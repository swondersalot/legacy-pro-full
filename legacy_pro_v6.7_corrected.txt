==== Full Code V6 ====

Message 1/5: Backend Core & Database Schema
/backend/package.json
{
  "name": "legacy-pro-backend",
  "version": "1.0.0",
  "main": "server.js",
  "scripts": {
    "dev": "NODE_ENV=development nodemon server.js",
    "start": "node server.js",
    "migrate": "prisma migrate dev --name init",
    "generate": "prisma generate"
  },
  "dependencies": {
    "@prisma/client": "^4.0.0",
    "bcrypt": "^5.0.1",
    "bull": "^4.0.0",
    "csurf": "^1.11.0",
    "dotenv": "^10.0.0",
    "express": "^4.17.1",
    "express-rate-limit": "^6.0.0",
    "firebase-admin": "^10.0.0",
    "jsdoc-to-swagger": "^1.0.0",
    "jsonwebtoken": "^8.5.1",
    "nodemailer": "^6.7.2",
    "plaid": "^10.0.0",
    "prisma": "^4.0.0",
    "stripe": "^8.0.0",
    "swagger-ui-express": "^4.1.6",
    "twilio": "^3.75.0",
    "zod": "^3.11.6"
  },
  "devDependencies": {
    "@types/express": "^4.17.13",
    "@types/node": "^16.11.7",
    "nodemon": "^2.0.15",
    "typescript": "^4.4.4"
  }
}
/backend/prisma/schema.prisma
prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id                String   @id @default(uuid())
  email             String   @unique
  passwordHash      String?
  name              String?
  avatarUrl         String?
  role              Role     @default(USER)
  twoFAEnabled      Boolean  @default(false)
  twoFASecret       String?
  locale            String   @default("en")
  firstTime         Boolean  @default(true)
  lastLogin         DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  sessions          Session[]
  userSubscriptions UserSubscription[]
  vaultFolders      VaultFolder[]
  vaultFiles        VaultFile[]
  auditLogs         AuditLog[]
  notifications     Notification[]
  notificationPrefs NotificationPreference[]
  userCheckIns      UserCheckIn[]
  aiUsageLogs       AIUsageLog[]
  trusts            Trust[]
  entities          Entity[]
  legacyLetters     LegacyLetter[]
  pushTokens        PushToken[]
  financialAccounts FinancialAccount[]
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  user         User     @relation(fields: [userId], references: [id])
  expires      DateTime
}

model SubscriptionPlan {
  id             String   @id @default(uuid())
  name           String   @unique
  stripePlanId   String   @unique
  priceCents     Int
  billingCycle   BillingCycle
  storageLimitMB Int
  createdAt      DateTime @default(now())
}

model UserSubscription {
  id             String           @id @default(uuid())
  userId         String
  planId         String
  status         SubscriptionStatus @default(PENDING)
  startDate      DateTime?
  endDate        DateTime?
  stripeSubId    String?
  cancelAt       DateTime?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user           User             @relation(fields: [userId], references: [id])
  plan           SubscriptionPlan @relation(fields: [planId], references: [id])

  @@index([userId])
}

model VaultFolder {
  id         String     @id @default(uuid())
  userId     String
  parentId   String?
  name       String
  path       String
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  user       User       @relation(fields: [userId], references: [id])
  parent     VaultFolder? @relation("FolderParent", fields: [parentId], references: [id])
  children   VaultFolder[] @relation("FolderParent")
  files      VaultFile[]
}

model VaultFile {
  id          String    @id @default(uuid())
  userId      String
  folderId    String
  fileName    String
  fileType    String
  size        Int
  s3Key       String    @unique
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  isArchived  Boolean   @default(false)

  user        User      @relation(fields: [userId], references: [id])
  folder      VaultFolder @relation(fields: [folderId], references: [id])
  auditLogs   AuditLog[]  @relation("FileActions")
}

model AuditLog {
  id           String    @id @default(uuid())
  userId       String
  resourceType ResourceType
  resourceId   String
  action       String
  metadata     Json?
  timestamp    DateTime  @default(now())

  user         User      @relation(fields: [userId], references: [id])
}

model Notification {
  id        String     @id @default(uuid())
  userId    String
  type      NotificationType
  content   Json
  read      Boolean     @default(false)
  createdAt DateTime    @default(now())

  user      User        @relation(fields: [userId], references: [id])
}

model NotificationPreference {
  id        String  @id @default(uuid())
  userId    String
  type      NotificationType
  enabled   Boolean @default(true)
  createdAt DateTime @default(now())

  user      User    @relation(fields: [userId], references: [id])

  @@unique([userId, type])
}

model UserCheckIn {
  id         String    @id @default(uuid())
  userId     String
  frequency  Frequency
  nextDate   DateTime
  lastSent   DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  user       User      @relation(fields: [userId], references: [id])
}

model AIUsageLog {
  id           String    @id @default(uuid())
  userId       String
  feature      FeatureType
  tokensUsed   Int
  promptHash   String
  createdAt    DateTime  @default(now())

  user         User      @relation(fields: [userId], references: [id])
}

model Trust {
  id             String      @id @default(uuid())
  userId         String
  trustName      String
  type           TrustType
  grantor        Json
  trustees       Json[]
  successorTrustees Json[]
  beneficiaries  Json[]
  state          String
  assetsIncluded Json[]
  additionalClauses String[]
  data           Json
  status         DraftStatus
  pdfS3Key       String?
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  user           User        @relation(fields: [userId], references: [id])
  auditLogs      AuditLog[]  @relation("TrustActions")
}

model Entity {
  id             String      @id @default(uuid())
  userId         String
  entityName     String
  type           EntityType
  owners         Json[]
  state          String
  purpose        String?
  capital        Json[]
  additionalClauses String[]
  data           Json
  status         DraftStatus
  pdfS3Key       String?
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  user           User        @relation(fields: [userId], references: [id])
  auditLogs      AuditLog[]  @relation("EntityActions")
}

model LegacyLetter {
  id          String     @id @default(uuid())
  userId      String
  tone        String
  recipients  String[]
  body        String
  attachedDocs Json[]
  status      DraftStatus
  pdfS3Key    String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user        User      @relation(fields: [userId], references: [id])
  auditLogs   AuditLog[]  @relation("LegacyLetterActions")
}

model PushToken {
  id         String   @id @default(uuid())
  userId     String
  deviceId   String
  token      String
  createdAt  DateTime @default(now())

  user       User     @relation(fields: [userId], references: [id])
}

model FinancialAccount {
  id            String    @id @default(uuid())
  userId        String
  provider      String
  accountData   Json
  accessToken   String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  user          User      @relation(fields: [userId], references: [id])
}

model Locale {
  id      String @id @default(uuid())
  code    String @unique
  name    String
}

model Translation {
  id       String @id @default(uuid())
  localeId String
  module   String
  key      String
  text     String

  locale   Locale @relation(fields: [localeId], references: [id])

  @@unique([localeId, module, key])
}

enum Role {
  USER
  ADMIN
}

enum SubscriptionStatus {
  PENDING
  ACTIVE
  CANCELED
}

enum BillingCycle {
  MONTHLY
  ANNUAL
}

enum ResourceType {
  VaultFile
  Trust
  Entity
  LegacyLetter
  User
  Notification
}

enum NotificationType {
  VaultAlert
  RegulatoryUpdate
  CheckInReminder
  ComplianceIssue
}

enum Frequency {
  DAILY
  WEEKLY
  MONTHLY
}

enum FeatureType {
  Advisor
  TrustBuilder
  EntityBuilder
  LegacyLetter
}

enum TrustType {
  REVOCABLE
  IRREVOCABLE
  SPECIAL_NEEDS
  DYNASTY
  MINOR
}

enum EntityType {
  LLC
  S_CORP
  C_CORP
  DBA
}

enum DraftStatus {
  DRAFT
  FINALIZED
}
/backend/prismaClient.ts
const { PrismaClient } = require("@prisma/client");
const prisma = new PrismaClient();
module.exports = prisma;
/backend/server.js
require("dotenv").config();
const express = require("express");
const cors = require("cors");
const swaggerUi = require("swagger-ui-express");
const swaggerDocument = require("./swagger.json");
const nextAuthRouter = require("./src/routes/auth");
const userRouter = require("./src/routes/users");
const subscriptionRouter = require("./src/routes/subscriptions");
const trustRouter = require("./src/routes/trusts");
const entityRouter = require("./src/routes/entities");
const vaultRouter = require("./src/routes/vault");
const aiRouter = require("./src/routes/ai");
const legacyLetterRouter = require("./src/routes/legacy-letter");
const protectionScoreRouter = require("./src/routes/protection-score");
const dashboardRouter = require("./src/routes/dashboard");
const adminRouter = require("./src/routes/admin");
const financialPlaidRouter = require("./src/routes/financial/plaid");
const notificationRouter = require("./src/routes/notifications");
const searchRouter = require("./src/routes/search");
const pushTokenRouter = require("./src/routes/push-notifications");
const { authLimiter, apiLimiter } = require("./src/middleware/rateLimiter");
const errorHandler = require("./src/middleware/errorHandler");
const csrfProtection = require("./src/middleware/csrfProtection");

const app = express();
app.use(cors());
app.use(express.json());

// Swagger docs
app.use("/api/docs", swaggerUi.serve, swaggerUi.setup(swaggerDocument));

// Rate limiting
app.use("/api/auth", authLimiter);
app.use("/api", apiLimiter);

// CSRF Protection
app.use(csrfProtection);

// Routes
app.use("/api/auth", nextAuthRouter);
app.use("/api/users", userRouter);
app.use("/api/subscriptions", subscriptionRouter);
app.use("/api/trusts", trustRouter);
app.use("/api/entities", entityRouter);
app.use("/api/vault", vaultRouter);
app.use("/api/ai", aiRouter);
app.use("/api/legacy-letter", legacyLetterRouter);
app.use("/api/protection-score", protectionScoreRouter);
app.use("/api/dashboard", dashboardRouter);
app.use("/api/admin", adminRouter);
app.use("/api/financial/plaid", financialPlaidRouter);
app.use("/api/notifications", notificationRouter);
app.use("/api/search", searchRouter);
app.use("/api/push-tokens", pushTokenRouter);

// Error handling
app.use(errorHandler);

const PORT = process.env.PORT || 4000;
app.listen(PORT, () => {
  console.log(`Legacy Pro backend running on port ${PORT}`);
});
Message 2/5: Backend Configuration & Middleware
/backend/src/config/index.js
require("dotenv").config();

module.exports = {
  DATABASE_URL: process.env.DATABASE_URL,
  NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET,
  JWT_SECRET: process.env.JWT_SECRET,
  STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY,
  STRIPE_WEBHOOK_SECRET: process.env.STRIPE_WEBHOOK_SECRET,
  OPENAI_API_KEY: process.env.OPENAI_API_KEY,
  TWILIO_ACCOUNT_SID: process.env.TWILIO_ACCOUNT_SID,
  TWILIO_AUTH_TOKEN: process.env.TWILIO_AUTH_TOKEN,
  TWILIO_PHONE_NUMBER: process.env.TWILIO_PHONE_NUMBER,
  PLAID_CLIENT_ID: process.env.PLAID_CLIENT_ID,
  PLAID_SECRET: process.env.PLAID_SECRET,
  PLAID_ENV: process.env.PLAID_ENV || "sandbox",
  YODLEE_CLIENT_ID: process.env.YODLEE_CLIENT_ID,
  YODLEE_SECRET: process.env.YODLEE_SECRET,
  EMAIL_SERVER: process.env.EMAIL_SERVER,
  EMAIL_FROM: process.env.EMAIL_FROM,
  FCM_SERVER_KEY: process.env.FCM_SERVER_KEY,
  RATE_LIMIT_WINDOW: process.env.RATE_LIMIT_WINDOW || 15 * 60 * 1000,
  RATE_LIMIT_MAX: process.env.RATE_LIMIT_MAX || 100
};
/backend/src/config/stripe.js
const Stripe = require("stripe");
const { STRIPE_SECRET_KEY } = require("./index");
const stripe = new Stripe(STRIPE_SECRET_KEY, { apiVersion: "2022-11-15" });
module.exports = stripe;
/backend/src/config/plaid.js
const { Configuration, PlaidApi, PlaidEnvironments } = require("plaid");
const { PLAID_CLIENT_ID, PLAID_SECRET, PLAID_ENV } = require("./index");

const config = new Configuration({
  basePath: PlaidEnvironments[PLAID_ENV],
  baseOptions: {
    headers: {
      "PLAID-CLIENT-ID": PLAID_CLIENT_ID,
      "PLAID-SECRET": PLAID_SECRET
    }
  }
});
const plaidClient = new PlaidApi(config);
module.exports = plaidClient;
/backend/src/config/sms.js
const Twilio = require("twilio");
const { TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, TWILIO_PHONE_NUMBER } = require("./index");
const client = new Twilio(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN);

async function sendSMS({ to, body }) {
  await client.messages.create({ from: TWILIO_PHONE_NUMBER, to, body });
}
module.exports = sendSMS;
/backend/src/config/email.js
const nodemailer = require("nodemailer");
const { EMAIL_SERVER, EMAIL_FROM } = require("./index");

const transporter = nodemailer.createTransport(EMAIL_SERVER);

async function sendEmail({ to, subject, html }) {
  await transporter.sendMail({ from: EMAIL_FROM, to, subject, html });
}

module.exports = sendEmail;
/backend/src/middleware/auth.js
const { getToken } = require("next-auth/jwt");
const ApiError = require("../utils/ApiError");

module.exports = async function authMiddleware(req, res, next) {
  try {
    const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });
    if (!token) throw new ApiError(401, "Not authenticated");
    req.user = { id: token.sub, role: token.role || "USER" };
    next();
  } catch (err) {
    next(err);
  }
};
/backend/src/middleware/rateLimiter.js
const rateLimit = require("express-rate-limit");
const { RATE_LIMIT_WINDOW, RATE_LIMIT_MAX } = require("../config");

const authLimiter = rateLimit({
  windowMs: RATE_LIMIT_WINDOW,
  max: 5,
  message: "Too many login attempts; please try again later.",
  keyGenerator: (req) => req.ip,
  skipSuccessfulRequests: true
});

const apiLimiter = rateLimit({
  windowMs: RATE_LIMIT_WINDOW,
  max: RATE_LIMIT_MAX,
  message: "Too many requests; please slow down.",
  keyGenerator: (req) => req.user?.id || req.ip
});

module.exports = { authLimiter, apiLimiter };
/backend/src/middleware/auditLogger.js
const prisma = require("../../prismaClient");

async function logAudit({ userId, resourceType, resourceId, action, metadata = {} }) {
  await prisma.auditLog.create({
    data: { userId, resourceType, resourceId, action, metadata }
  });
}

module.exports = logAudit;
/backend/src/middleware/csrfProtection.js
const csurf = require("csurf");
const csrfProtection = csurf({ cookie: true });
module.exports = csrfProtection;
/backend/src/middleware/errorHandler.js
function errorHandler(err, req, res, next) {
  console.error(err);
  if (err.isJoi || err.name === "ZodError") {
    return res.status(400).json({ error: err.message });
  }
  if (err.status) {
    return res.status(err.status).json({ error: err.message });
  }
  return res.status(500).json({ error: "Internal Server Error" });
}

module.exports = errorHandler;
/backend/src/utils/ApiError.js
class ApiError extends Error {
  constructor(status, message) {
    super(message);
    this.status = status;
  }
}

module.exports = ApiError;
/backend/src/utils/logger.js
const winston = require("winston");

const logger = winston.createLogger({
  level: process.env.NODE_ENV === "production" ? "info" : "debug",
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [new winston.transports.Console()]
});

module.exports = logger;
/backend/src/utils/validationSchemas.js
const Joi = require("joi");

const trustSchema = Joi.object({
  trustName: Joi.string().min(3).required(),
  type: Joi.string().valid("REVOCABLE", "IRREVOCABLE", "SPECIAL_NEEDS", "DYNASTY", "MINOR").required(),
  grantor: Joi.object({
    firstName: Joi.string().required(),
    lastName: Joi.string().required(),
    address: Joi.string().allow(""),
    DOB: Joi.string().isoDate().allow("")
  }).required(),
  trustees: Joi.array().items(
    Joi.object({
      firstName: Joi.string().required(),
      lastName: Joi.string().required(),
      address: Joi.string().allow("")
    })
  ).min(1).required(),
  beneficiaries: Joi.array().items(
    Joi.object({
      firstName: Joi.string().required(),
      lastName: Joi.string().required(),
      allocation: Joi.number().min(0).max(100).required(),
      DOB: Joi.string().isoDate().allow("")
    })
  ).min(1).required()
    .custom((list, helper) => {
      const sum = list.reduce((acc, b) => acc + b.allocation, 0);
      if (sum !== 100) return helper.message("Allocations must sum to 100%");
      return list;
    }),
  state: Joi.string().length(2).required(),
  additionalClauses: Joi.array().items(Joi.string()).optional(),
  assetsIncluded: Joi.array().items(
    Joi.object({
      type: Joi.string().required(),
      description: Joi.string().required()
    })
  ).optional()
});

module.exports = {
  trustSchema
};
Message 3/5: Backend Routes & Jobs
/backend/src/routes/auth/[...nextauth].ts
import NextAuth from "next-auth";
import Providers from "next-auth/providers";
import { PrismaAdapter } from "@next-auth/prisma-adapter";
import prisma from "../../../prismaClient";

export default NextAuth({
  adapter: PrismaAdapter(prisma),
  session: { jwt: true },
  jwt: { secret: process.env.NEXTAUTH_SECRET },
  providers: [
    Providers.Email({
      server: process.env.EMAIL_SERVER!,
      from: process.env.EMAIL_FROM!
    }),
    Providers.Google({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!
    }),
    Providers.GitHub({
      clientId: process.env.GITHUB_ID!,
      clientSecret: process.env.GITHUB_SECRET!
    })
  ],
  callbacks: {
    async session({ session, user }) {
      session.user.id = user.id;
      session.user.role = user.role;
      return session;
    }
  },
  pages: {
    signIn: "/login",
    signOut: "/",
    error: "/login?error="
  },
  events: {
    async signIn(message) {
      await prisma.user.update({
        where: { id: message.user.id },
        data: { lastLogin: new Date(), firstTime: false }
      });
    }
  }
});
/backend/src/routes/users/index.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";
import bcrypt from "bcrypt";
import sendEmail from "../../config/email";
import sendSMS from "../../config/sms";
import ApiError from "../../utils/ApiError";

const router = express.Router();

// GET /api/users/me
router.get("/me", authMiddleware, async (req, res, next) => {
  try {
    const user = await prisma.user.findUnique({ where: { id: req.user.id } });
    if (!user) throw new ApiError(404, "User not found");
    res.json(user);
  } catch (err) {
    next(err);
  }
});

// PATCH /api/users/me
router.patch("/me", authMiddleware, async (req, res, next) => {
  try {
    const { name, locale } = req.body;
    const updated = await prisma.user.update({
      where: { id: req.user.id },
      data: { name, locale }
    });
    res.json(updated);
  } catch (err) {
    next(err);
  }
});

// POST /api/users/me/avatar
router.post("/me/avatar", authMiddleware, async (req, res, next) => {
  try {
    const { fileName, fileType, size } = req.body;
    // Generate presigned PUT URL for S3 (omitted code for brevity)
    const key = `avatars/${req.user.id}/${fileName}`;
    const putUrl = await getPresignedPutUrl(key, fileType); // implement separately
    res.json({ key, url: putUrl });
  } catch (err) {
    next(err);
  }
});

// POST /api/users/me/password
router.post("/me/password", authMiddleware, async (req, res, next) => {
  try {
    const { currentPassword, newPassword } = req.body;
    const user = await prisma.user.findUnique({ where: { id: req.user.id } });
    if (!user?.passwordHash) throw new ApiError(400, "No password set");
    const match = await bcrypt.compare(currentPassword, user.passwordHash);
    if (!match) throw new ApiError(400, "Current password incorrect");
    const hash = await bcrypt.hash(newPassword, 10);
    await prisma.user.update({
      where: { id: req.user.id },
      data: { passwordHash: hash }
    });
    res.json({ message: "Password updated" });
  } catch (err) {
    next(err);
  }
});

// POST /api/users/me/2fa/setup
router.post("/me/2fa/setup", authMiddleware, async (req, res, next) => {
  try {
    const secret = generateTOTPSecret(); // implement separate
    const qrCodeDataURL = await generateQRCodeDataURL(secret); // implement
    await prisma.user.update({
      where: { id: req.user.id },
      data: { twoFASecret: encrypt(secret) } // implement encrypt
    });
    res.json({ qrCodeDataURL });
  } catch (err) {
    next(err);
  }
});

// POST /api/users/me/2fa/verify
router.post("/me/2fa/verify", authMiddleware, async (req, res, next) => {
  try {
    const { token } = req.body;
    const user = await prisma.user.findUnique({ where: { id: req.user.id } });
    const secret = decrypt(user?.twoFASecret!); // implement decrypt
    const valid = verifyTOTPToken(secret, token); // implement verify
    if (!valid) throw new ApiError(400, "Invalid token");
    await prisma.user.update({
      where: { id: req.user.id },
      data: { twoFAEnabled: true }
    });
    res.json({ message: "2FA enabled" });
  } catch (err) {
    next(err);
  }
});

// DELETE /api/users/me/2fa
router.delete("/me/2fa", authMiddleware, async (req, res, next) => {
  try {
    await prisma.user.update({
      where: { id: req.user.id },
      data: { twoFAEnabled: false, twoFASecret: null }
    });
    res.json({ message: "2FA disabled" });
  } catch (err) {
    next(err);
  }
});

// GET /api/users/checkins
router.get("/checkins", authMiddleware, async (req, res, next) => {
  try {
    const checkIns = await prisma.userCheckIn.findMany({ where: { userId: req.user.id } });
    res.json(checkIns);
  } catch (err) {
    next(err);
  }
});

// POST /api/users/checkins
router.post("/checkins", authMiddleware, async (req, res, next) => {
  try {
    const { frequency, nextDate } = req.body;
    const newCheckIn = await prisma.userCheckIn.create({
      data: { userId: req.user.id, frequency, nextDate: new Date(nextDate) }
    });
    res.json(newCheckIn);
  } catch (err) {
    next(err);
  }
});

// PATCH /api/users/checkins/:id
router.patch("/checkins/:id", authMiddleware, async (req, res, next) => {
  try {
    const { frequency, nextDate } = req.body;
    const updated = await prisma.userCheckIn.update({
      where: { id: req.params.id },
      data: { frequency, nextDate: new Date(nextDate) }
    });
    res.json(updated);
  } catch (err) {
    next(err);
  }
});

// DELETE /api/users/checkins/:id
router.delete("/checkins/:id", authMiddleware, async (req, res, next) => {
  try {
    await prisma.userCheckIn.delete({ where: { id: req.params.id } });
    res.json({ message: "Deleted" });
  } catch (err) {
    next(err);
  }
});

// GET /api/users/notifications
router.get("/notifications", authMiddleware, async (req, res, next) => {
  try {
    const notifications = await prisma.notification.findMany({
      where: { userId: req.user.id },
      orderBy: { createdAt: "desc" }
    });
    res.json(notifications);
  } catch (err) {
    next(err);
  }
});

// PATCH /api/users/notifications/:id/mark-read
router.patch("/notifications/:id/mark-read", authMiddleware, async (req, res, next) => {
  try {
    const updated = await prisma.notification.update({
      where: { id: req.params.id },
      data: { read: true }
    });
    res.json(updated);
  } catch (err) {
    next(err);
  }
});

// PATCH /api/users/notifications (preferences)
router.patch("/notifications", authMiddleware, async (req, res, next) => {
  try {
    const { type, enabled } = req.body;
    const pref = await prisma.notificationPreference.upsert({
      where: { userId_type: { userId: req.user.id, type } },
      update: { enabled },
      create: { userId: req.user.id, type, enabled }
    });
    res.json(pref);
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/subscriptions/plans.ts
import express from "express";
import prisma from "../../../prismaClient";

const router = express.Router();

// GET /api/subscriptions/plans
router.get("/plans", async (req, res, next) => {
  try {
    const plans = await prisma.subscriptionPlan.findMany();
    res.json(plans);
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/subscriptions/subscribe.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";
import stripe from "../../config/stripe";
import ApiError from "../../utils/ApiError";

const router = express.Router();

// POST /api/subscriptions/subscribe
router.post("/subscribe", authMiddleware, async (req, res, next) => {
  try {
    const { planId } = req.body;
    const user = await prisma.user.findUnique({ where: { id: req.user.id } });
    const plan = await prisma.subscriptionPlan.findUnique({ where: { id: planId } });
    if (!plan) throw new ApiError(404, "Plan not found");

    if (plan.priceCents === 0) {
      const subscription = await prisma.userSubscription.create({
        data: {
          userId: user!.id,
          planId: plan.id,
          status: "ACTIVE",
          startDate: new Date()
        }
      });
      return res.json({ subscription });
    }

    const session = await stripe.checkout.sessions.create({
      mode: "subscription",
      payment_method_types: ["card"],
      customer_email: user!.email!,
      line_items: [{ price: plan.stripePlanId, quantity: 1 }],
      success_url: `${process.env.FRONTEND_URL}/settings/plan?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${process.env.FRONTEND_URL}/settings/plan`
    });

    res.json({ sessionId: session.id, url: session.url });
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/subscriptions/webhook.ts
import express from "express";
import { buffer } from "micro";
import stripe from "../../config/stripe";
import prisma from "../../../prismaClient";

const router = express.Router();
const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET!;

// Skip body parsing, use raw buffer
export const config = { api: { bodyParser: false } };

router.post("/webhook", async (req, res) => {
  const sig = req.headers["stripe-signature"]!;
  const buf = await buffer(req);
  let event;

  try {
    event = stripe.webhooks.constructEvent(buf, sig, endpointSecret);
  } catch (err) {
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  switch (event.type) {
    case "checkout.session.completed": {
      const session = event.data.object;
      const user = await prisma.user.findUnique({
        where: { email: session.customer_email }
      });
      const plan = await prisma.subscriptionPlan.findUnique({
        where: { stripePlanId: session.display_items[0].price.id }
      });
      if (user && plan) {
        await prisma.userSubscription.upsert({
          where: { userId: user.id },
          update: {
            status: "ACTIVE",
            stripeSubId: session.subscription,
            startDate: new Date()
          },
          create: {
            userId: user.id,
            planId: plan.id,
            status: "ACTIVE",
            stripeSubId: session.subscription,
            startDate: new Date()
          }
        });
      }
      break;
    }
    case "invoice.payment_failed":
    case "customer.subscription.deleted": {
      const subscriptionId = event.data.object.id;
      await prisma.userSubscription.updateMany({
        where: { stripeSubId: subscriptionId },
        data: { status: "CANCELED", endDate: new Date() }
      });
      break;
    }
    default:
      break;
  }
  res.json({ received: true });
});

export default router;
/backend/src/routes/subscriptions/status.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";

const router = express.Router();

// GET /api/subscriptions/status
router.get("/status", authMiddleware, async (req, res, next) => {
  try {
    const subscription = await prisma.userSubscription.findFirst({
      where: { userId: req.user.id },
      include: { plan: true }
    });
    if (!subscription) {
      return res.json({ planName: "None", status: "NONE", storageUsedMB: 0, storageLimitMB: 0 });
    }
    const storageUsedBytes = await prisma.vaultFile.aggregate({
      where: { userId: req.user.id },
      _sum: { size: true }
    });
    const storageUsedMB = Math.ceil((storageUsedBytes._sum.size || 0) / (1024 * 1024));
    res.json({
      planName: subscription.plan.name,
      status: subscription.status,
      storageUsedMB,
      storageLimitMB: subscription.plan.storageLimitMB,
      nextBillingDate: subscription.endDate
    });
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/trusts/clauses.ts
import express from "express";
import clausesData from "../../../data/clauses.json";

const router = express.Router();

// GET /api/trusts/clauses?state=XX
router.get("/clauses", (req, res) => {
  const state = (req.query.state as string)?.toUpperCase();
  if (!state) return res.status(400).json({ error: "State parameter is required." });
  const clauses = clausesData[state] || [];
  res.json({ clauses });
});

export default router;
/backend/src/routes/trusts/generate.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";
import { trustSchema } from "../../utils/validationSchemas";
import OpenAI from "openai";
import logAudit from "../../middleware/auditLogger";
import ApiError from "../../utils/ApiError";

const router = express.Router();
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

router.post("/generate", authMiddleware, async (req, res, next) => {
  try {
    const validation = trustSchema.validate(req.body);
    if (validation.error) throw new ApiError(400, validation.error.details[0].message);

    const input = req.body;
    const newTrust = await prisma.trust.create({
      data: {
        userId: req.user.id,
        trustName: input.trustName,
        type: input.type,
        grantor: input.grantor,
        trustees: input.trustees,
        successorTrustees: input.successorTrustees,
        beneficiaries: input.beneficiaries,
        state: input.state,
        assetsIncluded: input.assetsIncluded || [],
        additionalClauses: input.additionalClauses || [],
        data: {},
        status: "DRAFT"
      }
    });

    const clauseTexts = input.additionalClauses.map((id: string) => {
      // Find full clause text from clausesData
      const allClauses = clausesData[input.state];
      const clause = allClauses.find((c: any) => c.id === id);
      return clause ? clause.text : "";
    });

    const prompt = `
You are LegalGPT. Generate a ${input.type} Trust for ${input.state}.
Grantor: ${JSON.stringify(input.grantor)}.
Trustees: ${JSON.stringify(input.trustees)}.
Successor Trustees: ${JSON.stringify(input.successorTrustees)}.
Beneficiaries: ${JSON.stringify(input.beneficiaries)}.
Assets: ${JSON.stringify(input.assetsIncluded)}.
Include clauses: ${clauseTexts.join("\n\n")}.
Respond with final document text only.
`;

    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");

    let documentText = "";
    const completion = await openai.chat.completions.create({
      model: "gpt-4-turbo",
      messages: [
        { role: "system", content: "You are LegalGPT, an estate planning AI." },
        { role: "user", content: prompt }
      ],
      stream: true
    });

    for await (const chunk of completion) {
      const text = chunk.choices[0].delta?.content || "";
      documentText += text;
      res.write(text);
    }
    res.end();

    await prisma.trust.update({
      where: { id: newTrust.id },
      data: { data: { text: documentText } }
    });

    await logAudit({
      userId: req.user.id,
      resourceType: "Trust",
      resourceId: newTrust.id,
      action: "generated_draft",
      metadata: { tokensUsed: completion.usage.total_tokens }
    });
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/trusts/compliance-check.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";
import OpenAI from "openai";
import ApiError from "../../utils/ApiError";

const router = express.Router();
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

router.post("/compliance-check", authMiddleware, async (req, res, next) => {
  try {
    const { trustId } = req.body;
    const trust = await prisma.trust.findUnique({ where: { id: trustId } });
    if (!trust) throw new ApiError(404, "Trust not found");

    const prompt = `
You are ComplianceGPT, an attorney AI. Review the following ${trust.type} Trust for ${trust.state} compliance. Identify missing required sections or issues. Return JSON: { "pass": boolean, "issues": string[] }.
Document:
${(trust.data as any).text || ""}
    `;

    const response = await openai.chat.completions.create({
      model: "gpt-4-turbo",
      messages: [
        { role: "system", content: "You are ComplianceGPT, a corporate law expert." },
        { role: "user", content: prompt }
      ]
    });

    let json;
    try {
      json = JSON.parse(response.choices[0].message.content);
    } catch {
      throw new ApiError(500, "Invalid compliance response format");
    }

    res.json(json);
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/trusts/finalize.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";
import PDFDocument from "pdf-lib";
import AWS from "aws-sdk";
import logAudit from "../../middleware/auditLogger";
import ApiError from "../../utils/ApiError";

const router = express.Router();
const s3 = new AWS.S3();

router.post("/:id/finalize", authMiddleware, async (req, res, next) => {
  try {
    const trust = await prisma.trust.findUnique({ where: { id: req.params.id } });
    if (!trust) throw new ApiError(404, "Trust not found");

    // Generate PDF using PDFDocument from trust.data.text
    const doc = await PDFDocument.create();
    const page = doc.addPage();
    page.drawText((trust.data as any).text || "", { x: 50, y: 700, size: 12, maxWidth: 500 });
    const pdfBytes = await doc.save();

    const key = `trusts/${trust.id}.pdf`;
    await s3
      .putObject({
        Bucket: process.env.S3_BUCKET_NAME!,
        Key: key,
        Body: Buffer.from(pdfBytes),
        ContentType: "application/pdf"
      })
      .promise();

    await prisma.trust.update({
      where: { id: trust.id },
      data: { status: "FINALIZED", pdfS3Key: key }
    });

    await prisma.vaultFile.create({
      data: {
        userId: req.user.id,
        folderId: await getTrustsFolderId(req.user.id), // implement helper to find folder
        fileName: `${trust.trustName}.pdf`,
        fileType: "application/pdf",
        size: pdfBytes.length,
        s3Key: key
      }
    });

    await logAudit({
      userId: req.user.id,
      resourceType: "Trust",
      resourceId: trust.id,
      action: "finalized",
      metadata: {}
    });

    const presignedUrl = s3.getSignedUrl("getObject", {
      Bucket: process.env.S3_BUCKET_NAME!,
      Key: key,
      Expires: 60 * 5
    });

    res.json({ url: presignedUrl });
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/entities/generate.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";
import { z } from "zod";
import OpenAI from "openai";
import logAudit from "../../middleware/auditLogger";
import ApiError from "../../utils/ApiError";

const router = express.Router();
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

const entitySchema = z.object({
  entityName: z.string().min(3),
  type: z.enum(["LLC", "S_CORP", "C_CORP", "DBA"]),
  owners: z.array(z.object({ name: z.string(), percentage: z.number().min(0).max(100) })).min(1)
    .refine(list => list.reduce((sum, o) => sum + o.percentage, 0) === 100, { message: "Percentages must sum to 100%" }),
  registeredAgent: z.object({ name: z.string(), address: z.string() }),
  state: z.string().length(2),
  purpose: z.string().optional(),
  capital: z.array(z.object({ amount: z.number().positive(), contributionDate: z.string().optional() })).optional(),
  additionalClauses: z.array(z.string()).optional()
});

router.post("/generate", authMiddleware, async (req, res, next) => {
  try {
    const validation = entitySchema.safeParse(req.body);
    if (!validation.success) throw new ApiError(400, validation.error.errors[0].message);

    const input = validation.data;
    const newEntity = await prisma.entity.create({
      data: {
        userId: req.user.id,
        entityName: input.entityName,
        type: input.type,
        owners: input.owners,
        state: input.state,
        purpose: input.purpose,
        capital: input.capital || [],
        additionalClauses: input.additionalClauses || [],
        data: {},
        status: "DRAFT"
      }
    });

    const prompt = `
You are a corporate attorney AI. Generate Articles of Organization for a ${input.type} named ${input.entityName} in ${input.state}, owned by ${JSON.stringify(input.owners)}, registered agent ${JSON.stringify(input.registeredAgent)}, purpose ${input.purpose || "N/A"}. Include any additional clauses: ${JSON.stringify(input.additionalClauses || [])}. Provide the final document text only.
`;

    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");

    let documentText = "";
    const completion = await openai.chat.completions.create({
      model: "gpt-4-turbo",
      messages: [
        { role: "system", content: "You are ComplianceGPT, a corporate law expert." },
        { role: "user", content: prompt }
      ],
      stream: true
    });

    for await (const chunk of completion) {
      const text = chunk.choices[0].delta?.content || "";
      documentText += text;
      res.write(text);
    }
    res.end();

    await prisma.entity.update({
      where: { id: newEntity.id },
      data: { data: { text: documentText } }
    });

    await logAudit({
      userId: req.user.id,
      resourceType: "Entity",
      resourceId: newEntity.id,
      action: "generated_draft",
      metadata: { tokensUsed: completion.usage.total_tokens }
    });
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/entities/compliance-check.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";
import OpenAI from "openai";
import ApiError from "../../utils/ApiError";

const router = express.Router();
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

router.post("/compliance-check", authMiddleware, async (req, res, next) => {
  try {
    const { entityId } = req.body;
    const entity = await prisma.entity.findUnique({ where: { id: entityId } });
    if (!entity) throw new ApiError(404, "Entity not found");

    const prompt = `
You are ComplianceGPT, a corporate law expert. Review the following ${entity.type} formation document for ${entity.state} compliance. Return JSON: { "pass": boolean, "issues": string[] }.
Document:
${(entity.data as any).text || ""}
    `;

    const response = await openai.chat.completions.create({
      model: "gpt-4-turbo",
      messages: [
        { role: "system", content: "You are ComplianceGPT." },
        { role: "user", content: prompt }
      ]
    });

    let json;
    try {
      json = JSON.parse(response.choices[0].message.content);
    } catch {
      throw new ApiError(500, "Invalid compliance response format");
    }

    res.json(json);
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/entities/finalize.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";
import { PDFDocument } from "pdf-lib";
import AWS from "aws-sdk";
import logAudit from "../../middleware/auditLogger";
import ApiError from "../../utils/ApiError";

const router = express.Router();
const s3 = new AWS.S3();

router.post("/:id/finalize", authMiddleware, async (req, res, next) => {
  try {
    const entity = await prisma.entity.findUnique({ where: { id: req.params.id } });
    if (!entity) throw new ApiError(404, "Entity not found");

    const doc = await PDFDocument.create();
    const page = doc.addPage();
    page.drawText((entity.data as any).text || "", { x: 50, y: 700, size: 12, maxWidth: 500 });
    const pdfBytes = await doc.save();

    const key = `entities/${entity.id}.pdf`;
    await s3.putObject({
      Bucket: process.env.S3_BUCKET_NAME!,
      Key: key,
      Body: Buffer.from(pdfBytes),
      ContentType: "application/pdf"
    }).promise();

    await prisma.entity.update({
      where: { id: entity.id },
      data: { status: "FINALIZED", pdfS3Key: key }
    });

    await prisma.vaultFile.create({
      data: {
        userId: req.user.id,
        folderId: await getEntitiesFolderId(req.user.id), // implement helper
        fileName: `${entity.entityName}.pdf`,
        fileType: "application/pdf",
        size: pdfBytes.length,
        s3Key: key
      }
    });

    await logAudit({
      userId: req.user.id,
      resourceType: "Entity",
      resourceId: entity.id,
      action: "finalized",
      metadata: {}
    });

    const presignedUrl = s3.getSignedUrl("getObject", {
      Bucket: process.env.S3_BUCKET_NAME!,
      Key: key,
      Expires: 300
    });

    res.json({ url: presignedUrl });
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/vault/folders.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";
import ApiError from "../../utils/ApiError";

const router = express.Router();

// GET /api/vault/folders (get full tree)
router.get("/", authMiddleware, async (req, res, next) => {
  try {
    const folders = await prisma.vaultFolder.findMany({
      where: { userId: req.user.id },
      orderBy: { path: "asc" }
    });
    res.json(folders);
  } catch (err) {
    next(err);
  }
});

// POST /api/vault/folders (create new folder)
router.post("/", authMiddleware, async (req, res, next) => {
  try {
    const { name, parentId } = req.body;
    const parent = parentId ? await prisma.vaultFolder.findUnique({ where: { id: parentId } }) : null;
    const path = parent ? `${parent.path}/${name}` : `/${name}`;
    const newFolder = await prisma.vaultFolder.create({
      data: {
        userId: req.user.id,
        parentId: parentId || null,
        name,
        path
      }
    });
    res.json(newFolder);
  } catch (err) {
    next(err);
  }
});

// PATCH /api/vault/folders/:id (rename/move)
router.patch("/:id", authMiddleware, async (req, res, next) => {
  try {
    const { name, parentId } = req.body;
    const folder = await prisma.vaultFolder.findUnique({ where: { id: req.params.id } });
    if (!folder) throw new ApiError(404, "Folder not found");

    let newPath = `/${name}`;
    if (parentId) {
      const parent = await prisma.vaultFolder.findUnique({ where: { id: parentId } });
      if (!parent) throw new ApiError(404, "Parent not found");
      newPath = `${parent.path}/${name}`;
    }

    const updated = await prisma.vaultFolder.update({
      where: { id: folder.id },
      data: { name, parentId: parentId || null, path: newPath }
    });

    // Update paths of children recursively (omitted for brevity)
    await updateChildrenPaths(folder.id, newPath); // implement recursively

    res.json(updated);
  } catch (err) {
    next(err);
  }
});

// DELETE /api/vault/folders/:id
router.delete("/:id", authMiddleware, async (req, res, next) => {
  try {
    const folder = await prisma.vaultFolder.findUnique({ where: { id: req.params.id } });
    if (!folder) throw new ApiError(404, "Folder not found");
    // Optionally, delete all nested files and folders (implement cascade behavior)
    await deleteFolderRecursively(folder.id);
    res.json({ message: "Folder deleted" });
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/vault/files.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";
import logAudit from "../../middleware/auditLogger";
import ApiError from "../../utils/ApiError";

const router = express.Router();

// GET /api/vault/folders/:folderId/files
router.get("/folders/:folderId/files", authMiddleware, async (req, res, next) => {
  try {
    const files = await prisma.vaultFile.findMany({
      where: { folderId: req.params.folderId },
      orderBy: { createdAt: "desc" }
    });
    res.json(files);
  } catch (err) {
    next(err);
  }
});

// POST /api/vault/files (after S3 PUT)
router.post("/", authMiddleware, async (req, res, next) => {
  try {
    const { fileName, fileType, size, folderId, s3Key } = req.body;
    const file = await prisma.vaultFile.create({
      data: { userId: req.user.id, fileName, fileType, size, folderId, s3Key }
    });
    await logAudit({
      userId: req.user.id,
      resourceType: "VaultFile",
      resourceId: file.id,
      action: "uploaded",
      metadata: { folderId, fileName, size }
    });
    res.json(file);
  } catch (err) {
    next(err);
  }
});

// GET /api/vault/files/:fileId/download-url
router.get("/files/:fileId/download-url", authMiddleware, async (req, res, next) => {
  try {
    const file = await prisma.vaultFile.findUnique({ where: { id: req.params.fileId } });
    if (!file) throw new ApiError(404, "File not found");
    const s3 = new (require("aws-sdk")).S3();
    const url = s3.getSignedUrl("getObject", {
      Bucket: process.env.S3_BUCKET_NAME!,
      Key: file.s3Key,
      Expires: 300
    });
    await logAudit({
      userId: req.user.id,
      resourceType: "VaultFile",
      resourceId: file.id,
      action: "downloaded",
      metadata: {}
    });
    res.json({ url });
  } catch (err) {
    next(err);
  }
});

// PATCH /api/vault/files/:fileId
router.patch("/files/:fileId", authMiddleware, async (req, res, next) => {
  try {
    const { fileName, folderId } = req.body;
    const file = await prisma.vaultFile.findUnique({ where: { id: req.params.fileId } });
    if (!file) throw new ApiError(404, "File not found");

    const updated = await prisma.vaultFile.update({
      where: { id: file.id },
      data: { fileName: fileName || file.fileName, folderId: folderId || file.folderId }
    });

    await logAudit({
      userId: req.user.id,
      resourceType: "VaultFile",
      resourceId: file.id,
      action: folderId ? "moved" : "renamed",
      metadata: { oldFileName: file.fileName, newFileName: updated.fileName, newFolderId: folderId }
    });

    res.json(updated);
  } catch (err) {
    next(err);
  }
});

// DELETE /api/vault/files
router.delete("/files", authMiddleware, async (req, res, next) => {
  try {
    const { fileIds } = req.body; // array of IDs
    if (!Array.isArray(fileIds)) throw new ApiError(400, "fileIds must be an array");

    const files = await prisma.vaultFile.findMany({ where: { id: { in: fileIds } } });
    if (files.length === 0) throw new ApiError(404, "No files found");

    // Delete from S3 and DB
    const s3 = new (require("aws-sdk")).S3();
    await Promise.all(
      files.map((f) =>
        s3.deleteObject({ Bucket: process.env.S3_BUCKET_NAME!, Key: f.s3Key }).promise()
      )
    );
    await prisma.vaultFile.deleteMany({ where: { id: { in: fileIds } } });

    await Promise.all(
      files.map((f) =>
        logAudit({
          userId: req.user.id,
          resourceType: "VaultFile",
          resourceId: f.id,
          action: "deleted",
          metadata: {}
        })
      )
    );

    res.json({ message: "Files deleted" });
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/vault/upload-url.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import { v4 as uuidv4 } from "uuid";
import AWS from "aws-sdk";

const router = express.Router();
const s3 = new AWS.S3();

// POST /api/vault/upload-url
router.post("/upload-url", authMiddleware, async (req, res, next) => {
  try {
    const { fileName, fileType, size } = req.body;
    const key = `vault/${req.user.id}/${uuidv4()}-${fileName}`;
    const url = s3.getSignedUrl("putObject", {
      Bucket: process.env.S3_BUCKET_NAME!,
      Key: key,
      ContentType: fileType,
      Expires: 300
    });
    res.json({ key, url });
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/vault/export.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";
import archiver from "archiver";
import AWS from "aws-sdk";
import ApiError from "../../utils/ApiError";

const router = express.Router();
const s3 = new AWS.S3();

// POST /api/vault/export
router.post("/export", authMiddleware, async (req, res, next) => {
  try {
    const { fileIds } = req.body;
    if (!Array.isArray(fileIds)) throw new ApiError(400, "fileIds must be an array");

    const files = await prisma.vaultFile.findMany({ where: { id: { in: fileIds } } });
    if (files.length === 0) throw new ApiError(404, "No files found");

    res.setHeader("Content-Type", "application/zip");
    res.setHeader("Content-Disposition", 'attachment; filename="vault_export.zip"');

    const archive = archiver("zip");
    archive.on("error", (err) => next(err));
    archive.pipe(res);

    for (const file of files) {
      const s3Stream = s3.getObject({ Bucket: process.env.S3_BUCKET_NAME!, Key: file.s3Key }).createReadStream();
      archive.append(s3Stream, { name: file.fileName });
    }

    await archive.finalize();
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/vault/emergency.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";
import { v4 as uuidv4 } from "uuid";
import sendEmail from "../../config/email";
import ApiError from "../../utils/ApiError";

const router = express.Router();

// POST /api/vault/emergency
router.post("/", authMiddleware, async (req, res, next) => {
  try {
    const { folderId, granteeEmail, expiresAt } = req.body;
    const folder = await prisma.vaultFolder.findUnique({ where: { id: folderId } });
    if (!folder || folder.userId !== req.user.id) throw new ApiError(404, "Folder not found");

    const grantee = await prisma.user.findUnique({ where: { email: granteeEmail } });
    if (!grantee) throw new ApiError(400, "Grantee must have a Legacy Pro account");

    const code = uuidv4().slice(0, 8);
    const emergency = await prisma.emergencyAccess.create({
      data: {
        folderId,
        granteeUserId: grantee.id,
        expiresAt: new Date(expiresAt),
        code
      }
    });

    const link = `${process.env.FRONTEND_URL}/emergency/${code}`;
    await sendEmail({
      to: granteeEmail,
      subject: "Legacy Pro Emergency Access Granted",
      html: `<p>You have been granted emergency access to folder <strong>${folder.path}</strong>. View here: <a href="${link}">${link}</a>. This link expires on ${new Date(expiresAt).toDateString()}.</p>`
    });

    res.json({ message: "Emergency access granted" });
  } catch (err) {
    next(err);
  }
});

// GET /api/vault/emergency/:code
router.get("/:code", async (req, res, next) => {
  try {
    const access = await prisma.emergencyAccess.findUnique({ where: { code: req.params.code } });
    if (!access || new Date(access.expiresAt) < new Date()) {
      return res.status(410).json({ error: "Access expired or invalid" });
    }
    const files = await prisma.vaultFile.findMany({ where: { folderId: access.folderId } });
    const s3 = new (require("aws-sdk")).S3();
    const filesWithUrls = files.map((f) => {
      const url = s3.getSignedUrl("getObject", {
        Bucket: process.env.S3_BUCKET_NAME!,
        Key: f.s3Key,
        Expires: 300
      });
      return { id: f.id, fileName: f.fileName, url };
    });
    res.json({ files: filesWithUrls });
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/search/index.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";

const router = express.Router();

// GET /api/search?q=...
router.get("/", authMiddleware, async (req, res, next) => {
  try {
    const { q } = req.query;
    if (!q || typeof q !== "string") return res.status(400).json({ error: "Query is required." });
    const formattedQuery = q.trim().replace(/[^a-zA-Z0-9 ]/g, "");
    const tsQuery = formattedQuery.split(" ").join(" & ");

    const trusts = await prisma.$queryRaw`
      SELECT id, "trustName" AS title, 'Trust' AS type
      FROM "Trust"
      WHERE to_tsvector("textSearch") @@ plainto_tsquery(${tsQuery})
      LIMIT 5;
    `;
    const entities = await prisma.$queryRaw`
      SELECT id, "entityName" AS title, 'Entity' AS type
      FROM "Entity"
      WHERE to_tsvector("textSearch") @@ plainto_tsquery(${tsQuery})
      LIMIT 5;
    `;
    const files = await prisma.$queryRaw`
      SELECT id, "fileName" AS title, 'VaultFile' AS type
      FROM "VaultFile"
      WHERE to_tsvector("fileName") @@ plainto_tsquery(${tsQuery})
      LIMIT 5;
    `;

    res.json({ results: [...trusts, ...entities, ...files] });
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/ai/advisor.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";
import OpenAI from "openai";
import logAudit from "../../middleware/auditLogger";
import ApiError from "../../utils/ApiError";

const router = express.Router();
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// POST /api/ai/advisor
router.post("/", authMiddleware, async (req, res, next) => {
  try {
    const { message } = req.body;
    if (!message) throw new ApiError(400, "Message is required");

    // Check token quota
    const usage = await prisma.aIUsageLog.aggregate({
      where: { userId: req.user.id, feature: "Advisor", createdAt: { gt: /* start of billing period */ new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) } },
      _sum: { tokensUsed: true }
    });
    const used = usage._sum.tokensUsed || 0;
    const plan = await prisma.userSubscription.findFirst({ where: { userId: req.user.id }, include: { plan: true } });
    const tokenLimit = plan?.plan.priceCents! * 100; // example formula
    if (used >= tokenLimit) throw new ApiError(402, "Quota exceeded");

    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");

    let aiText = "";
    const completion = await openai.chat.completions.create({
      model: "gpt-4-turbo",
      messages: [
        { role: "system", content: "You are Ava, a friendly legal and legacy planning advisor." },
        { role: "user", content: message }
      ],
      stream: true
    });

    for await (const chunk of completion) {
      const text = chunk.choices[0].delta?.content || "";
      aiText += text;
      res.write(text);
    }
    res.end();

    await prisma.aIUsageLog.create({
      data: {
        userId: req.user.id,
        feature: "Advisor",
        tokensUsed: completion.usage.total_tokens,
        promptHash: hashPrompt(message) // implement hash function
      }
    });

    await logAudit({
      userId: req.user.id,
      resourceType: "User",
      resourceId: req.user.id,
      action: "ai_advisor",
      metadata: { tokensUsed: completion.usage.total_tokens }
    });
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/legacy-letter/generate.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";
import OpenAI from "openai";
import logAudit from "../../middleware/auditLogger";
import ApiError from "../../utils/ApiError";

const router = express.Router();
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// POST /api/legacy-letter/generate
router.post("/generate", authMiddleware, async (req, res, next) => {
  try {
    const { tone, recipients, attachedDocs } = req.body;
    if (!tone || !recipients || !Array.isArray(recipients)) throw new ApiError(400, "Invalid input");

    const newLetter = await prisma.legacyLetter.create({
      data: {
        userId: req.user.id,
        tone,
        recipients,
        attachedDocs,
        status: "DRAFT"
      }
    });

    // Fetch summaries of attached documents
    const docsData = await Promise.all(
      attachedDocs.map(async (key: string) => {
        // fetch from S3 or DB as needed (omitted for brevity)
        return await getDocSummary(key); // implement helper
      })
    );

    const prompt = `
You are an estate planning advisor AI. Draft a ${tone} legacy letter addressed to ${recipients.join(", ")}. Summaries: ${JSON.stringify(docsData)}. Provide final letter text.
`;

    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");

    let letterText = "";
    const completion = await openai.chat.completions.create({
      model: "gpt-4-turbo",
      messages: [
        { role: "system", content: "You are ComplianceGPT, a legal advisor." },
        { role: "user", content: prompt }
      ],
      stream: true
    });

    for await (const chunk of completion) {
      const text = chunk.choices[0].delta?.content || "";
      letterText += text;
      res.write(text);
    }
    res.end();

    await prisma.legacyLetter.update({
      where: { id: newLetter.id },
      data: { body: letterText }
    });

    await logAudit({
      userId: req.user.id,
      resourceType: "LegacyLetter",
      resourceId: newLetter.id,
      action: "generated_draft",
      metadata: { tokensUsed: completion.usage.total_tokens }
    });
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/legacy-letter/compliance-check.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";
import OpenAI from "openai";
import ApiError from "../../utils/ApiError";

const router = express.Router();
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// POST /api/legacy-letter/compliance-check
router.post("/compliance-check", authMiddleware, async (req, res, next) => {
  try {
    const { letterId } = req.body;
    const letter = await prisma.legacyLetter.findUnique({ where: { id: letterId } });
    if (!letter) throw new ApiError(404, "Letter not found");

    const prompt = `
You are ComplianceGPT. Review this legacy letter for legal completeness and tone. Return JSON: { "pass": boolean, "issues": [string] }.
Letter:
${letter.body}
`;

    const response = await openai.chat.completions.create({
      model: "gpt-4-turbo",
      messages: [
        { role: "system", content: "You are ComplianceGPT." },
        { role: "user", content: prompt }
      ]
    });

    let json;
    try {
      json = JSON.parse(response.choices[0].message.content);
    } catch {
      throw new ApiError(500, "Invalid compliance response format");
    }

    res.json(json);
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/legacy-letter/finalize.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";
import { PDFDocument } from "pdf-lib";
import AWS from "aws-sdk";
import logAudit from "../../middleware/auditLogger";
import ApiError from "../../utils/ApiError";

const router = express.Router();
const s3 = new AWS.S3();

// POST /api/legacy-letter/:id/finalize
router.post("/:id/finalize", authMiddleware, async (req, res, next) => {
  try {
    const letter = await prisma.legacyLetter.findUnique({ where: { id: req.params.id } });
    if (!letter) throw new ApiError(404, "Letter not found");

    const doc = await PDFDocument.create();
    const page = doc.addPage();
    page.drawText(letter.body, { x: 50, y: 700, size: 12, maxWidth: 500 });
    const pdfBytes = await doc.save();

    const key = `legacy-letters/${letter.id}.pdf`;
    await s3.putObject({
      Bucket: process.env.S3_BUCKET_NAME!,
      Key: key,
      Body: Buffer.from(pdfBytes),
      ContentType: "application/pdf"
    }).promise();

    await prisma.legacyLetter.update({
      where: { id: letter.id },
      data: { status: "FINALIZED", pdfS3Key: key }
    });

    await prisma.vaultFile.create({
      data: {
        userId: req.user.id,
        folderId: await getLegacyLettersFolderId(req.user.id), // implement helper
        fileName: `LegacyLetter_${letter.id}.pdf`,
        fileType: "application/pdf",
        size: pdfBytes.length,
        s3Key: key
      }
    });

    await logAudit({
      userId: req.user.id,
      resourceType: "LegacyLetter",
      resourceId: letter.id,
      action: "finalized",
      metadata: {}
    });

    const presignedUrl = s3.getSignedUrl("getObject", {
      Bucket: process.env.S3_BUCKET_NAME!,
      Key: key,
      Expires: 300
    });

    res.json({ url: presignedUrl });
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/protection-score/index.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";

const router = express.Router();

// GET /api/protection-score
router.get("/", authMiddleware, async (req, res, next) => {
  try {
    const userId = req.user.id;
    let breakdown = { trust: 0, entity: 0, vault: 0, security: 0, financial: 0 };
    const suggestions: string[] = [];

    // Trust
    const trust = await prisma.trust.findFirst({ where: { userId, status: "FINALIZED" } });
    if (trust) {
      breakdown.trust += 10;
      const sectionsCompleted = [
        trust.trustName,
        trust.grantor,
        (trust.trustees as any[]).length > 0,
        (trust.beneficiaries as any[]).length > 0,
        trust.state,
        (trust.additionalClauses as string[]).length > 0,
        (trust.assetsIncluded as any[]).length > 0
      ].filter(Boolean).length;
      breakdown.trust += Math.min((sectionsCompleted - 1) * 5, 20);
    } else suggestions.push("Create and finalize a Trust.");

    // Entity
    const entity = await prisma.entity.findFirst({ where: { userId, status: "FINALIZED" } });
    if (entity) {
      breakdown.entity += 10;
      const entitySections = [
        entity.entityName,
        (entity.owners as any[]).length > 0,
        entity.registeredAgent,
        entity.state
      ].filter(Boolean).length;
      breakdown.entity += Math.min((entitySections - 1) * 2.5, 10);
    } else suggestions.push("Create and finalize an Entity.");

    // Vault Coverage
    const requiredDocs = ["Will", "Power of Attorney", "Advance Directives", "Guardianship", "Password Vault"];
    const userFiles = await prisma.vaultFile.findMany({ where: { userId } });
    requiredDocs.forEach((doc) => {
      const hasDoc = userFiles.some((f) => f.fileName.includes(doc));
      if (hasDoc) breakdown.vault += 5;
      else suggestions.push(`Upload your ${doc}.`);
    });

    // Security Settings
    const user = await prisma.user.findUnique({ where: { id: userId } });
    if (user?.twoFAEnabled) breakdown.security += 5;
    else suggestions.push("Enable Two-Factor Authentication.");

    const checkIns = await prisma.userCheckIn.findMany({ where: { userId } });
    if (checkIns.length > 0) breakdown.security += 5;
    else suggestions.push("Set up a scheduled check-in.");

    const emergencyAccess = await prisma.emergencyAccess.findFirst({
      where: { folder: { userId } }
    });
    if (emergencyAccess) breakdown.security += 5;
    else suggestions.push("Grant emergency access.");

    // Financial Hub
    const finAccounts = await prisma.financialAccount.findMany({ where: { userId } });
    if (finAccounts.length > 0) breakdown.financial += 5;
    else suggestions.push("Connect a financial account.");

    const score = Object.values(breakdown).reduce((sum, val) => sum + val, 0);
    res.json({ score, breakdown, suggestions });
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/dashboard/reporting.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";

const router = express.Router();

// GET /api/dashboard/metrics/users
router.get("/metrics/users", authMiddleware, async (req, res, next) => {
  try {
    const growth = await prisma.$queryRaw`
      SELECT to_char("createdAt", 'YYYY-MM') AS month, COUNT(*) AS count
      FROM "User"
      GROUP BY month
      ORDER BY month DESC
      LIMIT 12;
    `;
    const totalUsers = await prisma.user.count();
    res.json({ growth, totalUsers });
  } catch (err) {
    next(err);
  }
});

// GET /api/dashboard/metrics/subscriptions
router.get("/metrics/subscriptions", authMiddleware, async (req, res, next) => {
  try {
    const byPlanRaw = await prisma.$queryRaw`
      SELECT "planId", COUNT(*) AS count
      FROM "UserSubscription"
      WHERE status = 'ACTIVE'
      GROUP BY "planId";
    `;
    const byPlan = {};
    for (const row of byPlanRaw as any[]) {
      const plan = await prisma.subscriptionPlan.findUnique({ where: { id: row.planId } });
      byPlan[plan!.name] = parseInt(row.count);
    }
    // Churn calculation (simplified)
    const lastMonth = new Date();
    lastMonth.setMonth(lastMonth.getMonth() - 1);
    const canceledLastMonth = await prisma.userSubscription.count({
      where: { status: "CANCELED", updatedAt: { gte: lastMonth } }
    });
    const activeAtStart = await prisma.userSubscription.count({
      where: { updatedAt: { lte: lastMonth }, status: "ACTIVE" }
    });
    const churnRate = activeAtStart ? canceledLastMonth / activeAtStart : 0;
    res.json({ byPlan, churnRate });
  } catch (err) {
    next(err);
  }
});

// GET /api/dashboard/metrics/vault
router.get("/metrics/vault", authMiddleware, async (req, res, next) => {
  try {
    const monthlyUsage = await prisma.$queryRaw`
      SELECT to_char("createdAt", 'YYYY-MM') AS month, SUM(size) AS bytes
      FROM "VaultFile"
      GROUP BY month
      ORDER BY month DESC
      LIMIT 12;
    `;
    res.json({ monthlyUsage });
  } catch (err) {
    next(err);
  }
});

// GET /api/dashboard/metrics/api-usage
router.get("/metrics/api-usage", authMiddleware, async (req, res, next) => {
  try {
    const usageRaw = await prisma.aIUsageLog.groupBy({
      by: ["feature"],
      _sum: { tokensUsed: true }
    });
    const callsByFeature = {};
    (usageRaw as any[]).forEach((u) => {
      callsByFeature[u.feature] = u._sum.tokensUsed;
    });
    // errorRate calculation placeholder
    const errorRate = 0.015;
    res.json({ callsByFeature, errorRate });
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/admin/metrics.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";

const router = express.Router();

// GET /api/admin/metrics/users
router.get("/metrics/users", authMiddleware, async (req, res, next) => {
  try {
    if (req.user.role !== "ADMIN") return res.status(403).json({ error: "Forbidden" });
    const growth = await prisma.$queryRaw`
      SELECT to_char("createdAt", 'YYYY-MM') AS month, COUNT(*) AS count
      FROM "User"
      GROUP BY month
      ORDER BY month DESC
      LIMIT 12;
    `;
    const totalUsers = await prisma.user.count();
    res.json({ growth, totalUsers });
  } catch (err) {
    next(err);
  }
});

// GET /api/admin/metrics/subscriptions
router.get("/metrics/subscriptions", authMiddleware, async (req, res, next) => {
  try {
    if (req.user.role !== "ADMIN") return res.status(403).json({ error: "Forbidden" });
    const byPlanRaw = await prisma.$queryRaw`
      SELECT "planId", COUNT(*) AS count
      FROM "UserSubscription"
      WHERE status = 'ACTIVE'
      GROUP BY "planId";
    `;
    const byPlan = {};
    for (const row of byPlanRaw as any[]) {
      const plan = await prisma.subscriptionPlan.findUnique({ where: { id: row.planId } });
      byPlan[plan!.name] = parseInt(row.count);
    }
    const lastMonth = new Date();
    lastMonth.setMonth(lastMonth.getMonth() - 1);
    const canceledLastMonth = await prisma.userSubscription.count({
      where: { status: "CANCELED", updatedAt: { gte: lastMonth } }
    });
    const activeAtStart = await prisma.userSubscription.count({
      where: { updatedAt: { lte: lastMonth }, status: "ACTIVE" }
    });
    const churnRate = activeAtStart ? canceledLastMonth / activeAtStart : 0;
    res.json({ byPlan, churnRate });
  } catch (err) {
    next(err);
  }
});

// GET /api/admin/metrics/vault
router.get("/metrics/vault", authMiddleware, async (req, res, next) => {
  try {
    if (req.user.role !== "ADMIN") return res.status(403).json({ error: "Forbidden" });
    const monthlyUsage = await prisma.$queryRaw`
      SELECT to_char("createdAt", 'YYYY-MM') AS month, SUM(size) AS bytes
      FROM "VaultFile"
      GROUP BY month
      ORDER BY month DESC
      LIMIT 12;
    `;
    res.json({ monthlyUsage });
  } catch (err) {
    next(err);
  }
});

// GET /api/admin/metrics/api-usage
router.get("/metrics/api-usage", authMiddleware, async (req, res, next) => {
  try {
    if (req.user.role !== "ADMIN") return res.status(403).json({ error: "Forbidden" });
    const usageRaw = await prisma.aIUsageLog.groupBy({
      by: ["feature"],
      _sum: { tokensUsed: true }
    });
    const callsByFeature = {};
    (usageRaw as any[]).forEach((u) => {
      callsByFeature[u.feature] = u._sum.tokensUsed;
    });
    const errorRate = 0.015;
    res.json({ callsByFeature, errorRate });
  } catch (err) {
    next(err);
  }
});

// GET /api/admin/audit-logs
router.get("/audit-logs", authMiddleware, async (req, res, next) => {
  try {
    if (req.user.role !== "ADMIN") return res.status(403).json({ error: "Forbidden" });
    const { resourceType, resourceId, userId, action, from, to, page = 1, limit = 50 } = req.query;
    const where: any = {};
    if (resourceType) where.resourceType = resourceType;
    if (resourceId) where.resourceId = resourceId;
    if (userId) where.userId = userId;
    if (action) where.action = action;
    if (from && to) {
      where.timestamp = { gte: new Date(from as string), lte: new Date(to as string) };
    }
    const logs = await prisma.auditLog.findMany({
      where,
      skip: (Number(page) - 1) * Number(limit),
      take: Number(limit),
      orderBy: { timestamp: "desc" },
      include: { user: true }
    });
    res.json(logs);
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/notifications/index.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";

const router = express.Router();

// GET /api/notifications
router.get("/", authMiddleware, async (req, res, next) => {
  try {
    const notifications = await prisma.notification.findMany({
      where: { userId: req.user.id },
      orderBy: { createdAt: "desc" }
    });
    res.json(notifications);
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/routes/push-notifications/send.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";
import admin from "firebase-admin";
import ApiError from "../../utils/ApiError";

const router = express.Router();

// Initialize Firebase Admin
if (!admin.apps.length) {
  admin.initializeApp({
    credential: admin.credential.cert(JSON.parse(process.env.FCM_SERVICE_ACCOUNT!))
  });
}

// POST /api/push-notifications/send
router.post("/send", authMiddleware, async (req, res, next) => {
  try {
    const { title, body } = req.body;
    const tokens = await prisma.pushToken.findMany({ where: { userId: req.user.id } });
    if (tokens.length === 0) throw new ApiError(400, "No push tokens registered");

    const payload = { notification: { title, body } };
    const response = await admin.messaging().sendToDevice(tokens.map((t) => t.token), payload);
    res.json({ success: true, results: response.results });
  } catch (err) {
    next(err);
  }
});

export default router;
/backend/src/jobs/regulatoryAlerts.ts
import prisma from "../../prismaClient";
import sendEmail from "../config/email";
import sendSMS from "../config/sms";
import logAudit from "../middleware/auditLogger";

// This job runs daily to check for regulatory updates.
export default async function regulatoryAlerts() {
  // Assume we have a table PendingRegChange with fields { state, description, effectiveDate }
  const today = new Date();
  const changes = await prisma.pendingRegChange.findMany({
    where: { effectiveDate: today }
  });

  for (const change of changes) {
    const users = await prisma.trust.findMany({
      where: { state: change.state },
      distinct: ["userId"],
      select: { userId: true }
    });

    for (const { userId } of users) {
      const notification = await prisma.notification.create({
        data: {
          userId,
          type: "RegulatoryUpdate",
          content: { message: `${change.state} law update: ${change.description}` }
        }
      });

      // Send email if preference enabled
      const pref = await prisma.notificationPreference.findUnique({
        where: { userId_type: { userId, type: "RegulatoryUpdate" } }
      });
      const user = await prisma.user.findUnique({ where: { id: userId } });
      if (pref?.enabled && user?.email) {
        await sendEmail({
          to: user.email,
          subject: "Regulatory Update",
          html: `<p>${change.state} law update: ${change.description}</p>`
        });
      }

      // Optionally, send SMS if enabled and number available
      // await sendSMS({ to: user.phone, body: `...` });

      await logAudit({
        userId,
        resourceType: "Notification",
        resourceId: notification.id,
        action: "created",
        metadata: { changeId: change.id }
      });
    }
  }
}
/backend/src/jobs/checkInScheduler.ts
import prisma from "../../prismaClient";
import sendEmail from "../config/email";
import admin from "firebase-admin";
import logAudit from "../middleware/auditLogger";

// Initialize Firebase Admin
if (!admin.apps.length) {
  admin.initializeApp({
    credential: admin.credential.cert(JSON.parse(process.env.FCM_SERVICE_ACCOUNT!))
  });
}

export default async function checkInScheduler() {
  const now = new Date();
  const dueCheckIns = await prisma.userCheckIn.findMany({
    where: { nextDate: { lte: now } }
  });

  for (const checkIn of dueCheckIns) {
    const userId = checkIn.userId;
    const notification = await prisma.notification.create({
      data: {
        userId,
        type: "CheckInReminder",
        content: { message: "Time to review your estate plan." }
      }
    });

    const user = await prisma.user.findUnique({ where: { id: userId } });
    // Send email if enabled
    const pref = await prisma.notificationPreference.findUnique({
      where: { userId_type: { userId, type: "CheckInReminder" } }
    });
    if (pref?.enabled && user?.email) {
      await sendEmail({
        to: user.email,
        subject: "Legacy Pro Check-In Reminder",
        html: "<p>Time to review your estate plan.</p>"
      });
    }

    // Send push notification
    const tokens = await prisma.pushToken.findMany({ where: { userId } });
    if (tokens.length > 0) {
      const payload = { notification: { title: "Check-In Reminder", body: "Time to review your estate plan." } };
      await admin.messaging().sendToDevice(tokens.map((t) => t.token), payload);
    }

    // Update nextDate
    let newNextDate = new Date(checkIn.nextDate);
    switch (checkIn.frequency) {
      case "DAILY":
        newNextDate.setDate(newNextDate.getDate() + 1);
        break;
      case "WEEKLY":
        newNextDate.setDate(newNextDate.getDate() + 7);
        break;
      case "MONTHLY":
        newNextDate.setMonth(newNextDate.getMonth() + 1);
        break;
    }

    await prisma.userCheckIn.update({
      where: { id: checkIn.id },
      data: { lastSent: now, nextDate: newNextDate }
    });

    await logAudit({
      userId,
      resourceType: "UserCheckIn",
      resourceId: checkIn.id,
      action: "reminder_sent",
      metadata: {}
    });
  }
}
/frontend/package.json
{
  "name": "legacy-pro-frontend",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3000",
    "build": "next build",
    "start": "next start -p 3000",
    "lint": "eslint . --ext .ts,.tsx",
    "format": "prettier --write ."
  },
  "dependencies": {
    "@headlessui/react": "^1.4.2",
    "@heroicons/react": "^1.0.6",
    "@next/font": "13.4.4",
    "axios": "^1.4.0",
    "date-fns": "^2.30.0",
    "dompurify": "^2.4.3",
    "next": "13.4.4",
    "next-auth": "^4.22.1",
    "next-i18next": "^13.2.0",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "react-hook-form": "^7.45.1",
    "react-icons": "^4.11.0",
    "react-joyride": "^2.5.1",
    "react-plaid-link": "^5.0.4",
    "react-query": "^3.39.3",
    "recharts": "^2.6.2",
    "tailwind-merge": "^1.14.0",
    "tailwindcss": "^3.4.4",
    "typescript": "^5.2.2",
    "yup": "^1.2.0",
    "zustand": "^4.4.1"
  },
  "devDependencies": {
    "@types/node": "^20.5.1",
    "@types/react": "^18.2.15",
    "@typescript-eslint/eslint-plugin": "^6.13.1",
    "@typescript-eslint/parser": "^6.13.1",
    "autoprefixer": "^10.4.14",
    "eslint": "^8.45.0",
    "eslint-config-next": "13.4.4",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-react": "^7.32.2",
    "postcss": "^8.4.32",
    "prettier": "^3.0.5"
  }
}
/frontend/tsconfig.json
{
  "compilerOptions": {
    "target": "es2020",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "paths": {
      "@components/*": ["components/*"],
      "@utils/*": ["utils/*"],
      "@styles/*": ["styles/*"],
      "@hooks/*": ["hooks/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}
/frontend/next.config.js
const { i18n } = require("./next-i18next.config");

module.exports = {
  reactStrictMode: true,
  i18n,
  images: {
    domains: ["res.cloudinary.com", "avatars.githubusercontent.com", "lh3.googleusercontent.com"]
  },
  async redirects() {
    return [
      {
        source: "/",
        destination: "/login",
        permanent: false
      }
    ];
  }
};
/frontend/next-i18next.config.js
module.exports = {
  i18n: {
    defaultLocale: "en",
    locales: ["en", "es", "fr"]
  },
  localePath: "public/locales"
};
/frontend/tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx}",
    "./components/**/*.{js,ts,jsx,tsx}",
    "./utils/**/*.{js,ts,jsx,tsx}"
  ],
  theme: {
    extend: {
      colors: {
        primary: "#174EA6",
        secondary: "#1F3D7A",
        accent: "#FFD700"
      }
    }
  },
  plugins: []
};

/frontend/postcss.config.js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {}
  }
};

/frontend/styles/globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

html {
  scroll-behavior: smooth;
}

body {
  @apply bg-gray-100 text-gray-800 antialiased;
}

#__next {
  height: 100%;
}
/frontend/components/layout/AppLayout.tsx
import { ReactNode, useState, useEffect } from "react";
import { useSession, signOut } from "next-auth/react";
import Link from "next/link";
import { useRouter } from "next/router";
import { Menu, Transition } from "@headlessui/react";
import { BellIcon, MenuIcon, XIcon, ChevronDownIcon } from "@heroicons/react/outline";
import toast from "react-hot-toast";
import { useTranslation } from "next-i18next";
import MobileDrawer from "../navigation/MobileDrawer";
import Sidebar from "../navigation/Sidebar";
import NotificationBell from "../navigation/NotificationBell";
import LanguageSwitcher from "../navigation/LanguageSwitcher";
import Loader from "../common/Loader";
import ErrorBoundary from "./ErrorBoundary";
import ToastProvider from "../common/ToastProvider";

interface AppLayoutProps {
  children: ReactNode;
}

export default function AppLayout({ children }: AppLayoutProps) {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [mobileOpen, setMobileOpen] = useState(false);
  const { t } = useTranslation("common");

  useEffect(() => {
    if (status === "unauthenticated") {
      router.push("/login");
    }
  }, [status, router]);

  if (status === "loading") {
    return <Loader />;
  }

  return (
    <ErrorBoundary>
      <ToastProvider>
        <div className="flex h-screen">
          {/* Sidebar for desktop */}
          <div className="hidden lg:flex lg:w-64 lg:flex-col lg:fixed lg:inset-y-0 shadow-lg">
            <Sidebar />
          </div>

          {/* Mobile Drawer */}
          <MobileDrawer isOpen={mobileOpen} onClose={() => setMobileOpen(false)} />

          <div className="flex flex-col flex-1 lg:pl-64">
            {/* Top Nav */}
            <div className="sticky top-0 z-10 flex h-16 flex-shrink-0 bg-white shadow-md border-b border-gray-300">
              <button
                className="border-r border-gray-300 px-4 text-gray-500 focus:outline-none focus:ring-2 focus:ring-accent lg:hidden"
                onClick={() => setMobileOpen(true)}
                aria-label={t("nav.openMenu")}
              >
                <MenuIcon className="h-6 w-6" aria-hidden="true" />
              </button>
              <div className="flex flex-1 justify-between px-4">
                <div className="flex flex-1">
                  <Link href="/dashboard">
                    <a className="flex items-center text-xl font-bold text-primary hover:text-secondary">
                      <img src="/assets/logo.svg" alt="Legacy Pro" className="h-8 w-8 mr-2" />
                      Legacy Pro
                    </a>
                  </Link>
                </div>
                <div className="flex items-center space-x-4">
                  <NotificationBell />
                  <LanguageSwitcher />
                  <Menu as="div" className="relative">
                    <Menu.Button className="flex items-center text-sm rounded-full focus:outline-none focus:ring-2 focus:ring-accent">
                      <img
                        className="h-8 w-8 rounded-full"
                        src={session?.user?.image || "/assets/avatar-placeholder.png"}
                        alt={session?.user?.name || "User"}
                      />
                      <ChevronDownIcon className="h-5 w-5 ml-1 text-gray-500" />
                    </Menu.Button>
                    <Transition
                      as={React.Fragment}
                      enter="transition ease-out duration-100"
                      enterFrom="transform opacity-0 scale-95"
                      enterTo="transform opacity-100 scale-100"
                      leave="transition ease-in duration-75"
                      leaveFrom="transform opacity-100 scale-100"
                      leaveTo="transform opacity-0 scale-95"
                    >
                      <Menu.Items className="origin-top-right absolute right-0 mt-2 w-48 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none">
                        <div className="py-1">
                          <Menu.Item>
                            {({ active }) => (
                              <Link href="/settings">
                                <a
                                  className={`${
                                    active ? "bg-gray-100" : ""
                                  } block px-4 py-2 text-sm text-gray-700`}
                                >
                                  {t("nav.settings")}
                                </a>
                              </Link>
                            )}
                          </Menu.Item>
                          <Menu.Item>
                            {({ active }) => (
                              <button
                                onClick={() => signOut({ callbackUrl: "/login" })}
                                className={`${
                                  active ? "bg-gray-100" : ""
                                } w-full text-left block px-4 py-2 text-sm text-gray-700`}
                              >
                                {t("nav.logout")}
                              </button>
                            )}
                          </Menu.Item>
                        </div>
                      </Menu.Items>
                    </Transition>
                  </Menu>
                </div>
              </div>
            </div>

            {/* Main content */}
            <main className="flex-1 overflow-y-auto bg-gray-100">
              <div className="py-6">
                <div className="px-4 sm:px-6 md:px-8">{children}</div>
              </div>
            </main>
          </div>
        </div>
      </ToastProvider>
    </ErrorBoundary>
  );
}
/frontend/components/layout/ErrorBoundary.tsx
import { Component, ReactNode, ErrorInfo } from "react";
import Link from "next/link";

interface ErrorBoundaryProps {
  children: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
}

export default class ErrorBoundary extends Component<
  ErrorBoundaryProps,
  ErrorBoundaryState
> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(_: Error): ErrorBoundaryState {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Uncaught error:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="flex flex-col items-center justify-center h-screen bg-white">
          <h1 className="text-3xl font-bold text-red-600">
            {`Something went wrong.`}
          </h1>
          <p className="mt-2 text-gray-700">
            Please refresh the page or{" "}
            <Link href="/settings">
              <a className="text-accent underline">contact support</a>
            </Link>
            .
          </p>
        </div>
      );
    }

    return this.props.children;
  }
}
/frontend/components/layout/Loader.tsx
export default function Loader() {
  return (
    <div className="fixed inset-0 flex items-center justify-center bg-white bg-opacity-75 z-50">
      <svg
        className="animate-spin h-10 w-10 text-primary"
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
        aria-label="Loading"
      >
        <circle
          className="opacity-25"
          cx="12"
          cy="12"
          r="10"
          stroke="currentColor"
          strokeWidth="4"
        ></circle>
        <path
          className="opacity-75"
          fill="currentColor"
          d="M4 12a8 8 0 018-8v8H4z"
        ></path>
      </svg>
    </div>
  );
}
/frontend/components/common/ToastProvider.tsx
import { createContext, ReactNode, useContext, useState } from "react";
import { v4 as uuidv4 } from "uuid";
import Toast from "./Toast";

interface ToastProps {
  id: string;
  title: string;
  description?: string;
  status?: "success" | "error" | "warning" | "info";
  duration?: number;
}

interface ToastContextValue {
  addToast: (toast: Omit<ToastProps, "id">) => void;
}

const ToastContext = createContext<ToastContextValue | undefined>(undefined);

export const useToast = (): ToastContextValue => {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error("useToast must be used within a ToastProvider");
  }
  return context;
};

interface ToastProviderProps {
  children: ReactNode;
}

export default function ToastProvider({ children }: ToastProviderProps) {
  const [toasts, setToasts] = useState<ToastProps[]>([]);

  const addToast = ({
    title,
    description,
    status = "success",
    duration = 5000
  }: Omit<ToastProps, "id">) => {
    const id = uuidv4();
    setToasts((prev) => [...prev, { id, title, description, status, duration }]);
    setTimeout(() => removeToast(id), duration);
  };

  const removeToast = (id: string) => {
    setToasts((prev) => prev.filter((t) => t.id !== id));
  };

  return (
    <ToastContext.Provider value={{ addToast }}>
      {children}
      <div className="fixed bottom-4 right-4 space-y-2 z-50">
        {toasts.map((toast) => (
          <Toast key={toast.id} {...toast} onClose={() => removeToast(toast.id)} />
        ))}
      </div>
    </ToastContext.Provider>
  );
}
/frontend/components/common/Toast.tsx
import { XIcon } from "@heroicons/react/outline";

interface ToastProps {
  id: string;
  title: string;
  description?: string;
  status: "success" | "error" | "warning" | "info";
  onClose: () => void;
}

const statusStyles = {
  success: "bg-green-100 border-green-400 text-green-700",
  error: "bg-red-100 border-red-400 text-red-700",
  warning: "bg-yellow-100 border-yellow-400 text-yellow-700",
  info: "bg-blue-100 border-blue-400 text-blue-700"
};

export default function Toast({ title, description, status, onClose }: ToastProps) {
  return (
    <div
      className={`max-w-sm w-full ${statusStyles[status]} border px-6 py-4 rounded-lg shadow`}
      role="alert"
    >
      <div className="flex items-start">
        <div className="flex-1">
          <p className="font-bold">{title}</p>
          {description && <p className="text-sm">{description}</p>}
        </div>
        <button
          onClick={onClose}
          className="ml-4 text-gray-500 hover:text-gray-700 transition-colors duration-150 focus:outline-none focus:ring-2 focus:ring-accent"
          aria-label="Close toast"
        >
          <XIcon className="h-5 w-5" />
        </button>
      </div>
    </div>
  );
}
/frontend/components/navigation/MobileDrawer.tsx
import { Fragment } from "react";
import { Dialog, Transition } from "@headlessui/react";
import Link from "next/link";
import {
  HomeIcon,
  FolderOpenIcon,
  DocumentTextIcon,
  BriefcaseIcon,
  ChatAlt2Icon,
  MailOpenIcon,
  ChartPieIcon,
  CogIcon,
  XIcon
} from "@heroicons/react/outline";
import { useTranslation } from "next-i18next";

interface MobileDrawerProps {
  isOpen: boolean;
  onClose: () => void;
}

const navItems = [
  { nameKey: "nav.dashboard", href: "/dashboard", icon: HomeIcon },
  { nameKey: "nav.vault", href: "/vault", icon: FolderOpenIcon },
  { nameKey: "nav.trustBuilder", href: "/trust-builder", icon: DocumentTextIcon },
  { nameKey: "nav.entityBuilder", href: "/entity-builder", icon: BriefcaseIcon },
  { nameKey: "nav.legacyLetter", href: "/legacy-letter", icon: MailOpenIcon },
  { nameKey: "nav.aiAdvisor", href: "/ai-advisor", icon: ChatAlt2Icon },
  { nameKey: "nav.protectionScore", href: "/protection-score", icon: ChartPieIcon },
  { nameKey: "nav.settings", href: "/settings", icon: CogIcon }
];

export default function MobileDrawer({ isOpen, onClose }: MobileDrawerProps) {
  const { t } = useTranslation("common");

  return (
    <Transition.Root show={isOpen} as={Fragment}>
      <Dialog as="div" className="relative z-40 lg:hidden" onClose={onClose}>
        <Transition.Child
          as={Fragment}
          enter="transition-opacity ease-linear duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-50"
          leave="transition-opacity ease-linear duration-300"
          leaveFrom="opacity-50"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-black bg-opacity-50" aria-hidden="true" />
        </Transition.Child>

        <div className="fixed inset-0 flex z-40">
          <Transition.Child
            as={Fragment}
            enter="transition ease-in-out duration-300 transform"
            enterFrom="-translate-x-full"
            enterTo="translate-x-0"
            leave="transition ease-in-out duration-300 transform"
            leaveFrom="translate-x-0"
            leaveTo="-translate-x-full"
          >
            <Dialog.Panel className="relative flex-1 flex flex-col max-w-xs w-full bg-gray-50 focus:outline-none">
              <div className="absolute top-0 right-0 -mr-12 pt-2">
                <button
                  className="ml-1 flex items-center justify-center h-10 w-10 rounded-full focus:outline-none focus:ring-2 focus:ring-accent"
                  onClick={onClose}
                  aria-label={t("nav.closeMenu")}
                >
                  <XIcon className="h-6 w-6 text-white" />
                </button>
              </div>
              <div className="pt-5 pb-4 px-6 overflow-y-auto">
                <div className="flex items-center px-4">
                  <img className="h-8 w-auto" src="/assets/logo.svg" alt="Legacy Pro" />
                  <span className="ml-2 text-xl font-bold text-primary">Legacy Pro</span>
                </div>
                <nav className="mt-5 px-2 space-y-1">
                  {navItems.map((item) => {
                    const Icon = item.icon;
                    return (
                      <Link href={item.href} key={item.href}>
                        <a className="group flex items-center px-2 py-2 text-base font-medium text-gray-700 rounded-md hover:bg-gray-100 hover:text-gray-900">
                          <Icon className="mr-4 h-6 w-6 text-gray-400 group-hover:text-gray-500" />
                          {t(item.nameKey)}
                        </a>
                      </Link>
                    );
                  })}
                </nav>
              </div>
            </Dialog.Panel>
          </Transition.Child>
          <div className="w-14 flex-shrink-0" aria-hidden="true">
            {/* Dummy element to force sidebar to shrink */}
          </div>
        </div>
      </Dialog>
    </Transition.Root>
  );
}
/frontend/components/navigation/Sidebar.tsx
import Link from "next/link";
import { useRouter } from "next/router";
import {
  HomeIcon,
  FolderOpenIcon,
  DocumentTextIcon,
  BriefcaseIcon,
  MailOpenIcon,
  ChatAlt2Icon,
  ChartPieIcon,
  CogIcon
} from "@heroicons/react/outline";
import { useTranslation } from "next-i18next";

const navItems = [
  { nameKey: "nav.dashboard", href: "/dashboard", icon: HomeIcon },
  { nameKey: "nav.vault", href: "/vault", icon: FolderOpenIcon },
  { nameKey: "nav.trustBuilder", href: "/trust-builder", icon: DocumentTextIcon },
  { nameKey: "nav.entityBuilder", href: "/entity-builder", icon: BriefcaseIcon },
  { nameKey: "nav.legacyLetter", href: "/legacy-letter", icon: MailOpenIcon },
  { nameKey: "nav.aiAdvisor", href: "/ai-advisor", icon: ChatAlt2Icon },
  { nameKey: "nav.protectionScore", href: "/protection-score", icon: ChartPieIcon },
  { nameKey: "nav.settings", href: "/settings", icon: CogIcon }
];

export default function Sidebar() {
  const router = useRouter();
  const { t } = useTranslation("common");

  return (
    <div className="flex-1 flex flex-col min-h-0 bg-gray-50 border-r border-gray-200">
      <div className="flex h-16 flex-shrink-0 items-center px-4">
        <img className="h-8 w-auto" src="/assets/logo.svg" alt="Legacy Pro" />
        <span className="ml-2 text-xl font-bold text-primary">Legacy Pro</span>
      </div>
      <nav className="flex-1 px-2 py-4 space-y-1 overflow-y-auto">
        {navItems.map((item) => {
          const isActive = router.pathname === item.href;
          const Icon = item.icon;
          return (
            <Link href={item.href} key={item.href}>
              <a
                className={`group flex items-center px-2 py-2 text-sm font-medium rounded-md transition-colors duration-150
                  ${
                    isActive
                      ? "bg-secondary text-white"
                      : "text-gray-700 hover:bg-gray-100 hover:text-gray-900"
                  }`}
                aria-current={isActive ? "page" : undefined}
              >
                <Icon
                  className={`mr-3 h-6 w-6 ${
                    isActive ? "text-white" : "text-gray-400 group-hover:text-gray-500"
                  }`}
                />
                {t(item.nameKey)}
              </a>
            </Link>
          );
        })}
      </nav>
    </div>
  );
}
/frontend/components/navigation/NotificationBell.tsx
import { useState, useEffect, Fragment } from "react";
import { BellIcon } from "@heroicons/react/outline";
import { useToast } from "../common/ToastProvider";
import Link from "next/link";
import { useSession } from "next-auth/react";
import { Menu, Transition } from "@headlessui/react";
import { formatDistanceToNow } from "date-fns";
import axios from "axios";
import { useTranslation } from "next-i18next";

interface Notification {
  id: string;
  type: string;
  content: { message: string };
  read: boolean;
  createdAt: string;
}

export default function NotificationBell() {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const { data: session } = useSession();
  const { addToast } = useToast();
  const { t } = useTranslation("common");

  const fetchNotifications = async () => {
    try {
      const { data } = await axios.get("/api/notifications");
      setNotifications(data);
      setUnreadCount(data.filter((n: Notification) => !n.read).length);
    } catch (err) {
      console.error(err);
      addToast({ title: t("errors.fetchNotifications"), status: "error" });
    }
  };

  useEffect(() => {
    if (session) {
      fetchNotifications();
    }
  }, [session]);

  const markAsRead = async (id: string) => {
    try {
      await axios.patch(`/api/notifications/${id}/mark-read`);
      setNotifications((prev) =>
        prev.map((n) => (n.id === id ? { ...n, read: true } : n))
      );
      setUnreadCount((prev) => prev - 1);
    } catch (err) {
      console.error(err);
      addToast({ title: t("errors.updateNotification"), status: "error" });
    }
  };

  return (
    <Menu as="div" className="relative">
      <Menu.Button className="p-1 rounded-full text-gray-500 hover:text-gray-700 focus:outline-none focus:ring-2 focus:ring-accent" aria-label={t("nav.notifications")}>
        <BellIcon className="h-6 w-6" />
        {unreadCount > 0 && (
          <span className="absolute top-0 right-0 inline-flex items-center justify-center px-1.5 py-0.5 text-xs font-bold leading-none text-white bg-red-600 rounded-full">
            {unreadCount}
          </span>
        )}
      </Menu.Button>
      <Transition
        as={Fragment}
        enter="transition ease-out duration-100"
        enterFrom="transform opacity-0 scale-95"
        enterTo="transform opacity-100 scale-100"
        leave="transition ease-in duration-75"
        leaveFrom="transform opacity-100 scale-100"
        leaveTo="transform opacity-0 scale-95"
      >
        <Menu.Items className="origin-top-right absolute right-0 mt-2 w-80 bg-white border border-gray-200 divide-y divide-gray-100 rounded-md shadow-lg focus:outline-none z-50">
          <div className="py-1 max-h-96 overflow-y-auto">
            {notifications.length === 0 ? (
              <div className="px-4 py-2 text-sm text-gray-500">{t("notifications.none")}</div>
            ) : (
              notifications.map((notif) => (
                <Menu.Item key={notif.id}>
                  {({ active }) => (
                    <div
                      className={`flex items-start px-4 py-3 cursor-pointer ${
                        active ? "bg-gray-100" : ""
                      } ${!notif.read ? "bg-gray-50" : ""}`}
                      onClick={() => markAsRead(notif.id)}
                    >
                      <div className="flex-1">
                        <p className="text-sm font-medium">{t(`notification.${notif.type}`)}</p>
                        <p className="text-xs text-gray-600">{notif.content.message}</p>
                        <p className="text-xs text-gray-400">
                          {formatDistanceToNow(new Date(notif.createdAt), { addSuffix: true })}
                        </p>
                      </div>
                      {!notif.read && (
                        <span className="ml-2 text-blue-600 text-xs">{t("notifications.new")}</span>
                      )}
                    </div>
                  )}
                </Menu.Item>
              ))
            )}
          </div>
          {notifications.length > 0 && (
            <div className="px-4 py-2 text-sm text-center">
              <Link href="/settings/notifications">
                <a className="text-primary hover:underline">{t("notifications.viewAll")}</a>
              </Link>
            </div>
          )}
        </Menu.Items>
      </Transition>
    </Menu>
  );
}
/frontend/components/navigation/LanguageSwitcher.tsx
import { Menu, Transition } from "@headlessui/react";
import { GlobeAltIcon, CheckIcon } from "@heroicons/react/outline";
import { Fragment } from "react";
import { useRouter } from "next/router";

const locales = ["en", "es", "fr"];

export default function LanguageSwitcher() {
  const router = useRouter();
  const { locale, locales: allLocales, pathname, query, asPath } = router;

  const changeLocale = (newLocale: string) => {
    router.push({ pathname, query }, asPath, { locale: newLocale });
  };

  return (
    <Menu as="div" className="relative">
      <Menu.Button className="p-1 rounded-full text-gray-500 hover:text-gray-700 focus:outline-none focus:ring-2 focus:ring-accent" aria-label="Change language">
        <GlobeAltIcon className="h-6 w-6" />
      </Menu.Button>
      <Transition
        as={Fragment}
        enter="transition ease-out duration-100"
        enterFrom="transform opacity-0 scale-95"
        enterTo="transform opacity-100 scale-100"
        leave="transition ease-in duration-75"
        leaveFrom="transform opacity-100 scale-100"
        leaveTo="transform opacity-0 scale-95"
      >
        <Menu.Items className="origin-top-right absolute right-0 mt-2 w-32 bg-white border border-gray-200 divide-y divide-gray-100 rounded-md shadow-lg focus:outline-none z-50">
          <div className="py-1">
            {locales.map((loc) => (
              <Menu.Item key={loc}>
                {({ active }) => (
                  <button
                    onClick={() => changeLocale(loc)}
                    className={`${
                      active ? "bg-gray-100" : ""
                    } flex items-center w-full px-4 py-2 text-sm text-gray-700`}
                  >
                    {loc.toUpperCase()}
                    {locale === loc && <CheckIcon className="ml-auto h-5 w-5 text-primary" />}
                  </button>
                )}
              </Menu.Item>
            ))}
          </div>
        </Menu.Items>
      </Transition>
    </Menu>
  );
}
/frontend/components/common/Button.tsx
import { ButtonHTMLAttributes } from "react";
import { twMerge } from "tailwind-merge";

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: "primary" | "secondary" | "outline";
}

const variantStyles = {
  primary: "bg-primary text-white hover:bg-secondary focus:ring-accent",
  secondary: "bg-secondary text-white hover:bg-primary focus:ring-accent",
  outline:
    "border border-primary text-primary hover:bg-primary hover:text-white focus:ring-accent"
};

export default function Button({
  variant = "primary",
  className,
  children,
  ...props
}: ButtonProps) {
  return (
    <button
      className={twMerge(
        `px-6 py-2 rounded-lg font-semibold focus:outline-none focus:ring-2 shadow-sm transition-colors duration-150`,
        variantStyles[variant],
        className
      )}
      {...props}
    >
      {children}
    </button>
  );
}
/frontend/components/common/Input.tsx
import { InputHTMLAttributes } from "react";
import { twMerge } from "tailwind-merge";

interface InputProps extends InputHTMLAttributes<HTMLInputElement> {}

export default function Input({ className, ...props }: InputProps) {
  return (
    <input
      className={twMerge(
        "w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-accent",
        className
      )}
      {...props}
    />
  );
}
/frontend/components/common/Select.tsx
import { SelectHTMLAttributes } from "react";
import { twMerge } from "tailwind-merge";

interface SelectProps extends SelectHTMLAttributes<HTMLSelectElement> {}

export default function Select({ className, ...props }: SelectProps) {
  return (
    <select
      className={twMerge(
        "w-full px-3 py-2 border border-gray-300 rounded-lg bg-white focus:outline-none focus:ring-2 focus:ring-accent",
        className
      )}
      {...props}
    />
  );
}
/frontend/components/common/Modal.tsx
import { Fragment, ReactNode } from "react";
import { Dialog, Transition } from "@headlessui/react";

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: ReactNode;
}

export default function Modal({ isOpen, onClose, title, children }: ModalProps) {
  return (
    <Transition.Root show={isOpen} as={Fragment}>
      <Dialog as="div" className="fixed inset-0 z-50 overflow-y-auto" onClose={onClose}>
        <div className="flex items-end justify-center min-h-screen px-4 pb-20 text-center sm:block sm:p-0">
          <Transition.Child
            as={Fragment}
            enter="ease-out duration-300"
            enterFrom="opacity-0"
            enterTo="opacity-75"
            leave="ease-in duration-200"
            leaveFrom="opacity-75"
            leaveTo="opacity-0"
          >
            <Dialog.Overlay className="fixed inset-0 bg-black transition-opacity" />
          </Transition.Child>

          {/* Trick to center */}
          <span className="hidden sm:inline-block sm:align-middle sm:h-screen" aria-hidden="true">
            &#8203;
          </span>

          <Transition.Child
            as={Fragment}
            enter="ease-out duration-300"
            enterFrom="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
            enterTo="opacity-100 translate-y-0 sm:scale-100"
            leave="ease-in duration-200"
            leaveFrom="opacity-100 translate-y-0 sm:scale-100"
            leaveTo="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
          >
            <div className="inline-block align-bottom bg-white rounded-lg px-4 pt-5 pb-4 text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg sm:w-full sm:p-6">
              <div>
                <Dialog.Title as="h3" className="text-lg leading-6 font-medium text-gray-900">
                  {title}
                </Dialog.Title>
                <div className="mt-2">{children}</div>
              </div>
            </div>
          </Transition.Child>
        </div>
      </Dialog>
    </Transition.Root>
  );
}
/frontend/components/common/LoaderSpinner.tsx

export default function LoaderSpinner() {
  return (
    <svg
      className="animate-spin h-8 w-8 text-primary"
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      aria-label="Loading"
    >
      <circle
        className="opacity-25"
        cx="12"
        cy="12"
        r="10"
        stroke="currentColor"
        strokeWidth="4"
      />
      <path
        className="opacity-75"
        fill="currentColor"
        d="M4 12a8 8 0 018-8v8H4z"
      />
    </svg>
  );
}
/frontend/components/common/ChartWrapper.tsx
import { ReactNode } from "react";

interface ChartWrapperProps {
  title: string;
  children: ReactNode;
}

export default function ChartWrapper({ title, children }: ChartWrapperProps) {
  return (
    <div className="bg-white shadow rounded-lg p-4">
      <h2 className="text-lg font-semibold text-gray-800 mb-2">{title}</h2>
      {children}
    </div>
  );
}
/frontend/components/navigation/SearchBar.tsx
import { useState, useRef, useEffect } from "react";
import { SearchIcon } from "@heroicons/react/outline";
import axios from "axios";
import Link from "next/link";
import { useRouter } from "next/router";
import { useTranslation } from "next-i18next";

interface Result {
  id: string;
  title: string;
  type: string;
}

export default function SearchBar() {
  const [query, setQuery] = useState("");
  const [results, setResults] = useState<Result[]>([]);
  const [showDropdown, setShowDropdown] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const router = useRouter();
  const { t } = useTranslation("common");

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target as Node)
      ) {
        setShowDropdown(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, []);

  const onChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const val = e.target.value;
    setQuery(val);
    if (val.trim().length > 0) {
      try {
        const { data } = await axios.get("/api/search", { params: { q: val } });
        setResults(data.results);
        setShowDropdown(true);
      } catch (err) {
        console.error(err);
      }
    } else {
      setShowDropdown(false);
      setResults([]);
    }
  };

  const onKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter" && results.length > 0) {
      const first = results[0];
      router.push(`/${first.type.toLowerCase()}/${first.id}`);
      setShowDropdown(false);
      setQuery("");
    }
  };

  return (
    <div className="relative w-full max-w-md mx-auto" ref={dropdownRef}>
      <div className="relative">
        <input
          type="text"
          value={query}
          onChange={onChange}
          onKeyDown={onKeyDown}
          placeholder={t("search.placeholder")}
          className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-accent"
          aria-label={t("search.ariaLabel")}
        />
        <SearchIcon className="absolute left-3 top-2.5 h-5 w-5 text-gray-400" />
      </div>
      {showDropdown && results.length > 0 && (
        <div className="absolute mt-1 w-full bg-white border border-gray-200 rounded-md shadow-lg z-50">
          {results.map((r) => (
            <Link key={`${r.type}-${r.id}`} href={`/${r.type.toLowerCase()}/${r.id}`}>
              <a className="block px-4 py-2 hover:bg-gray-100">
                <span className="font-medium">{r.title}</span>
                <span className="ml-2 text-xs text-gray-500">{r.type}</span>
              </a>
            </Link>
          ))}
        </div>
      )}
    </div>
  );
}
/frontend/components/vault/FolderTree.tsx
import { useState, KeyboardEvent, useRef, useEffect } from "react";

interface VaultFolder {
  id: string;
  name: string;
  children: VaultFolder[];
}

interface FolderTreeProps {
  folder: VaultFolder;
  selectedId: string | null;
  onSelect: (id: string) => void;
}

export default function FolderTree({
  folder,
  selectedId,
  onSelect
}: FolderTreeProps) {
  const [expanded, setExpanded] = useState(false);
  const itemRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (selectedId === folder.id && itemRef.current) {
      itemRef.current.focus();
    }
  }, [selectedId, folder.id]);

  const handleKeyDown = (e: KeyboardEvent<HTMLDivElement>) => {
    switch (e.key) {
      case "Enter":
      case " ":
        e.preventDefault();
        onSelect(folder.id);
        break;
      case "ArrowRight":
        e.preventDefault();
        setExpanded(true);
        break;
      case "ArrowLeft":
        e.preventDefault();
        setExpanded(false);
        break;
      default:
        break;
    }
  };

  return (
    <div className="pl-4">
      <div
        ref={itemRef}
        tabIndex={0}
        role="treeitem"
        aria-expanded={folder.children.length > 0 ? expanded : undefined}
        className={`flex items-center cursor-pointer ${
          selectedId === folder.id ? "bg-primary text-white" : "text-gray-800"
        } rounded-md p-1 focus:outline-none focus:ring-2 focus:ring-accent`}
        onClick={() => onSelect(folder.id)}
        onKeyDown={handleKeyDown}
      >
        {folder.children.length > 0 && (
          <span
            className={`inline-block transform transition-transform ${
              expanded ? "rotate-90" : ""
            }`}
            aria-hidden="true"
          >
            ▶
          </span>
        )}
        <span className="ml-1">{folder.name}</span>
      </div>
      {expanded &&
        folder.children.map((child) => (
          <FolderTree
            key={child.id}
            folder={child}
            selectedId={selectedId}
            onSelect={onSelect}
          />
        ))}
    </div>
  );
}
/frontend/components/vault/UploadBox.tsx
import { useState } from "react";
import axios from "axios";
import { useToast } from "../common/ToastProvider";
import LoaderSpinner from "../common/LoaderSpinner";
import { useSubscriptionStatus } from "../../hooks/useSubscriptionStatus";
import { useTranslation } from "next-i18next";

interface UploadBoxProps {
  folderId: string;
  onUploadSuccess: () => void;
}

export default function UploadBox({ folderId, onUploadSuccess }: UploadBoxProps) {
  const [isUploading, setIsUploading] = useState(false);
  const { addToast } = useToast();
  const { status, storageUsedMB, storageLimitMB } = useSubscriptionStatus();
  const { t } = useTranslation("common");

  const handleFiles = async (files: FileList | null) => {
    if (!files) return;
    let totalSizeMB = 0;
    Array.from(files).forEach((file) => {
      totalSizeMB += file.size / (1024 * 1024);
    });
    if (storageUsedMB + totalSizeMB > storageLimitMB) {
      addToast({
        title: t("vault.uploadQuotaExceeded"),
        description: t("vault.uploadQuotaExceededDetail", {
          used: storageUsedMB,
          limit: storageLimitMB
        }),
        status: "error"
      });
      return;
    }

    setIsUploading(true);
    try {
      for (const file of Array.from(files)) {
        // 1. Get upload URL
        const { data: uploadData } = await axios.post("/api/vault/upload-url", {
          fileName: file.name,
          fileType: file.type,
          size: file.size
        });
        const { key, url } = uploadData;

        // 2. PUT file to S3
        await axios.put(url, file, {
          headers: { "Content-Type": file.type }
        });

        // 3. Register file in DB
        await axios.post("/api/vault/files", {
          fileName: file.name,
          fileType: file.type,
          size: file.size,
          folderId,
          s3Key: key
        });
      }
      addToast({ title: t("vault.uploadSuccess"), status: "success" });
      onUploadSuccess();
    } catch (err: any) {
      console.error(err);
      addToast({ title: t("vault.uploadError"), status: "error" });
    } finally {
      setIsUploading(false);
    }
  };

  return (
    <div className="border-2 border-dashed border-gray-400 rounded-xl p-6 text-center group hover:bg-gray-50">
      <input
        type="file"
        multiple
        className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
        onChange={(e) => handleFiles(e.target.files)}
      />
      {isUploading ? (
        <LoaderSpinner />
      ) : (
        <div className="text-gray-500 transition-colors duration-150">{t("vault.dragDropPrompt")}</div>
      )}
    </div>
  );
}
/frontend/components/vault/FileList.tsx
import { ChangeEvent, useState, useEffect } from "react";
import axios from "axios";
import { useToast } from "../common/ToastProvider";
import { DocumentDownloadIcon, TrashIcon } from "@heroicons/react/outline";
import moment from "moment";
import { useTranslation } from "next-i18next";

interface File {
  id: string;
  fileName: string;
  fileType: string;
  size: number;
  createdAt: string;
  s3Key: string;
}

interface FileListProps {
  folderId: string;
  onRefresh: () => void;
}

export default function FileList({ folderId, onRefresh }: FileListProps) {
  const [files, setFiles] = useState<File[]>([]);
  const [selectedIds, setSelectedIds] = useState<string[]>([]);
  const [isDeleting, setIsDeleting] = useState(false);
  const [allSelected, setAllSelected] = useState(false);
  const { addToast } = useToast();
  const { t } = useTranslation("common");

  const fetchFiles = async () => {
    try {
      const { data } = await axios.get(`/api/vault/folders/${folderId}/files`);
      setFiles(data);
      setSelectedIds([]);
      setAllSelected(false);
    } catch (err) {
      console.error(err);
      addToast({ title: t("vault.fetchError"), status: "error" });
    }
  };

  useEffect(() => {
    if (folderId) {
      fetchFiles();
    }
  }, [folderId]);

  const toggleSelect = (id: string) => {
    setSelectedIds((prev) => (prev.includes(id) ? prev.filter((x) => x !== id) : [...prev, id]));
  };

  const toggleSelectAll = (e: ChangeEvent<HTMLInputElement>) => {
    const isChecked = e.target.checked;
    setAllSelected(isChecked);
    setSelectedIds(isChecked ? files.map((f) => f.id) : []);
  };

  const deleteSelected = async () => {
    if (selectedIds.length === 0) {
      addToast({ title: t("vault.noSelection"), status: "warning" });
      return;
    }
    if (!confirm(t("vault.confirmDelete", { count: selectedIds.length }))) {
      return;
    }
    setIsDeleting(true);
    try {
      await axios.delete("/api/vault/files", { data: { fileIds: selectedIds } });
      addToast({ title: t("vault.deleteSuccess"), status: "success" });
      onRefresh();
    } catch (err) {
      console.error(err);
      addToast({ title: t("vault.deleteError"), status: "error" });
    } finally {
      setIsDeleting(false);
    }
  };

  return (
    <div>
      <div className="flex items-center justify-between mb-4">
        <label className="inline-flex items-center">
          <input
            type="checkbox"
            checked={allSelected}
            onChange={toggleSelectAll}
            className="form-checkbox h-4 w-4 text-primary hover:text-secondary transition-colors duration-150"
          />
          <span className="ml-2 text-sm text-gray-700">{t("vault.selectAll")}</span>
        </label>
        <button
          onClick={deleteSelected}
          disabled={isDeleting || selectedIds.length === 0}
          className="flex items-center px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded focus:outline-none focus:ring-2 focus:ring-accent disabled:opacity-50 transition-colors duration-150"
        >
          <TrashIcon className="h-5 w-5 mr-2" />
          {isDeleting ? t("vault.deleting") : t("vault.delete")}
        </button>
      </div>
      <table className="min-w-full bg-white">
        <thead>
          <tr>
            <th />
            <th className="px-4 py-2 text-left text-sm font-medium text-gray-500 bg-gray-100">
              {t("vault.fileName")}
            </th>
            <th className="px-4 py-2 text-left text-sm font-medium text-gray-500 bg-gray-100">
              {t("vault.size")}
            </th>
            <th className="px-4 py-2 text-left text-sm font-medium text-gray-500 bg-gray-100">
              {t("vault.uploadedAt")}
            </th>
            <th />
          </tr>
        </thead>
        <tbody>
          {files.map((file) => (
            <tr key={file.id} className="hover:bg-gray-100">
              <td className="px-4 py-2">
                <input
                  type="checkbox"
                  checked={selectedIds.includes(file.id)}
                  onChange={() => toggleSelect(file.id)}
                  className="form-checkbox h-4 w-4 text-primary hover:text-secondary transition-colors duration-150"
                />
              </td>
              <td className="px-4 py-2 text-sm text-gray-700">{file.fileName}</td>
              <td className="px-4 py-2 text-sm text-gray-700">
                {(file.size / (1024 * 1024)).toFixed(2)} MB
              </td>
              <td className="px-4 py-2 text-sm text-gray-500">
                {moment(file.createdAt).format("MMM D, YYYY")}
              </td>
              <td className="px-4 py-2">
                <button
                  onClick={async () => {
                    try {
                      const { data } = await axios.get(
                        `/api/vault/files/${file.id}/download-url`
                      );
                      window.open(data.url, "_blank");
                    } catch (err) {
                      console.error(err);
                      addToast({ title: t("vault.downloadError"), status: "error" });
                    }
                  }}
                  className="text-blue-600 hover:text-blue-800 focus:outline-none transition-colors duration-150"
                >
                  <DocumentDownloadIcon className="h-5 w-5" />
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
/frontend/hooks/useSubscriptionStatus.tsx
import { useQuery } from "react-query";
import axios from "axios";

interface SubscriptionStatus {
  planName: string;
  status: string;
  storageUsedMB: number;
  storageLimitMB: number;
  nextBillingDate: string | null;
}

export function useSubscriptionStatus() {
  return useQuery<SubscriptionStatus>(
    ["subscriptionStatus"],
    async () => {
      const { data } = await axios.get("/api/subscriptions/status");
      return data;
    },
    {
      staleTime: 5 * 60 * 1000, // 5 minutes
      retry: false
    }
  );
}
/frontend/utils/apiRequest.tsx
import axios, { AxiosRequestConfig } from "axios";
import { useToast } from "../components/common/ToastProvider";

// This wrapper can be imported and used inside React components or custom hooks
export async function apiRequest<T>(
  url: string,
  config: AxiosRequestConfig = {}
): Promise<T> {
  try {
    const response = await axios({
      withCredentials: true,
      headers: {
        "Content-Type": "application/json",
        ...config.headers
      },
      ...config,
      url
    });
    return response.data;
  } catch (err: any) {
    const toast = useToast();
    const message =
      err.response?.data?.error || err.message || "Network error";
    toast.addToast({ title: message, status: "error" });
    throw new Error(message);
  }
}
/frontend/pages/_app.tsx
import { SessionProvider } from "next-auth/react";
import { appWithTranslation } from "next-i18next";
import { QueryClient, QueryClientProvider } from "react-query";
import "../styles/globals.css";
import AppLayout from "../components/layout/AppLayout";

const queryClient = new QueryClient();

function MyApp({ Component, pageProps: { session, ...pageProps } }: any) {
  return (
    <SessionProvider session={session}>
      <QueryClientProvider client={queryClient}>
        {Component.authRequired ? (
          <AppLayout>
            <Component {...pageProps} />
          </AppLayout>
        ) : (
          <Component {...pageProps} />
        )}
      </QueryClientProvider>
    </SessionProvider>
  );
}

export default appWithTranslation(MyApp);
/frontend/pages/_document.tsx
import Document, { Html, Head, Main, NextScript } from "next/document";

class MyDocument extends Document {
  render() {
    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="description" content="Legacy Pro – Your Digital Legacy Planning Platform" />
          <link rel="icon" href="/favicon.ico" />
        </Head>
        <body className="h-full">
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;
/frontend/pages/404.tsx
import Link from "next/link";
import { useTranslation } from "next-i18next";

export default function Custom404() {
  const { t } = useTranslation("common");

  return (
    <div className="flex flex-col items-center justify-center h-screen bg-white">
      <h1 className="text-5xl font-bold text-red-600">404</h1>
      <p className="mt-2 text-xl text-gray-700">{t("errors.pageNotFound")}</p>
      <Link href="/dashboard">
        <a className="mt-4 text-accent underline">{t("errors.goHome")}</a>
      </Link>
    </div>
  );
}
/frontend/pages/_error.tsx
import { NextPageContext } from "next";
import Link from "next/link";
import { useTranslation } from "next-i18next";

interface ErrorProps {
  statusCode?: number;
}

function Error({ statusCode }: ErrorProps) {
  const { t } = useTranslation("common");
  return (
    <div className="flex flex-col items-center justify-center h-screen bg-white">
      <h1 className="text-5xl font-bold text-red-600">
        {statusCode
          ? `${t("errors.errorOccurred")} ${statusCode}`
          : t("errors.errorOccurredClient")}
      </h1>
      <Link href="/dashboard">
        <a className="mt-4 text-accent underline">{t("errors.goHome")}</a>
      </Link>
    </div>
  );
}

Error.getInitialProps = ({ res, err }: NextPageContext) => {
  const statusCode = res ? res.statusCode : err ? err.statusCode : 404;
  return { statusCode };
};

export default Error;
/frontend/pages/index.tsx
import { useSession } from "next-auth/react";
import { useEffect } from "react";
import { useRouter } from "next/router";

export default function Home() {
  const { data: session, status } = useSession();
  const router = useRouter();

  useEffect(() => {
    if (status === "authenticated") {
      router.replace("/dashboard");
    } else if (status === "unauthenticated") {
      router.replace("/login");
    }
  }, [status, router]);

  return null;
}

Home.authRequired = false;
/frontend/pages/login.tsx
import { signIn, useSession } from "next-auth/react";
import { useRouter } from "next/router";
import { FormEvent, useState } from "react";
import Link from "next/link";
import Button from "../components/common/Button";
import Input from "../components/common/Input";
import { useToast } from "../components/common/ToastProvider";
import { serverSideTranslations } from "next-i18next/serverSideTranslations";
import { useTranslation } from "next-i18next";

export default function Login() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { addToast } = useToast();
  const { t } = useTranslation("common");

  if (status === "authenticated") {
    router.replace("/dashboard");
    return null;
  }

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    try {
      const res = await signIn("credentials", {
        redirect: false,
        email,
        password
      });
      if (res?.error) {
        addToast({ title: t("errors.invalidCredentials"), status: "error" });
      } else {
        router.replace("/dashboard");
      }
    } catch (err) {
      console.error(err);
      addToast({ title: t("errors.loginFailed"), status: "error" });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="max-w-md w-full bg-white p-8 rounded-lg shadow">
        <h2 className="text-2xl font-bold text-center text-gray-800 mb-6">
          {t("login.title")}
        </h2>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
              {t("login.email")}
            </label>
            <Input
              id="email"
              type="email"
              required
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder={t("login.emailPlaceholder")}
            />
          </div>
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-gray-700">
              {t("login.password")}
            </label>
            <Input
              id="password"
              type="password"
              required
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder={t("login.passwordPlaceholder")}
            />
          </div>
          <Button type="submit" disabled={isSubmitting} className="w-full">
            {isSubmitting ? t("login.loggingIn") : t("login.loginButton")}
          </Button>
          <p className="text-center text-sm text-gray-600">
            {t("login.noAccount")}{" "}
            <Link href="/signup">
              <a className="text-accent hover:underline">{t("login.signUp")}</a>
            </Link>
          </p>
        </form>
      </div>
    </div>
  );
}

Login.authRequired = false;

export async function getStaticProps({ locale }: any) {
  return {
    props: {
      ...(await serverSideTranslations(locale, ["common"]))
    }
  };
}
/frontend/pages/signup.tsx
import { signIn } from "next-auth/react";
import { useRouter } from "next/router";
import { FormEvent, useState } from "react";
import Link from "next/link";
import Button from "../components/common/Button";
import Input from "../components/common/Input";
import { useToast } from "../components/common/ToastProvider";
import axios from "axios";
import { serverSideTranslations } from "next-i18next/serverSideTranslations";
import { useTranslation } from "next-i18next";

export default function Signup() {
  const router = useRouter();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [confirm, setConfirm] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { addToast } = useToast();
  const { t } = useTranslation("common");

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    if (password !== confirm) {
      addToast({ title: t("signup.passwordMismatch"), status: "error" });
      return;
    }
    setIsSubmitting(true);
    try {
      const { data } = await axios.post("/api/auth/register", { email, password });
      if (data.success) {
        await signIn("credentials", {
          redirect: false,
          email,
          password
        });
        router.replace("/dashboard");
      } else {
        addToast({ title: t("signup.failed"), status: "error" });
      }
    } catch (err) {
      console.error(err);
      addToast({ title: t("signup.failed"), status: "error" });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="max-w-md w-full bg-white p-8 rounded-lg shadow">
        <h2 className="text-2xl font-bold text-center text-gray-800 mb-6">
          {t("signup.title")}
        </h2>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
              {t("signup.email")}
            </label>
            <Input
              id="email"
              type="email"
              required
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder={t("signup.emailPlaceholder")}
            />
          </div>
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-gray-700">
              {t("signup.password")}
            </label>
            <Input
              id="password"
              type="password"
              required
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder={t("signup.passwordPlaceholder")}
            />
          </div>
          <div>
            <label htmlFor="confirm" className="block text-sm font-medium text-gray-700">
              {t("signup.confirmPassword")}
            </label>
            <Input
              id="confirm"
              type="password"
              required
              value={confirm}
              onChange={(e) => setConfirm(e.target.value)}
              placeholder={t("signup.confirmPasswordPlaceholder")}
            />
          </div>
          <Button type="submit" disabled={isSubmitting} className="w-full">
            {isSubmitting ? t("signup.signingUp") : t("signup.signupButton")}
          </Button>
          <p className="text-center text-sm text-gray-600">
            {t("signup.haveAccount")}{" "}
            <Link href="/login">
              <a className="text-accent hover:underline">{t("signup.login")}</a>
            </Link>
          </p>
        </form>
      </div>
    </div>
  );
}

Signup.authRequired = false;

export async function getStaticProps({ locale }: any) {
  return {
    props: {
      ...(await serverSideTranslations(locale, ["common"]))
    }
  };
}
/frontend/pages/forgot-password.tsx
import { useState, FormEvent } from "react";
import Button from "../components/common/Button";
import Input from "../components/common/Input";
import { useToast } from "../components/common/ToastProvider";
import axios from "axios";
import { serverSideTranslations } from "next-i18next/serverSideTranslations";
import { useTranslation } from "next-i18next";

export default function ForgotPassword() {
  const [email, setEmail] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { addToast } = useToast();
  const { t } = useTranslation("common");

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    try {
      await axios.post("/api/auth/forgot-password", { email });
      addToast({ title: t("forgotPassword.sent"), status: "success" });
    } catch (err) {
      console.error(err);
      addToast({ title: t("forgotPassword.error"), status: "error" });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="max-w-md w-full bg-white p-8 rounded-lg shadow">
        <h2 className="text-2xl font-bold text-center text-gray-800 mb-6">
          {t("forgotPassword.title")}
        </h2>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
              {t("forgotPassword.email")}
            </label>
            <Input
              id="email"
              type="email"
              required
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder={t("forgotPassword.emailPlaceholder")}
            />
          </div>
          <Button type="submit" disabled={isSubmitting} className="w-full">
            {isSubmitting ? t("forgotPassword.sending") : t("forgotPassword.sendButton")}
          </Button>
          <p className="text-center text-sm text-gray-600">
            <a href="/login" className="text-accent hover:underline">
              {t("forgotPassword.backToLogin")}
            </a>
          </p>
        </form>
      </div>
    </div>
  );
}

ForgotPassword.authRequired = false;

export async function getStaticProps({ locale }: any) {
  return {
    props: {
      ...(await serverSideTranslations(locale, ["common"]))
    }
  };
}
/frontend/pages/reset-password.tsx
import { useState, FormEvent } from "react";
import { useRouter } from "next/router";
import Button from "../components/common/Button";
import Input from "../components/common/Input";
import { useToast } from "../components/common/ToastProvider";
import axios from "axios";
import { serverSideTranslations } from "next-i18next/serverSideTranslations";
import { useTranslation } from "next-i18next";

export default function ResetPassword() {
  const router = useRouter();
  const { token } = router.query;
  const [password, setPassword] = useState("");
  const [confirm, setConfirm] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { addToast } = useToast();
  const { t } = useTranslation("common");

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    if (password !== confirm) {
      addToast({ title: t("resetPassword.mismatch"), status: "error" });
      return;
    }
    setIsSubmitting(true);
    try {
      await axios.post("/api/auth/reset-password", { token, password });
      addToast({ title: t("resetPassword.success"), status: "success" });
      router.replace("/login");
    } catch (err) {
      console.error(err);
      addToast({ title: t("resetPassword.error"), status: "error" });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="max-w-md w-full bg-white p-8 rounded-lg shadow">
        <h2 className="text-2xl font-bold text-center text-gray-800 mb-6">
          {t("resetPassword.title")}
        </h2>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-gray-700">
              {t("resetPassword.newPassword")}
            </label>
            <Input
              id="password"
              type="password"
              required
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder={t("resetPassword.newPasswordPlaceholder")}
            />
          </div>
          <div>
            <label htmlFor="confirm" className="block text-sm font-medium text-gray-700">
              {t("resetPassword.confirmPassword")}
            </label>
            <Input
              id="confirm"
              type="password"
              required
              value={confirm}
              onChange={(e) => setConfirm(e.target.value)}
              placeholder={t("resetPassword.confirmPasswordPlaceholder")}
            />
          </div>
          <Button type="submit" disabled={isSubmitting} className="w-full">
            {isSubmitting ? t("resetPassword.submitting") : t("resetPassword.resetButton")}
          </Button>
        </form>
      </div>
    </div>
  );
}

ResetPassword.authRequired = false;

export async function getStaticProps({ locale }: any) {
  return {
    props: {
      ...(await serverSideTranslations(locale, ["common"]))
    }
  };
}
/frontend/pages/dashboard/index.tsx
import { useQuery } from "react-query";
import axios from "axios";
import ChartWrapper from "../../components/common/ChartWrapper";
import { LineChart, Line, XAxis, YAxis, Tooltip, CartesianGrid, BarChart, Bar, AreaChart, Area, PieChart, Pie, Cell, ResponsiveContainer } from "recharts";
import { useTranslation } from "next-i18next";
import { serverSideTranslations } from "next-i18next/serverSideTranslations";

interface GrowthData {
  month: string;
  count: number;
}

interface VaultUsageData {
  month: string;
  bytes: number;
}

interface SubscriptionMetrics {
  plan: string;
  count: number;
}

interface ApiUsageData {
  feature: string;
  value: number;
}

export default function Dashboard() {
  const { t } = useTranslation("common");

  const { data: growthData = [], isLoading: loadingGrowth } = useQuery<GrowthData[]>("userGrowth", async () => {
    const { data } = await axios.get("/api/dashboard/metrics/users");
    return data.growth;
  });

  const { data: subscriptionMetrics = [], isLoading: loadingSubscriptions } =
    useQuery<SubscriptionMetrics[]>("subscriptionMetrics", async () => {
      const { data } = await axios.get("/api/dashboard/metrics/subscriptions");
      return Object.entries(data.byPlan).map(([plan, count]) => ({ plan, count }));
    });

  const churnRate = useQuery<{ churnRate: number }>("churnRate", async () => {
    const { data } = await axios.get("/api/dashboard/metrics/subscriptions");
    return { churnRate: data.churnRate };
  });

  const { data: vaultUsage = [], isLoading: loadingVault } = useQuery<VaultUsageData[]>(
    "vaultUsage",
    async () => {
      const { data } = await axios.get("/api/dashboard/metrics/vault");
      return data.monthlyUsage;
    }
  );

  const { data: apiUsage = [], isLoading: loadingApiUsage } = useQuery<ApiUsageData[]>(
    "apiUsage",
    async () => {
      const { data } = await axios.get("/api/dashboard/metrics/api-usage");
      return Object.entries(data.callsByFeature).map(([feature, value]) => ({ feature, value }));
    }
  );

  return (
    <div>
      <h1 className="text-2xl font-bold mb-6">{t("dashboard.title")}</h1>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {/* User Growth */}
        <ChartWrapper title={t("dashboard.userGrowth")}>
          {loadingGrowth ? (
            <p>{t("dashboard.loading")}</p>
          ) : (
            <ResponsiveContainer width="100%" height={200}>
              <LineChart data={growthData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip />
                <Line type="monotone" dataKey="count" stroke="#174EA6" />
              </LineChart>
            </ResponsiveContainer>
          )}
        </ChartWrapper>

        {/* Subscription Metrics */}
        <ChartWrapper title={t("dashboard.subscriptionMetrics")}>
          {loadingSubscriptions ? (
            <p>{t("dashboard.loading")}</p>
          ) : (
            <ResponsiveContainer width="100%" height={200}>
              <BarChart data={subscriptionMetrics}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="plan" />
                <YAxis />
                <Tooltip />
                <Bar dataKey="count" fill="#174EA6" />
              </BarChart>
            </ResponsiveContainer>
          )}
          {!loadingSubscriptions && (
            <p className="mt-2">{t("dashboard.churnRate", { rate: (churnRate.data?.churnRate || 0) * 100 })}</p>
          )}
        </ChartWrapper>

        {/* Vault Usage */}
        <ChartWrapper title={t("dashboard.vaultUsage")}>
          {loadingVault ? (
            <p>{t("dashboard.loading")}</p>
          ) : (
            <ResponsiveContainer width="100%" height={200}>
              <AreaChart data={vaultUsage}>
                <defs>
                  <linearGradient id="colorBytes" x1="0" y1="0" x2="0" y2="1">
                    <stop offset="5%" stopColor="#174EA6" stopOpacity={0.8} />
                    <stop offset="95%" stopColor="#174EA6" stopOpacity={0} />
                  </linearGradient>
                </defs>
                <XAxis dataKey="month" />
                <YAxis />
                <CartesianGrid strokeDasharray="3 3" />
                <Tooltip />
                <Area type="monotone" dataKey="bytes" stroke="#174EA6" fillOpacity={1} fill="url(#colorBytes)" />
              </AreaChart>
            </ResponsiveContainer>
          )}
        </ChartWrapper>

        {/* API Usage */}
        <ChartWrapper title={t("dashboard.apiUsage")}>
          {loadingApiUsage ? (
            <p>{t("dashboard.loading")}</p>
          ) : (
            <ResponsiveContainer width="100%" height={200}>
              <PieChart>
                <Pie
                  data={apiUsage}
                  dataKey="value"
                  nameKey="feature"
                  cx="50%"
                  cy="50%"
                  outerRadius={60}
                  fill="#174EA6"
                  label
                >
                  {apiUsage.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={["#174EA6", "#1F3D7A", "#FFD700", "#8884d8"][index % 4]} />
                  ))}
                </Pie>
                <Tooltip />
              </PieChart>
            </ResponsiveContainer>
          )}
          {!loadingApiUsage && (
            <p className="mt-2">{t("dashboard.errorRate", { rate: 1.5 })}</p>
          )}
        </ChartWrapper>
      </div>
    </div>
  );
}

Dashboard.authRequired = true;

export async function getStaticProps({ locale }: any) {
  return {
    props: {
      ...(await serverSideTranslations(locale, ["common"]))
    }
  };
}
Create a new folder at the root called /frontend (sitting alongside /backend). Inside /frontend, initialize a Next.js + TypeScript project:

cd frontend
npm init -y
npm install next react react-dom typescript @types/react @types/node
Then install additional dependencies:

npm install \
  next-auth @next-auth/prisma-adapter \
  axios swr \
  tailwindcss postcss autoprefixer \
  shadcn-ui lucide-react framer-motion recharts \
  react-hook-form zod @hookform/resolvers \
  jwt-decode \
  react-hot-toast \
  react-datepicker \
  nprogress
And the dev-deps:

npm install -D \
  @types/node @types/react @types/zod eslint prettier eslint-config-prettier eslint-plugin-react \
  eslint-plugin-react-hooks \
  @typescript-eslint/parser @typescript-eslint/eslint-plugin \
  postcss autoprefixer tailwindcss
5.1.1 package.json

// frontend/package.json
{
  "name": "legacy-pro-frontend",
  "version": "1.0.0",
  "scripts": {
    "dev": "next dev -p 3000",
    "build": "next build",
    "start": "next start",
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx",
    "format": "prettier --write ."
  },
  "dependencies": {
    "axios": "^0.27.2",
    "framer-motion": "^6.2.4",
    "jwt-decode": "^3.1.2",
    "lucide-react": "^0.254.0",
    "next": "^13.0.0",
    "next-auth": "^4.10.3",
    "nprogress": "^0.2.0",
    "react": "^18.2.0",
    "react-datepicker": "^4.8.0",
    "react-dom": "^18.2.0",
    "react-hook-form": "^7.34.2",
    "react-hot-toast": "^2.4.0",
    "recharts": "^2.1.15",
    "swr": "^1.3.0",
    "tailwindcss": "^3.1.8",
    "zod": "^3.18.0",
    "@hookform/resolvers": "^2.9.11",
    "shadcn-ui": "^0.3.1"
  },
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^5.29.0",
    "@typescript-eslint/parser": "^5.29.0",
    "@types/jwt-decode": "^3.1.1",
    "@types/node": "^18.0.0",
    "@types/react": "^18.0.9",
    "@types/react-datepicker": "^4.4.2",
    "@types/react-dom": "^18.0.5",
    "@types/zod": "^3.11.10",
    "autoprefixer": "^10.4.7",
    "eslint": "^8.19.0",
    "eslint-config-prettier": "^8.5.0",
    "eslint-plugin-react": "^7.31.8",
    "eslint-plugin-react-hooks": "^4.6.0",
    "postcss": "^8.4.14",
    "prettier": "^2.7.1",
    "tailwindcss": "^3.1.8"
  }
}
5.1.2 tsconfig.json

// frontend/tsconfig.json
{
  "compilerOptions": {
    "target": "ES2021",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": false,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}
5.1.3 next.config.js

// frontend/next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  typescript: { ignoreBuildErrors: false },
  images: {
    domains: ["your-s3-bucket.s3.amazonaws.com", "avatars.githubusercontent.com"],
  },
  env: {
    NEXT_PUBLIC_API_BASE: process.env.NEXT_PUBLIC_API_BASE || "http://localhost:4000/api",
  },
};

module.exports = nextConfig;
5.1.4 postcss.config.js & tailwind.config.js

// frontend/postcss.config.js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

// frontend/tailwind.config.js
module.exports = {
  content: ["./src/**/*.{js,ts,jsx,tsx}"],
  theme: { extend: {} },
  plugins: [],
};
5.1.5 /public assets
Place a favicon in /public/favicon.ico.

Add any logo or static images under /public/images/.

5.2 Directory Structure

/frontend
├── package.json
├── tsconfig.json
├── next.config.js
├── postcss.config.js
├── tailwind.config.js
├── public/
│   └── favicon.ico
│   └── images/
├── src/
│   ├── pages/
│   │   ├── _app.tsx
│   │   ├── _document.tsx
│   │   ├── index.tsx
│   │   ├── login.tsx
│   │   ├── register.tsx
│   │   ├── dashboard/
│   │   │   ├── index.tsx
│   │   │   ├── metrics/
│   │   │   │   ├── users.tsx
│   │   │   │   ├── subscriptions.tsx
│   │   │   │   ├── vault.tsx
│   │   │   │   └── api-usage.tsx
│   │   ├── trusts/
│   │   │   ├── index.tsx        // list + “Create Trust”
│   │   │   ├── create.tsx       // step-by-step form
│   │   │   ├── [id].tsx         // view/edit a specific trust
│   │   │   ├── [id]/finalize.tsx
│   │   │   └── [id]/compliance.tsx
│   │   ├── entities/
│   │   │   ├── index.tsx
│   │   │   ├── create.tsx
│   │   │   ├── [id].tsx
│   │   │   ├── [id]/finalize.tsx
│   │   │   └── [id]/compliance.tsx
│   │   ├── legacy-letter/
│   │   │   ├── index.tsx
│   │   │   ├── create.tsx
│   │   │   ├── [id].tsx
│   │   │   ├── [id]/finalize.tsx
│   │   │   └── [id]/compliance.tsx
│   │   ├── vault/
│   │   │   ├── index.tsx        // folder tree + file list
│   │   │   ├── folder/[folderId].tsx
│   │   │   └── emergency.tsx
│   │   ├── subscriptions/
│   │   │   ├── index.tsx        // plan selection & status
│   │   │   └── status.tsx
│   │   ├── notifications.tsx
│   │   ├── profile.tsx
│   │   └── settings/
│   │       ├── index.tsx        // tabs: account, security, billing
│   │       ├── security.tsx
│   │       └── billing.tsx
│   ├── components/
│   │   ├── Layout.tsx
│   │   ├── Navbar.tsx
│   │   ├── Sidebar.tsx
│   │   ├── Button.tsx
│   │   ├── Input.tsx
│   │   ├── Spinner.tsx
│   │   ├── Modal.tsx
│   │   ├── FileUploader.tsx
│   │   ├── SSEReader.tsx       // utility for Server‐Sent Events
│   │   ├── Chart.tsx           // wrapper for Recharts
│   │   ├── DatePicker.tsx
│   │   └── ToastProvider.tsx
│   ├── hooks/
│   │   ├── useUser.ts          // fetch /users/me
│   │   ├── useAuth.ts          // NextAuth wrappers
│   │   ├── useSSE.ts           // SSE streaming hook
│   │   ├── useFormFields.ts    // common Form hook
│   │   └── useVaultTree.ts     // fetch folder structure + manage updates
│   ├── lib/
│   │   ├── api.ts              // Axios instance, interceptors
│   │   ├── auth.ts             // NextAuth config
│   │   └── validators.ts       // Zod schemas for forms
│   ├── styles/
│   │   ├── globals.css
│   │   └── tailwind.css
│   └── utils/
│       ├── formatDate.ts
│       ├── calculateStorageMB.ts
│       ├── token.ts           // JWT decode, get user role
│       └── constants.ts
└── README.md
Everything under src/ is written in TypeScript/TSX.

5.3 Global Configuration
5.3.1 src/pages/_app.tsx

// frontend/src/pages/_app.tsx
import "@/styles/globals.css";
import { SessionProvider } from "next-auth/react";
import { ToastProvider } from "@/components/ToastProvider";
import Layout from "@/components/Layout";
import NProgress from "nprogress";
import Router from "next/router";
import "nprogress/nprogress.css";

Router.events.on("routeChangeStart", () => NProgress.start());
Router.events.on("routeChangeComplete", () => NProgress.done());
Router.events.on("routeChangeError", () => NProgress.done());

export default function App({
  Component,
  pageProps: { session, ...pageProps },
}: {
  Component: any;
  pageProps: any;
}) {
  return (
    <SessionProvider session={session}>
      <ToastProvider>
        <Layout>
          <Component {...pageProps} />
        </Layout>
      </ToastProvider>
    </SessionProvider>
  );
}
5.3.2 src/pages/_document.tsx
Standard setup for SSR plus custom fonts (if desired):


// frontend/src/pages/_document.tsx
import Document, { Html, Head, Main, NextScript } from "next/document";

class MyDocument extends Document {
  render() {
    return (
      <Html lang="en">
        <Head>
          <link rel="preconnect" href="https://fonts.googleapis.com" />
          {/* Add Google Fonts or other metadata here */}
        </Head>
        <body className="bg-gray-50 text-gray-800">
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;
5.3.3 src/lib/api.ts (Axios instance)

// frontend/src/lib/api.ts
import axios from "axios";
import { getSession } from "next-auth/react";

const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_BASE,
  headers: { "Content-Type": "application/json" },
});

// Attach JWT to every request
api.interceptors.request.use(async (config) => {
  const session = await getSession();
  if (session?.user?.accessToken) {
    config.headers.Authorization = `Bearer ${session.user.accessToken}`;
  }
  return config;
});

export default api;
Note: Ensure your NextAuth callback sets accessToken in session.user. (Will configure in auth.ts below.)

5.3.4 src/lib/auth.ts (NextAuth config)

// frontend/src/lib/auth.ts
import NextAuth from "next-auth";
import DiscordProvider from "next-auth/providers/discord";
import GitHubProvider from "next-auth/providers/github";
import CredentialsProvider from "next-auth/providers/credentials";
import { PrismaAdapter } from "@next-auth/prisma-adapter";
import prisma from "@/prisma"; // you need to export a Prisma client from root or adjust path

export default NextAuth({
  adapter: PrismaAdapter(prisma),
  session: {
    strategy: "jwt",
  },
  jwt: {
    secret: process.env.NEXTAUTH_SECRET,
  },
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
      },
      authorize: async (credentials) => {
        // Delegate to your backend /api/auth/login or direct Prisma check
        const res = await fetch(`${process.env.NEXT_PUBLIC_API_BASE}/auth/login`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(credentials),
        });
        const user = await res.json();
        if (res.ok && user) {
          return {
            id: user.id,
            name: user.name,
            email: user.email,
            role: user.role,
            accessToken: user.token, // have backend respond with JWT
          };
        }
        return null;
      },
    }),
    GitHubProvider({
      clientId: process.env.GITHUB_ID!,
      clientSecret: process.env.GITHUB_SECRET!,
    }),
    // Add Google/etc. as needed
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.role = (user as any).role;
        token.accessToken = (user as any).accessToken; 
      }
      return token;
    },
    async session({ session, token }) {
      session.user.id = token.sub!;
      session.user.role = token.role as string;
      session.user.accessToken = token.accessToken as string;
      return session;
    },
  },
  pages: {
    signIn: "/login",
  },
});
Important: You must create /src/pages/api/auth/[...nextauth].ts and simply import this above. That ensures NextAuth works server‐side.


// frontend/src/pages/api/auth/[...nextauth].ts
import NextAuthConfig from "@/lib/auth";
export default NextAuthConfig;
5.4 Shared Components & Utilities
We’ll build a handful of reusable components and hooks that every page uses.

5.4.1 src/components/Layout.tsx
A top‐level layout with navbar/sidebar:


// frontend/src/components/Layout.tsx
import { useRouter } from "next/router";
import Navbar from "./Navbar";
import Sidebar from "./Sidebar";
import { useSession } from "next-auth/react";
import { ReactNode } from "react";

export default function Layout({ children }: { children: ReactNode }) {
  const { data: session, status } = useSession();
  const router = useRouter();

  // If unauthenticated and trying to access a protected route, redirect to /login
  const publicPaths = ["/login", "/register"];
  if (status === "loading") return <div className="h-screen flex justify-center items-center">Loading...</div>;
  if (status === "unauthenticated" && !publicPaths.includes(router.pathname)) {
    router.push("/login");
    return null;
  }

  return (
    <div className="flex h-screen bg-gray-100">
      {session && <Sidebar />}
      <div className="flex-1 flex flex-col overflow-hidden">
        {session && <Navbar />}
        <main className="flex-1 overflow-auto p-6">{children}</main>
      </div>
    </div>
  );
}
5.4.2 src/components/Navbar.tsx
Basic top bar with user menu:

// frontend/src/components/Navbar.tsx
import Link from "next/link";
import { signOut, useSession } from "next-auth/react";
import { useState } from "react";
import { Menu, X } from "lucide-react";

export default function Navbar() {
  const { data: session } = useSession();
  const [mobileOpen, setMobileOpen] = useState(false);

  return (
    <header className="bg-white shadow-md px-4 py-3 flex items-center justify-between">
      <button onClick={() => setMobileOpen((o) => !o)} className="sm:hidden">
        {mobileOpen ? <X size={24} /> : <Menu size={24} />}
      </button>
      <div className="text-xl font-bold">Legacy Pro</div>
      <div className="flex items-center space-x-4">
        <Link href="/profile">
          <a className="text-gray-600 hover:text-gray-800">{session?.user?.name || session?.user?.email}</a>
        </Link>
        <button onClick={() => signOut()} className="text-red-500 hover:text-red-700">
          Sign Out
        </button>
      </div>
    </header>
  );
}
5.4.3 src/components/Sidebar.tsx
Vertical navigation menu:


// frontend/src/components/Sidebar.tsx
import Link from "next/link";
import { useRouter } from "next/router";
import {
  Home, FileText, ShieldCheck, Archive, Users, Settings,
} from "lucide-react";

const navItems = [
  { href: "/dashboard", label: "Dashboard", icon: <Home size={20} /> },
  { href: "/trusts", label: "Trusts", icon: <ShieldCheck size={20} /> },
  { href: "/entities", label: "Entities", icon: <Users size={20} /> },
  { href: "/legacy-letter", label: "Legacy Letters", icon: <FileText size={20} /> },
  { href: "/vault", label: "Vault", icon: <Archive size={20} /> },
  { href: "/subscriptions", label: "Subscriptions", icon: <Users size={20} /> },
  { href: "/notifications", label: "Notifications", icon: <Users size={20} /> },
  { href: "/settings", label: "Settings", icon: <Settings size={20} /> },
];

export default function Sidebar() {
  const router = useRouter();
  return (
    <aside className="w-64 bg-white shadow-md hidden sm:flex flex-col">
      <div className="h-16 flex items-center justify-center text-2xl font-bold">Logo</div>
      <nav className="flex-1 overflow-y-auto">
        {navItems.map((item) => (
          <Link href={item.href} key={item.href}>
            <a
              className={`flex items-center px-4 py-3 hover:bg-gray-100 ${
                router.pathname.startsWith(item.href) ? "bg-gray-200 font-semibold" : ""
              }`}
            >
              <span className="mr-3">{item.icon}</span>
              {item.label}
            </a>
          </Link>
        ))}
      </nav>
    </aside>
  );
}
5.4.4 src/components/Button.tsx

// frontend/src/components/Button.tsx
import { ButtonHTMLAttributes, ReactNode } from "react";

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  children: ReactNode;
  variant?: "primary" | "secondary" | "danger" | "outline";
}

export default function Button({ children, variant = "primary", ...props }: ButtonProps) {
  const base = "px-4 py-2 rounded-lg font-medium focus:outline-none transition";
  const variants = {
    primary: "bg-blue-600 text-white hover:bg-blue-700",
    secondary: "bg-gray-200 text-gray-800 hover:bg-gray-300",
    danger: "bg-red-600 text-white hover:bg-red-700",
    outline: "border border-gray-300 text-gray-700 hover:bg-gray-50",
  };
  return (
    <button className={`${base} ${variants[variant]}`} {...props}>
      {children}
    </button>
  );
}
5.4.5 src/components/Input.tsx
Simple styled input:

// frontend/src/components/Input.tsx
import { InputHTMLAttributes } from "react";

export default function Input(props: InputHTMLAttributes<HTMLInputElement>) {
  return (
    <input
      className="border border-gray-300 rounded-md px-3 py-2 w-full focus:ring-blue-500 focus:border-blue-500"
      {...props}
    />
  );
}
5.4.6 src/components/Spinner.tsx
// frontend/src/components/Spinner.tsx
export default function Spinner() {
  return (
    <div className="flex justify-center items-center">
      <svg
        className="animate-spin h-8 w-8 text-blue-600"
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
      >
        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
        <path
          className="opacity-75"
          fill="currentColor"
          d="M4 12a8 8 0 018-8v8H4z"
        />
      </svg>
    </div>
  );
}
5.4.7 src/components/FileUploader.tsx
Used to request a presigned URL, upload to S3, then notify backend:

// frontend/src/components/FileUploader.tsx
import { ChangeEvent, useState } from "react";
import api from "@/lib/api";
import Button from "./Button";

interface FileUploaderProps {
  folderId: string;
  onUploadComplete: () => void;
}

export default function FileUploader({ folderId, onUploadComplete }: FileUploaderProps) {
  const [isUploading, setIsUploading] = useState(false);

  const handleFileChange = async (e: ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files?.length) return;
    setIsUploading(true);
    const file = e.target.files[0];
    try {
      // 1. Get presigned URL from backend
      const { data } = await api.post("/vault/upload-url", {
        fileName: file.name,
        fileType: file.type,
        size: file.size,
      });
      const { key, url } = data;
      // 2. Upload to S3
      await fetch(url, {
        method: "PUT",
        headers: { "Content-Type": file.type },
        body: file,
      });
      // 3. Notify backend that upload is complete
      await api.post("/vault/files", {
        fileName: file.name,
        fileType: file.type,
        size: file.size,
        folderId,
        s3Key: key,
      });
      onUploadComplete();
    } catch (err) {
      console.error(err);
    } finally {
      setIsUploading(false);
    }
  };

  return (
    <div>
      <input type="file" onChange={handleFileChange} disabled={isUploading} />
      {isUploading && <div className="mt-2 text-sm text-gray-500">Uploading…</div>}
    </div>
  );
}
5.4.8 src/components/SSEReader.tsx
Helper to stream SSE responses (for document generation):

// frontend/src/components/SSEReader.tsx
import { useEffect, useRef, useState } from "react";

interface SSEReaderProps {
  url: string;
  onMessage: (chunk: string) => void;
  onComplete?: () => void;
  onError?: (e: any) => void;
}

export default function SSEReader({ url, onMessage, onComplete, onError }: SSEReaderProps) {
  const eventSourceRef = useRef<EventSource | null>(null);

  useEffect(() => {
    const es = new EventSource(url);
    eventSourceRef.current = es;

    es.onmessage = (e) => {
      onMessage(e.data);
    };
    es.onerror = (e) => {
      onError?.(e);
      es.close();
    };
    es.addEventListener("end", () => {
      onComplete?.();
      es.close();
    });

    return () => {
      es.close();
    };
  }, [url, onMessage, onComplete, onError]);

  return null;
}
Note: Our backend generate routes stream raw text chunks without a named event type. Depending on how you implement SSE on the backend, you may need to adjust this. If your backend simply writes res.write(text) continuously, you can wrap it in a custom hook instead. But this component structure is a starting point.

5.5 Authentication Pages
5.5.1 src/pages/login.tsx

// frontend/src/pages/login.tsx
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { signIn } from "next-auth/react";
import { useRouter } from "next/router";
import Input from "@/components/Input";
import Button from "@/components/Button";
import { useState } from "react";
import toast from "react-hot-toast";

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(6),
});

export default function LoginPage() {
  const router = useRouter();
  const [loading, setLoading] = useState(false);
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<z.infer<typeof loginSchema>>({
    resolver: zodResolver(loginSchema),
  });

  const onSubmit = async (data: z.infer<typeof loginSchema>) => {
    setLoading(true);
    const res = await signIn("credentials", {
      redirect: false,
      email: data.email,
      password: data.password,
    });
    setLoading(false);
    if (res?.error) {
      toast.error(res.error);
    } else {
      router.push("/dashboard");
    }
  };

  return (
    <div className="h-screen flex items-center justify-center bg-gray-50">
      <div className="w-full max-w-md bg-white p-8 shadow-md rounded-lg">
        <h1 className="text-2xl font-bold mb-6">Sign In</h1>
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
              Email
            </label>
            <Input id="email" type="email" {...register("email")} />
            {errors.email && <p className="mt-1 text-xs text-red-500">{errors.email.message}</p>}
          </div>
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-gray-700">
              Password
            </label>
            <Input id="password" type="password" {...register("password")} />
            {errors.password && <p className="mt-1 text-xs text-red-500">{errors.password.message}</p>}
          </div>
          <Button type="submit" disabled={loading} variant="primary">
            {loading ? "Signing In…" : "Sign In"}
          </Button>
        </form>
        <p className="mt-4 text-sm text-gray-600">
          Don’t have an account?{" "}
          <a href="/register" className="text-blue-600 hover:underline">
            Register
          </a>
        </p>
      </div>
    </div>
  );
}
5.5.2 src/pages/register.tsx
// frontend/src/pages/register.tsx
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import api from "@/lib/api";
import Input from "@/components/Input";
import Button from "@/components/Button";
import { useState } from "react";
import { useRouter } from "next/router";
import toast from "react-hot-toast";

const registerSchema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
  password: z.string().min(6),
});

export default function RegisterPage() {
  const router = useRouter();
  const [loading, setLoading] = useState(false);
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<z.infer<typeof registerSchema>>({
    resolver: zodResolver(registerSchema),
  });

  const onSubmit = async (data: z.infer<typeof registerSchema>) => {
    setLoading(true);
    try {
      await api.post("/auth/register", data);
      toast.success("Registration successful! Please login.");
      router.push("/login");
    } catch (err: any) {
      toast.error(err.response?.data?.error || "Registration failed.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="h-screen flex items-center justify-center bg-gray-50">
      <div className="w-full max-w-md bg-white p-8 shadow-md rounded-lg">
        <h1 className="text-2xl font-bold mb-6">Register</h1>
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          <div>
            <label htmlFor="name" className="block text-sm font-medium text-gray-700">
              Name
            </label>
            <Input id="name" type="text" {...register("name")} />
            {errors.name && <p className="mt-1 text-xs text-red-500">{errors.name.message}</p>}
          </div>
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
              Email
            </label>
            <Input id="email" type="email" {...register("email")} />
            {errors.email && <p className="mt-1 text-xs text-red-500">{errors.email.message}</p>}
          </div>
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-gray-700">
              Password
            </label>
            <Input id="password" type="password" {...register("password")} />
            {errors.password && <p className="mt-1 text-xs text-red-500">{errors.password.message}</p>}
          </div>
          <Button type="submit" disabled={loading} variant="primary">
            {loading ? "Registering…" : "Register"}
          </Button>
        </form>
        <p className="mt-4 text-sm text-gray-600">
          Already have an account?{" "}
          <a href="/login" className="text-blue-600 hover:underline">
            Sign In
          </a>
        </p>
      </div>
    </div>
  );
}
Backend Reminder: Ensure your backend has an /api/auth/register route that creates a new user in Prisma, hashes the password with bcrypt, etc. If not, create it exactly like your /auth/login route (mirroring NextAuth’s Credentials verify flow).

5.6 “Me” & Profile
5.6.1 src/hooks/useUser.ts
// frontend/src/hooks/useUser.ts
import useSWR from "swr";
import api from "@/lib/api";

export function useUser() {
  const { data, error, isValidating, mutate } = useSWR("/users/me", (url) => api.get(url).then((res) => res.data));
  return {
    user: data,
    isLoading: !error && !data,
    isError: error,
    mutate,
  };
}
5.6.2 src/pages/profile.tsx
// frontend/src/pages/profile.tsx
import { useForm } from "react-hook-form";
import Input from "@/components/Input";
import Button from "@/components/Button";
import { useUser } from "@/hooks/useUser";
import api from "@/lib/api";
import { useState } from "react";
import toast from "react-hot-toast";

type ProfileForm = { name: string; locale: string };

export default function ProfilePage() {
  const { user, isLoading } = useUser();
  const [loading, setLoading] = useState(false);
  const { register, handleSubmit, reset } = useForm<ProfileForm>();

  // When user data is ready, set default values
  if (user) {
    reset({ name: user.name || "", locale: user.locale });
  }

  const onSubmit = async (data: ProfileForm) => {
    setLoading(true);
    try {
      await api.patch("/users/me", data);
      toast.success("Profile updated");
    } catch (err: any) {
      toast.error(err.response?.data?.error || "Error updating profile");
    } finally {
      setLoading(false);
    }
  };

  if (isLoading) return <div>Loading…</div>;
  return (
    <div className="max-w-lg mx-auto bg-white p-6 rounded-lg shadow-md">
      <h1 className="text-xl font-semibold mb-4">My Profile</h1>
      <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
        <div>
          <label className="block text-sm font-medium text-gray-700">Name</label>
          <Input {...register("name")} />
        </div>
        <div>
          <label className="block text-sm font-medium text-gray-700">Locale</label>
          <select {...register("locale")} className="border border-gray-300 rounded-md px-3 py-2 w-full">
            <option value="en">English</option>
            <option value="es">Español</option>
            {/* Add more as needed */}
          </select>
        </div>
        <Button type="submit" variant="primary" disabled={loading}>
          {loading ? "Saving…" : "Save"}
        </Button>
      </form>
    </div>
  );
}
5.7 Security & 2FA
5.7.1 src/pages/settings/security.tsx
// frontend/src/pages/settings/security.tsx
import { useState } from "react";
import { useUser } from "@/hooks/useUser";
import api from "@/lib/api";
import Button from "@/components/Button";
import toast from "react-hot-toast";
import Input from "@/components/Input";

export default function SecuritySettings() {
  const { user } = useUser();
  const [qrUrl, setQrUrl] = useState<string | null>(null);
  const [token, setToken] = useState("");
  const [enabling, setEnabling] = useState(false);
  const [disabling, setDisabling] = useState(false);

  const setup2FA = async () => {
    setEnabling(true);
    try {
      const res = await api.post("/users/me/2fa/setup");
      setQrUrl(res.data.qrCodeDataURL);
      toast.success("Scan this QR code in your authenticator app");
    } catch (err: any) {
      toast.error(err.response?.data?.error || "Error setting up 2FA");
    } finally {
      setEnabling(false);
    }
  };

  const verify2FA = async () => {
    if (!token.trim()) return;
    setEnabling(true);
    try {
      await api.post("/users/me/2fa/verify", { token });
      toast.success("2FA enabled");
      setQrUrl(null);
      setToken("");
    } catch (err: any) {
      toast.error(err.response?.data?.error || "Invalid token");
    } finally {
      setEnabling(false);
    }
  };

  const disable2FA = async () => {
    setDisabling(true);
    try {
      await api.delete("/users/me/2fa");
      toast.success("2FA disabled");
    } catch (err: any) {
      toast.error(err.response?.data?.error || "Error disabling 2FA");
    } finally {
      setDisabling(false);
    }
  };

  return (
    <div className="max-w-md mx-auto bg-white p-6 rounded-lg shadow-md space-y-6">
      <h2 className="text-xl font-semibold">Security Settings</h2>
      <div>
        <p>
          Two‐Factor Authentication:{" "}
          <strong>{user?.twoFAEnabled ? "Enabled" : "Disabled"}</strong>
        </p>
        {!user?.twoFAEnabled ? (
          <>
            <Button onClick={setup2FA} disabled={enabling || !!qrUrl}>
              {enabling ? "Generating QR…" : "Set up 2FA"}
            </Button>
            {qrUrl && (
              <div className="mt-4 space-y-2">
                <img src={qrUrl} alt="TOTP QR Code" className="mx-auto" />
                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    Enter token from Authenticator
                  </label>
                  <Input
                    type="text"
                    value={token}
                    onChange={(e) => setToken(e.target.value)}
                  />
                  <Button onClick={verify2FA} disabled={enabling}>
                    {enabling ? "Verifying…" : "Verify"}
                  </Button>
                </div>
              </div>
            )}
          </>
        ) : (
          <Button onClick={disable2FA} disabled={disabling}>
            {disabling ? "Disabling…" : "Disable 2FA"}
          </Button>
        )}
      </div>
    </div>
  );
}
Reminder: The backend routes /api/users/me/2fa/setup, /verify, and DELETE /2fa are already implemented (Section 2).

5.8 Subscriptions
5.8.1 src/pages/subscriptions/index.tsx
// frontend/src/pages/subscriptions/index.tsx
import useSWR from "swr";
import api from "@/lib/api";
import { useState } from "react";
import Button from "@/components/Button";
import toast from "react-hot-toast";

type Plan = {
  id: string;
  name: string;
  priceCents: number;
  billingCycle: "MONTHLY" | "ANNUAL";
  storageLimitMB: number;
};

export default function PlansPage() {
  const { data: plans, error } = useSWR<Plan[]>("/subscriptions/plans", (url) =>
    api.get(url).then((res) => res.data)
  );
  const [loading, setLoading] = useState<string | null>(null);

  const subscribe = async (planId: string, priceCents: number) => {
    setLoading(planId);
    try {
      if (priceCents === 0) {
        const res = await api.post("/subscriptions/subscribe", { planId });
        toast.success("Free plan activated!");
      } else {
        const { data } = await api.post("/subscriptions/subscribe", { planId });
        // Redirect to Stripe Checkout
        window.location.href = data.url;
      }
    } catch (err: any) {
      toast.error(err.response?.data?.error || "Subscription failed");
    } finally {
      setLoading(null);
    }
  };

  if (!plans) return <div>Loading plans…</div>;
  if (error) return <div>Error loading plans.</div>;

  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
      {plans.map((plan) => (
        <div key={plan.id} className="bg-white p-6 rounded-lg shadow-md">
          <h3 className="text-lg font-semibold mb-2">{plan.name}</h3>
          <p className="text-2xl font-bold mb-4">
            ${ (plan.priceCents / 100).toFixed(2) } / {plan.billingCycle.toLowerCase()}
          </p>
          <p className="mb-4">Storage: {plan.storageLimitMB} MB</p>
          <Button
            onClick={() => subscribe(plan.id, plan.priceCents)}
            disabled={loading === plan.id}
          >
            {loading === plan.id ? "Processing…" : "Choose Plan"}
          </Button>
        </div>
      ))}
    </div>
  );
}
5.8.2 src/pages/subscriptions/status.tsx
// frontend/src/pages/subscriptions/status.tsx
import useSWR from "swr";
import api from "@/lib/api";
import { BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer } from "recharts";
import Spinner from "@/components/Spinner";

type StatusResp = {
  planName: string;
  status: string;
  storageUsedMB: number;
  storageLimitMB: number;
  nextBillingDate: string | null;
};

export default function SubscriptionStatus() {
  const { data, error } = useSWR<StatusResp>("/subscriptions/status", (url) =>
    api.get(url).then((res) => res.data)
  );

  if (!data) return <Spinner />;
  if (error) return <div>Error fetching status</div>;

  const { planName, status, storageUsedMB, storageLimitMB, nextBillingDate } = data;
  const usagePercent = Math.min(
    Math.round((storageUsedMB / storageLimitMB) * 100),
    100
  );

  return (
    <div className="bg-white p-6 rounded-lg shadow-md max-w-lg mx-auto space-y-6">
      <h2 className="text-xl font-semibold">Subscription Status</h2>
      <p>
        <strong>Plan:</strong> {planName}
      </p>
      <p>
        <strong>Status:</strong> {status}
      </p>
      <div>
        <strong>Storage Usage:</strong> {storageUsedMB} / {storageLimitMB} MB
      </div>
      <div className="h-32">
        <ResponsiveContainer width="100%" height="100%">
          <BarChart data={[{ name: "Used", value: storageUsedMB }]}>
            <XAxis dataKey="name" hide />
            <YAxis hide domain={[0, storageLimitMB]} />
            <Tooltip />
            <Bar dataKey="value" fill="#3b82f6" />
          </BarChart>
        </ResponsiveContainer>
      </div>
      {nextBillingDate && (
        <p>
          <strong>Next Billing:</strong> {new Date(nextBillingDate).toDateString()}
        </p>
      )}
    </div>
  );
}
Backend Reminder: The route /api/subscriptions/status returns exactly { planName, status, storageUsedMB, storageLimitMB, nextBillingDate }.

5.9 Dashboard & Metrics
5.9.1 src/pages/dashboard/index.tsx
// frontend/src/pages/dashboard/index.tsx
import dynamic from "next/dynamic";
import Link from "next/link";
import useSWR from "swr";
import api from "@/lib/api";
import Spinner from "@/components/Spinner";
import { Chart } from "@/components/Chart";

type DashboardMetrics = {
  score: number;
  breakdown: {
    trust: number;
    entity: number;
    vault: number;
    security: number;
    financial: number;
  };
  suggestions: string[];
};

export default function Dashboard() {
  const { data, error } = useSWR<DashboardMetrics>("/dashboard/protection-score", (url) =>
    api.get(url).then((res) => res.data)
  );

  if (!data) return <Spinner />;
  if (error) return <div>Error loading dashboard</div>;

  const { score, breakdown, suggestions } = data;
  const breakdownData = Object.entries(breakdown).map(([key, value]) => ({
    name: key,
    value,
  }));

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold">Protection Score: {score}</h1>
      <div className="h-64 bg-white p-4 rounded-lg shadow-md">
        <Chart data={breakdownData} />
      </div>
      <div className="bg-white p-4 rounded-lg shadow-md">
        <h2 className="text-lg font-semibold mb-2">Suggestions</h2>
        <ul className="list-disc list-inside space-y-1">
          {suggestions.map((s, i) => (
            <li key={i}>{s}</li>
          ))}
        </ul>
      </div>
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
        <Link href="/dashboard/metrics/users">
          <a className="block bg-white p-4 rounded-lg shadow-md hover:bg-gray-50">
            <h3 className="font-medium">User Growth</h3>
          </a>
        </Link>
        <Link href="/dashboard/metrics/subscriptions">
          <a className="block bg-white p-4 rounded-lg shadow-md hover:bg-gray-50">
            <h3 className="font-medium">Subscriptions</h3>
          </a>
        </Link>
        <Link href="/dashboard/metrics/vault">
          <a className="block bg-white p-4 rounded-lg shadow-md hover:bg-gray-50">
            <h3 className="font-medium">Vault Usage</h3>
          </a>
        </Link>
        <Link href="/dashboard/metrics/api-usage">
          <a className="block bg-white p-4 rounded-lg shadow-md hover:bg-gray-50">
            <h3 className="font-medium">API Usage</h3>
          </a>
        </Link>
      </div>
    </div>
  );
}
Backend Reminder: The route /api/dashboard/protection-score produces { score, breakdown, suggestions } exactly as used here.

5.9.2 src/pages/dashboard/metrics/users.tsx
// frontend/src/pages/dashboard/metrics/users.tsx
import useSWR from "swr";
import api from "@/lib/api";
import Spinner from "@/components/Spinner";
import { BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer } from "recharts";

type Growth = { month: string; count: string }[];

export default function UserMetrics() {
  const { data, error } = useSWR<{ growth: Growth; totalUsers: number }>(
    "/dashboard/metrics/users",
    (url) => api.get(url).then((res) => res.data)
  );

  if (!data) return <Spinner />;
  if (error) return <div>Error loading user metrics</div>;

  const chartData = data.growth.map((row) => ({
    month: row.month,
    count: parseInt(row.count),
  }));

  return (
    <div className="bg-white p-6 rounded-lg shadow-md space-y-4">
      <h2 className="text-xl font-semibold">Users (Last 12 Months)</h2>
      <div className="h-64">
        <ResponsiveContainer width="100%" height="100%">
          <BarChart data={chartData.reverse()}>
            <XAxis dataKey="month" />
            <YAxis />
            <Tooltip />
            <Bar dataKey="count" fill="#3b82f6" />
          </BarChart>
        </ResponsiveContainer>
      </div>
      <p>Total Users: {data.totalUsers}</p>
    </div>
  );
}
5.9.3 src/pages/dashboard/metrics/subscriptions.tsx
// frontend/src/pages/dashboard/metrics/subscriptions.tsx
import useSWR from "swr";
import api from "@/lib/api";
import Spinner from "@/components/Spinner";
import { PieChart, Pie, Cell, Tooltip, ResponsiveContainer, Legend } from "recharts";

type ByPlan = Record<string, number>;

export default function SubscriptionMetrics() {
  const { data, error } = useSWR<{ byPlan: ByPlan; churnRate: number }>(
    "/dashboard/metrics/subscriptions",
    (url) => api.get(url).then((res) => res.data)
  );

  if (!data) return <Spinner />;
  if (error) return <div>Error loading subscription metrics</div>;

  const pieData = Object.entries(data.byPlan).map(([name, count]) => ({ name, value: count }));
  const COLORS = ["#3b82f6", "#10b981", "#f59e0b", "#ef4444", "#8b5cf6"];

  return (
    <div className="bg-white p-6 rounded-lg shadow-md space-y-4">
      <h2 className="text-xl font-semibold">Active Subscriptions by Plan</h2>
      <div className="h-64">
        <ResponsiveContainer width="100%" height="100%">
          <PieChart>
            <Pie dataKey="value" isAnimationActive data={pieData} cx="50%" cy="50%" outerRadius={80}>
              {pieData.map((entry, index) => (
                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
              ))}
            </Pie>
            <Tooltip />
            <Legend />
          </PieChart>
        </ResponsiveContainer>
      </div>
      <p>Churn Rate (Last Month): {(data.churnRate * 100).toFixed(2)}%</p>
    </div>
  );
}
5.9.4 src/pages/dashboard/metrics/vault.tsx
// frontend/src/pages/dashboard/metrics/vault.tsx
import useSWR from "swr";
import api from "@/lib/api";
import Spinner from "@/components/Spinner";
import { LineChart, Line, XAxis, YAxis, Tooltip, ResponsiveContainer } from "recharts";

type MonthUsage = { month: string; bytes: string }[];

export default function VaultMetrics() {
  const { data, error } = useSWR<{ monthlyUsage: MonthUsage }>("/dashboard/metrics/vault", (url) =>
    api.get(url).then((res) => res.data)
  );

  if (!data) return <Spinner />;
  if (error) return <div>Error loading vault metrics</div>;

  const chartData = data.monthlyUsage.map((row) => ({
    month: row.month,
    MB: Math.round((parseInt(row.bytes) || 0) / (1024 * 1024)),
  }));

  return (
    <div className="bg-white p-6 rounded-lg shadow-md space-y-4">
      <h2 className="text-xl font-semibold">Vault Uploads (Last 12 Months)</h2>
      <div className="h-64">
        <ResponsiveContainer width="100%" height="100%">
          <LineChart data={chartData.reverse()}>
            <XAxis dataKey="month" />
            <YAxis />
            <Tooltip />
            <Line type="monotone" dataKey="MB" stroke="#3b82f6" strokeWidth={2} />
          </LineChart>
        </ResponsiveContainer>
      </div>
    </div>
  );
}
5.9.5 src/pages/dashboard/metrics/api-usage.tsx
// frontend/src/pages/dashboard/metrics/api-usage.tsx
import useSWR from "swr";
import api from "@/lib/api";
import Spinner from "@/components/Spinner";
import { BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer } from "recharts";

type Usage = Record<string, number>;

export default function APIUsageMetrics() {
  const { data, error } = useSWR<{ callsByFeature: Usage; errorRate: number }>(
    "/dashboard/metrics/api-usage",
    (url) => api.get(url).then((res) => res.data)
  );

  if (!data) return <Spinner />;
  if (error) return <div>Error loading API usage metrics</div>;

  const chartData = Object.entries(data.callsByFeature).map(([feature, tokens]) => ({
    feature,
    tokens,
  }));

  return (
    <div className="bg-white p-6 rounded-lg shadow-md space-y-4">
      <h2 className="text-xl font-semibold">AI Token Usage by Feature</h2>
      <div className="h-64">
        <ResponsiveContainer width="100%" height="100%">
          <BarChart data={chartData}>
            <XAxis dataKey="feature" />
            <YAxis />
            <Tooltip />
            <Bar dataKey="tokens" fill="#3b82f6" />
          </BarChart>
        </ResponsiveContainer>
      </div>
      <p>Error Rate: {(data.errorRate * 100).toFixed(2)}%</p>
    </div>
  );
}
Backend Reminder: You’ve already implemented /api/dashboard/metrics/* routes (Section 3). These frontends simply fetch and visualize that data.

5.10 Trust & Entity Builder
Both Trust and Entity builders follow a similar pattern:

List page: show all user’s drafts/finals, button to create new.

Create page: multi‐step form that collects necessary fields (trustName, type, grantor, trustees, beneficiaries, state, additionalClauses, assetsIncluded).

Stream‐generate: Upon submitting the form, call /api/trusts/generate (or /entities/generate) via SSE to stream back the GPT‐generated document text.

Compliance check: dedicated page that sends existing draft to /api/trusts/compliance-check (or /entities/compliance-check) and shows JSON response.

Finalize: call /api/trusts/{id}/finalize to produce and store PDF; then show a presigned URL to download.

We’ll show representative code for Trust; Entity is analogous.

5.10.1 src/pages/trusts/index.tsx
// frontend/src/pages/trusts/index.tsx
import useSWR from "swr";
import api from "@/lib/api";
import Link from "next/link";
import Button from "@/components/Button";
import Spinner from "@/components/Spinner";
import { useRouter } from "next/router";

type Trust = {
  id: string;
  trustName: string;
  status: "DRAFT" | "FINALIZED";
  createdAt: string;
};

export default function TrustList() {
  const router = useRouter();
  const { data, error, mutate } = useSWR<Trust[]>("/trusts", (url) =>
    api.get(url).then((res) => res.data)
  );

  if (!data) return <Spinner />;
  if (error) return <div>Error loading trusts</div>;

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold">My Trusts</h1>
        <Button onClick={() => router.push("/trusts/create")}>Create New Trust</Button>
      </div>
      {data.length === 0 ? (
        <p>No trusts found. Create one to get started.</p>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {data.map((t) => (
            <div key={t.id} className="bg-white p-4 rounded-lg shadow-md space-y-2">
              <h2 className="font-semibold">{t.trustName}</h2>
              <p>Status: {t.status}</p>
              <p>Created: {new Date(t.createdAt).toLocaleDateString()}</p>
              <div className="flex space-x-2">
                <Link href={`/trusts/${t.id}`}>
                  <a className="text-blue-600 hover:underline">View/Edit</a>
                </Link>
                {t.status === "DRAFT" && (
                  <Link href={`/trusts/${t.id}/compliance`}>
                    <a className="text-green-600 hover:underline">Compliance</a>
                  </Link>
                )}
                {t.status === "DRAFT" && (
                  <Link href={`/trusts/${t.id}/finalize`}>
                    <a className="text-indigo-600 hover:underline">Finalize</a>
                  </Link>
                )}
                {t.status === "FINALIZED" && (
                  <a
                    href="#"
                    onClick={async () => {
                      const res = await api.get(`/trusts/${t.id}/download`);
                      window.open(res.data.url, "_blank");
                    }}
                    className="text-purple-600 hover:underline"
                  >
                    Download PDF
                  </a>
                )}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
Backend Reminder: You need a GET /api/trusts route that returns all trusts for the current user (with fields id, trustName, status, createdAt). If you haven’t added that yet, add it now:

// backend/src/routes/trusts/index.ts
import express from "express";
import authMiddleware from "../../middleware/auth";
import prisma from "../../../prismaClient";

const router = express.Router();

// GET /api/trusts
router.get("/", authMiddleware, async (req, res, next) => {
  try {
    const trusts = await prisma.trust.findMany({
      where: { userId: req.user.id },
      orderBy: { createdAt: "desc" },
      select: { id: true, trustName: true, status: true, createdAt: true },
    });
    res.json(trusts);
  } catch (err) {
    next(err);
  }
});

export default router;
5.10.2 src/pages/trusts/create.tsx
// frontend/src/pages/trusts/create.tsx
import { useForm, useFieldArray } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import api from "@/lib/api";
import { useState } from "react";
import Spinner from "@/components/Spinner";
import Button from "@/components/Button";
import { useRouter } from "next/router";
import SSEReader from "@/components/SSEReader";
import toast from "react-hot-toast";

const trustFormSchema = z.object({
  trustName: z.string().min(3),
  type: z.enum(["REVOCABLE", "IRREVOCABLE", "SPECIAL_NEEDS", "DYNASTY", "MINOR"]),
  grantor: z.object({
    firstName: z.string().min(1),
    lastName: z.string().min(1),
    address: z.string().optional(),
    DOB: z.string().optional(),
  }),
  trustees: z
    .array(
      z.object({
        firstName: z.string().min(1),
        lastName: z.string().min(1),
        address: z.string().optional(),
      })
    )
    .min(1),
  successorTrustees: z
    .array(
      z.object({
        firstName: z.string().min(1),
        lastName: z.string().min(1),
        address: z.string().optional(),
      })
    )
    .optional()
    .default([]),
  beneficiaries: z
    .array(
      z.object({
        firstName: z.string().min(1),
        lastName: z.string().min(1),
        allocation: z.number().min(0).max(100),
        DOB: z.string().optional(),
      })
    )
    .min(1)
    .refine((list) => list.reduce((acc, b) => acc + b.allocation, 0) === 100, {
      message: "Allocations must sum to 100%",
    }),
  state: z.string().length(2),
  assetsIncluded: z
    .array(
      z.object({
        type: z.string().min(1),
        description: z.string().min(1),
      })
    )
    .optional()
    .default([]),
  additionalClauses: z.array(z.string()).optional().default([]),
});

type TrustForm = z.infer<typeof trustFormSchema>;

export default function CreateTrust() {
  const router = useRouter();
  const [streamingUrl, setStreamingUrl] = useState<string | null>(null);
  const [documentText, setDocumentText] = useState("");
  const [finished, setFinished] = useState(false);

  const {
    register,
    control,
    handleSubmit,
    watch,
    formState: { errors },
  } = useForm<TrustForm>({
    resolver: zodResolver(trustFormSchema),
    defaultValues: {
      trustees: [{ firstName: "", lastName: "", address: "" }],
      beneficiaries: [{ firstName: "", lastName: "", allocation: 100, DOB: "" }],
    },
  });

  const trusteesArray = useFieldArray({ control, name: "trustees" });
  const beneficiariesArray = useFieldArray({ control, name: "beneficiaries" });

  const onSubmit = async (data: TrustForm) => {
    const res = await api.post("/trusts/generate", data, {
      responseType: "stream",
    });
    // We need a streaming endpoint. If backend is SSE at /trusts/generate, 
    // we might have to call a separate SSE reader. For simplicity:
    setStreamingUrl(`${process.env.NEXT_PUBLIC_API_BASE}/trusts/generate?client=1`);
    // Actually, you’d pass the form data in SSE – or set up a dedicated endpoint that emits SSE.
  };

  const handleStreamMessage = (chunk: string) => {
    setDocumentText((prev) => prev + chunk);
  };

  const handleStreamComplete = () => {
    setFinished(true);
    toast.success("Trust draft generated");
  };

  return (
    <div className="max-w-2xl mx-auto bg-white p-6 rounded-lg shadow-md space-y-6">
      <h1 className="text-2xl font-bold">Create a New Trust</h1>
      {!streamingUrl && (
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700">Trust Name</label>
            <input
              type="text"
              {...register("trustName")}
              className="border border-gray-300 rounded-md px-3 py-2 w-full"
            />
            {errors.trustName && (
              <p className="mt-1 text-xs text-red-500">{errors.trustName.message}</p>
            )}
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700">Type</label>
            <select {...register("type")} className="border border-gray-300 rounded-md px-3 py-2 w-full">
              <option value="REVOCABLE">Revocable</option>
              <option value="IRREVOCABLE">Irrevocable</option>
              <option value="SPECIAL_NEEDS">Special Needs</option>
              <option value="DYNASTY">Dynasty</option>
              <option value="MINOR">Minor</option>
            </select>
          </div>

          {/* Grantor fields */}
          <div className="space-y-2">
            <h2 className="font-semibold">Grantor</h2>
            <div>
              <label className="block text-sm font-medium text-gray-700">First Name</label>
              <input
                type="text"
                {...register("grantor.firstName")}
                className="border border-gray-300 rounded-md px-3 py-2 w-full"
              />
              {errors.grantor?.firstName && (
                <p className="mt-1 text-xs text-red-500">{errors.grantor.firstName.message}</p>
              )}
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700">Last Name</label>
              <input
                type="text"
                {...register("grantor.lastName")}
                className="border border-gray-300 rounded-md px-3 py-2 w-full"
              />
              {errors.grantor?.lastName && (
                <p className="mt-1 text-xs text-red-500">{errors.grantor.lastName.message}</p>
              )}
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700">Address</label>
              <input
                type="text"
                {...register("grantor.address")}
                className="border border-gray-300 rounded-md px-3 py-2 w-full"
              />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700">Date of Birth</label>
              <input
                type="date"
                {...register("grantor.DOB")}
                className="border border-gray-300 rounded-md px-3 py-2 w-full"
              />
            </div>
          </div>

          {/* Trustees (dynamic) */}
          <div className="space-y-2">
            <h2 className="font-semibold">Trustees</h2>
            {trusteesArray.fields.map((field, index) => (
              <div key={field.id} className="border border-gray-200 p-4 rounded-md space-y-2">
                <div className="flex justify-between items-center">
                  <span className="font-medium">Trustee {index + 1}</span>
                  <button
                    type="button"
                    onClick={() => trusteesArray.remove(index)}
                    className="text-red-500 hover:text-red-700"
                  >
                    Remove
                  </button>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700">First Name</label>
                  <input
                    {...register(`trustees.${index}.firstName` as const)}
                    className="border border-gray-300 rounded-md px-3 py-2 w-full"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700">Last Name</label>
                  <input
                    {...register(`trustees.${index}.lastName` as const)}
                    className="border border-gray-300 rounded-md px-3 py-2 w-full"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700">Address</label>
                  <input
                    {...register(`trustees.${index}.address` as const)}
                    className="border border-gray-300 rounded-md px-3 py-2 w-full"
                  />
                </div>
              </div>
            ))}
            <Button type="button" onClick={() => trusteesArray.append({ firstName: "", lastName: "", address: "" })}>
              Add Trustee
            </Button>
          </div>

          {/* Beneficiaries (dynamic) */}
          <div className="space-y-2">
            <h2 className="font-semibold">Beneficiaries</h2>
            {beneficiariesArray.fields.map((field, index) => (
              <div key={field.id} className="border border-gray-200 p-4 rounded-md space-y-2">
                <div className="flex justify-between items-center">
                  <span className="font-medium">Beneficiary {index + 1}</span>
                  <button
                    type="button"
                    onClick={() => beneficiariesArray.remove(index)}
                    className="text-red-500 hover:text-red-700"
                  >
                    Remove
                  </button>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700">First Name</label>
                  <input
                    {...register(`beneficiaries.${index}.firstName` as const)}
                    className="border border-gray-300 rounded-md px-3 py-2 w-full"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700">Last Name</label>
                  <input
                    {...register(`beneficiaries.${index}.lastName` as const)}
                    className="border border-gray-300 rounded-md px-3 py-2 w-full"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    Allocation (%) – must sum to 100%
                  </label>
                  <input
                    type="number"
                    {...register(`beneficiaries.${index}.allocation` as const, {
                      valueAsNumber: true,
                    })}
                    className="border border-gray-300 rounded-md px-3 py-2 w-full"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700">Date of Birth</label>
                  <input
                    type="date"
                    {...register(`beneficiaries.${index}.DOB` as const)}
                    className="border border-gray-300 rounded-md px-3 py-2 w-full"
                  />
                </div>
              </div>
            ))}
            <Button
              type="button"
              onClick={() =>
                beneficiariesArray.append({ firstName: "", lastName: "", allocation: 0, DOB: "" })
              }
            >
              Add Beneficiary
            </Button>
            {errors.beneficiaries && (
              <p className="mt-1 text-xs text-red-500">{errors.beneficiaries.message as string}</p>
            )}
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700">State (2-Letter)</label>
            <input
              type="text"
              maxLength={2}
              {...register("state")}
              className="border border-gray-300 rounded-md px-3 py-2 w-full"
            />
            {errors.state && (
              <p className="mt-1 text-xs text-red-500">{errors.state.message}</p>
            )}
          </div>

          {/* Additional Clauses and Assets can be added similarly – omitted for brevity */}
          <div>
            <label className="block text-sm font-medium text-gray-700">Additional Clause IDs (comma-separated)</label>
            <input
              type="text"
              {...register("additionalClauses")}
              placeholder="e.g. clause123,clause456"
              className="border border-gray-300 rounded-md px-3 py-2 w-full"
            />
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700">Assets (JSON‐encoded array)</label>
            <textarea
              {...register("assetsIncluded")}
              placeholder='e.g. [{"type":"Real Estate","description":"123 Main St"}]'
              className="border border-gray-300 rounded-md px-3 py-2 w-full h-24"
            />
          </div>

          <Button type="submit" variant="primary">
            Generate Draft
          </Button>
        </form>
      )}

      {/* SSE streaming results */}
      {streamingUrl && (
        <div className="space-y-4">
          <h2 className="text-lg font-semibold">Draft Preview</h2>
          <div className="border border-gray-200 p-4 rounded-md h-96 overflow-auto bg-gray-50 whitespace-pre-wrap">
            {documentText || <p>Generating…</p>}
          </div>
          {!finished && (
            <SSEReader
              url={streamingUrl}
              onMessage={handleStreamMessage}
              onComplete={handleStreamComplete}
              onError={(e) => toast.error("Error streaming draft")}
            />
          )}
          {finished && (
            <div className="flex space-x-2">
              <Button
                onClick={() => {
                  // Save final text into DB via PUT or PATCH endpoint, if needed.
                  api.patch(`/trusts/${documentText.id}`, { data: { text: documentText } });
                  router.push("/trusts");
                }}
                variant="primary"
              >
                Save & Return to List
              </Button>
            </div>
          )}
        </div>
      )}
    </div>
  );
}
Backend Note: Your /api/trusts/generate route is already set up for SSE (see Section 3). Frontend hits that with the JSON body. Ensure CORS/headers are correct to allow SSE.

5.10.3 src/pages/trusts/[id]/compliance.tsx
// frontend/src/pages/trusts/[id]/compliance.tsx
import { useRouter } from "next/router";
import useSWR from "swr";
import api from "@/lib/api";
import Button from "@/components/Button";
import { useState } from "react";
import Spinner from "@/components/Spinner";
import toast from "react-hot-toast";

type ComplianceResponse = {
  pass: boolean;
  issues: string[];
};

export default function TrustCompliance() {
  const router = useRouter();
  const { id } = router.query;
  const [loading, setLoading] = useState(false);
  const { data: compliance, error, mutate } = useSWR<ComplianceResponse>(
    () => (id ? `/trusts/compliance-check?id=${id}` : null),
    async () => {
      const res = await api.post("/trusts/compliance-check", { trustId: id });
      return res.data;
    }
  );

  if (!id) return <div>Loading…</div>;
  if (!compliance && !error) return <Spinner />;
  if (error) return <div>Error checking compliance</div>;

  return (
    <div className="max-w-lg mx-auto bg-white p-6 rounded-lg shadow-md space-y-4">
      <h1 className="text-xl font-semibold">Compliance Check</h1>
      <p>
        Result:{" "}
        <span className={compliance.pass ? "text-green-600" : "text-red-600"}>
          {compliance.pass ? "Pass" : "Fail"}
        </span>
      </p>
      {!compliance.pass && (
        <ul className="list-disc list-inside space-y-1">
          {compliance.issues.map((issue, i) => (
            <li key={i}>{issue}</li>
          ))}
        </ul>
      )}
      <Button onClick={() => router.push(`/trusts/${id}`)}>Back to Trust</Button>
    </div>
  );
}
5.10.4 src/pages/trusts/[id]/finalize.tsx
// frontend/src/pages/trusts/[id]/finalize.tsx
import { useRouter } from "next/router";
import { useState } from "react";
import Button from "@/components/Button";
import Spinner from "@/components/Spinner";
import api from "@/lib/api";
import toast from "react-hot-toast";

export default function TrustFinalize() {
  const router = useRouter();
  const { id } = router.query;
  const [loading, setLoading] = useState(false);

  const finalize = async () => {
    if (!id) return;
    setLoading(true);
    try {
      const res = await api.post(`/trusts/${id}/finalize`);
      // res.data.url is presigned URL to download
      window.open(res.data.url, "_blank");
      router.push("/trusts");
    } catch (err: any) {
      toast.error(err.response?.data?.error || "Error finalizing trust");
    } finally {
      setLoading(false);
    }
  };

  if (!id) return <Spinner />;
  return (
    <div className="max-w-md mx-auto bg-white p-6 rounded-lg shadow-md space-y-4">
      <h1 className="text-xl font-semibold">Finalize Trust</h1>
      <p>This will generate a PDF of your trust and store it in your Vault.</p>
      <Button onClick={finalize} disabled={loading}>
        {loading ? "Finalizing…" : "Generate PDF & Save"}
      </Button>
    </div>
  );
}
Backend Reminder: Your /api/trusts/:id/finalize route already:

Creates a PDF using pdf-lib,

Uploads to S3 under key trusts/{id}.pdf,

Saves status: FINALIZED & pdfS3Key in Prisma,

Creates a VaultFile record,

Returns { url: presignedUrl }.

5.11 Entity Builder
The Entity pages mirror the Trust pages: replace “trust” with “entity” and adjust form fields. For brevity, just note:

src/pages/entities/index.tsx: List all entities.

src/pages/entities/create.tsx: Use zod schema for entity form, call /entities/generate SSE.

src/pages/entities/[id]/compliance.tsx: POST to /entities/compliance-check, show JSON.

src/pages/entities/[id]/finalize.tsx: POST to /entities/:id/finalize, open returned URL.

Feel free to copy/paste the Trust code and swap out field names.

5.12 Legacy Letter Builder
Similarly:

src/pages/legacy-letter/index.tsx: List user’s letters with “Create New” button.

src/pages/legacy-letter/create.tsx: Collect tone, recipients (array of strings), and allow selecting attachments (pre‐uploaded Vault files). Then call /legacy-letter/generate SSE, stream back the letter.

src/pages/legacy-letter/[id]/compliance.tsx: POST to /legacy-letter/compliance-check.

src/pages/legacy-letter/[id]/finalize.tsx: POST to /legacy-letter/:id/finalize, open returned PDF link.

Just replicate the Trust flow, swapping endpoints and fields.

5.13 Vault: Folders & Files
5.13.1 src/hooks/useVaultTree.ts
// frontend/src/hooks/useVaultTree.ts
import useSWR from "swr";
import api from "@/lib/api";

export type Folder = {
  id: string;
  userId: string;
  parentId: string | null;
  name: string;
  path: string;
  createdAt: string;
  updatedAt: string;
};

export type VaultFile = {
  id: string;
  userId: string;
  folderId: string;
  fileName: string;
  fileType: string;
  size: number;
  s3Key: string;
  createdAt: string;
  updatedAt: string;
  isArchived: boolean;
};

export function useVaultFolders() {
  const { data, error, mutate } = useSWR<Folder[]>("/vault/folders", (url) =>
    api.get(url).then((res) => res.data)
  );
  return {
    folders: data,
    isLoading: !error && !data,
    isError: error,
    mutate,
  };
}

export function useFilesInFolder(folderId: string) {
  const { data, error, mutate } = useSWR<VaultFile[]>(
    () => (folderId ? `/vault/folders/${folderId}/files` : null),
    (url) => api.get(url).then((res) => res.data)
  );
  return {
    files: data,
    isLoading: !error && !data,
    isError: error,
    mutate,
  };
}
5.13.2 src/pages/vault/index.tsx
// frontend/src/pages/vault/index.tsx
import { useState } from "react";
import { useVaultFolders, useFilesInFolder } from "@/hooks/useVaultTree";
import Button from "@/components/Button";
import FileUploader from "@/components/FileUploader";
import Spinner from "@/components/Spinner";
import { useRouter } from "next/router";
import api from "@/lib/api";

export default function VaultPage() {
  const { folders, isLoading: foldersLoading, mutate: mutateFolders } = useVaultFolders();
  const [selectedFolder, setSelectedFolder] = useState<string | null>(null);
  const { files, isLoading: filesLoading, mutate: mutateFiles } = useFilesInFolder(selectedFolder || "");
  const router = useRouter();

  if (foldersLoading) return <Spinner />;

  // Build a simple tree view (flat list ordered by path, indent based on slash count)
  return (
    <div className="flex space-x-6">
      {/* Folders Pane */}
      <div className="w-1/3 bg-white p-4 rounded-lg shadow-md space-y-4">
        <div className="flex justify-between items-center mb-2">
          <h2 className="font-semibold">Folders</h2>
          <Button onClick={() => router.push("/vault/folder/new")}>New Folder</Button>
        </div>
        <ul className="space-y-1">
          {folders?.map((f) => {
            const depth = f.path.split("/").length - 1;
            return (
              <li
                key={f.id}
                onClick={() => setSelectedFolder(f.id)}
                className={`cursor-pointer pl-${depth * 4} ${
                  selectedFolder === f.id ? "font-semibold" : ""
                }`}
              >
                {f.name}
              </li>
            );
          })}
        </ul>
      </div>

      {/* Files Pane */}
      <div className="flex-1 bg-white p-4 rounded-lg shadow-md space-y-4">
        {selectedFolder ? (
          <>
            <div className="flex justify-between items-center">
              <h2 className="font-semibold">Files in {folders?.find((f) => f.id === selectedFolder)?.name}</h2>
              <FileUploader
                folderId={selectedFolder}
                onUploadComplete={() => {
                  mutateFiles();
                  mutateFolders();
                }}
              />
            </div>
            {filesLoading ? (
              <Spinner />
            ) : (
              <table className="w-full text-left">
                <thead>
                  <tr>
                    <th className="px-2 py-1">Name</th>
                    <th className="px-2 py-1">Type</th>
                    <th className="px-2 py-1">Size (KB)</th>
                    <th className="px-2 py-1">Actions</th>
                  </tr>
                </thead>
                <tbody>
                  {files?.map((file) => (
                    <tr key={file.id} className="hover:bg-gray-50">
                      <td className="px-2 py-1">{file.fileName}</td>
                      <td className="px-2 py-1">{file.fileType}</td>
                      <td className="px-2 py-1">{Math.ceil(file.size / 1024)}</td>
                      <td className="px-2 py-1 space-x-2">
                        <button
                          onClick={async () => {
                            const res = await api.get(`/vault/files/${file.id}/download-url`);
                            window.open(res.data.url, "_blank");
                          }}
                          className="text-blue-600 hover:underline"
                        >
                          Download
                        </button>
                        <button
                          onClick={async () => {
                            await api.patch(`/vault/files/${file.id}`, { fileName: `${file.fileName}_archived` });
                            mutateFiles();
                          }}
                          className="text-red-600 hover:underline"
                        >
                          Archive
                        </button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            )}
          </>
        ) : (
          <p>Select a folder to see its files.</p>
        )}
      </div>
    </div>
  );
}
5.13.3 src/pages/vault/folder/[folderId].tsx
Handle moving/renaming a folder:

// frontend/src/pages/vault/folder/[folderId].tsx
import { useRouter } from "next/router";
import { useForm } from "react-hook-form";
import Button from "@/components/Button";
import Input from "@/components/Input";
import api from "@/lib/api";
import { useState, useEffect } from "react";
import Spinner from "@/components/Spinner";
import { useVaultFolders } from "@/hooks/useVaultTree";
import toast from "react-hot-toast";

type FolderForm = {
  name: string;
  parentId: string | null;
};

export default function FolderEdit() {
  const router = useRouter();
  const { folderId } = router.query as { folderId: string };
  const { folders, isLoading } = useVaultFolders();
  const [loading, setLoading] = useState(false);
  const [initial, setInitial] = useState<FolderForm | null>(null);

  const { register, handleSubmit, reset } = useForm<FolderForm>();

  useEffect(() => {
    if (folderId && folders) {
      const folder = folders.find((f) => f.id === folderId);
      if (folder) {
        // parentId could be null or another folder
        const parentId = folder.parentId || null;
        setInitial({ name: folder.name, parentId });
        reset({ name: folder.name, parentId });
      }
    }
  }, [folderId, folders, reset]);

  const onSubmit = async (data: FolderForm) => {
    setLoading(true);
    try {
      await api.patch(`/vault/folders/${folderId}`, data);
      toast.success("Folder updated");
      router.push("/vault");
    } catch (err: any) {
      toast.error(err.response?.data?.error || "Error updating folder");
    } finally {
      setLoading(false);
    }
  };

  if (!folderId || isLoading || !initial) return <Spinner />;
  return (
    <div className="max-w-md mx-auto bg-white p-6 rounded-lg shadow-md space-y-4">
      <h1 className="text-xl font-semibold">Edit Folder</h1>
      <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
        <div>
          <label className="block text-sm font-medium text-gray-700">Folder Name</label>
          <Input {...register("name")} />
        </div>
        <div>
          <label className="block text-sm font-medium text-gray-700">Parent Folder</label>
          <select {...register("parentId")} className="border border-gray-300 rounded-md px-3 py-2 w-full">
            <option value="">— None (root) —</option>
            {folders
              .filter((f) => f.id !== folderId)
              .map((f) => (
                <option key={f.id} value={f.id}>
                  {f.path}
                </option>
              ))}
          </select>
        </div>
        <div className="flex space-x-2">
          <Button type="submit" variant="primary" disabled={loading}>
            {loading ? "Saving…" : "Save Changes"}
          </Button>
          <Button
            variant="danger"
            onClick={async () => {
              if (confirm("Delete this folder and all its contents?")) {
                await api.delete(`/vault/folders/${folderId}`);
                router.push("/vault");
              }
            }}
          >
            Delete Folder
          </Button>
        </div>
      </form>
    </div>
  );
}
5.13.4 src/pages/vault/emergency.tsx
// frontend/src/pages/vault/emergency.tsx
import { useForm } from "react-hook-form";
import Input from "@/components/Input";
import Button from "@/components/Button";
import api from "@/lib/api";
import { useState, useEffect } from "react";
import toast from "react-hot-toast";
import { useVaultFolders } from "@/hooks/useVaultTree";

type EmergencyForm = {
  folderId: string;
  granteeEmail: string;
  expiresAt: string;
};

export default function EmergencyAccessPage() {
  const { folders, mutate: mutateFolders } = useVaultFolders();
  const [loading, setLoading] = useState(false);
  const { register, handleSubmit } = useForm<EmergencyForm>();

  const onSubmit = async (data: EmergencyForm) => {
    setLoading(true);
    try {
      await api.post("/vault/emergency", data);
      toast.success("Emergency access granted");
    } catch (err: any) {
      toast.error(err.response?.data?.error || "Error granting access");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-md mx-auto bg-white p-6 rounded-lg shadow-md space-y-4">
      <h1 className="text-xl font-semibold">Grant Emergency Access</h1>
      <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
        <div>
          <label className="block text-sm font-medium text-gray-700">Folder</label>
          <select {...register("folderId")} className="border border-gray-300 rounded-md px-3 py-2 w-full">
            <option value="">— Select Folder —</option>
            {folders?.map((f) => (
              <option key={f.id} value={f.id}>
                {f.path}
              </option>
            ))}
          </select>
        </div>
        <div>
          <label className="block text-sm font-medium text-gray-700">Grantee’s Email</label>
          <Input type="email" {...register("granteeEmail")} />
        </div>
        <div>
          <label className="block text-sm font-medium text-gray-700">Expires At</label>
          <Input type="datetime-local" {...register("expiresAt")} />
        </div>
        <Button type="submit" variant="primary" disabled={loading}>
          {loading ? "Granting…" : "Grant Access"}
        </Button>
      </form>
    </div>
  );
}
Backend Reminder: The endpoint /api/vault/emergency (Section 3) already creates an EmergencyAccess record, sends an email, and publishes a code. The frontend simply consumes it.

5.14 Notifications
5.14.1 src/pages/notifications.tsx
// frontend/src/pages/notifications.tsx
import useSWR from "swr";
import api from "@/lib/api";
import { useState } from "react";
import Button from "@/components/Button";
import Spinner from "@/components/Spinner";
import toast from "react-hot-toast";

type Notification = {
  id: string;
  type: string;
  content: { message: string };
  read: boolean;
  createdAt: string;
};

export default function NotificationsPage() {
  const { data, error, mutate } = useSWR<Notification[]>("/users/notifications", (url) =>
    api.get(url).then((res) => res.data)
  );
  const [marking, setMarking] = useState<string | null>(null);

  if (!data) return <Spinner />;
  if (error) return <div>Error loading notifications</div>;

  const markRead = async (id: string) => {
    setMarking(id);
    try {
      await api.patch(`/users/notifications/${id}/mark-read`);
      mutate();
    } catch (err: any) {
      toast.error(err.response?.data?.error || "Error marking read");
    } finally {
      setMarking(null);
    }
  };

  return (
    <div className="space-y-4">
      <h1 className="text-2xl font-bold">Notifications</h1>
      {data.length === 0 ? (
        <p>No notifications yet.</p>
      ) : (
        <ul className="space-y-2">
          {data.map((n) => (
            <li
              key={n.id}
              className={`p-4 rounded-lg shadow-md flex justify-between items-center ${
                n.read ? "bg-gray-100" : "bg-white"
              }`}
            >
              <div>
                <p className="font-medium">{n.content.message}</p>
                <p className="text-xs text-gray-500">{new Date(n.createdAt).toLocaleString()}</p>
              </div>
              {!n.read && (
                <Button
                  onClick={() => markRead(n.id)}
                  variant="secondary"
                  disabled={marking === n.id}
                >
                  {marking === n.id ? "Marking…" : "Mark Read"}
                </Button>
              )}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
5.15 Check‐In Scheduler (User Check‐Ins)
We need a page to let users create/edit their scheduled check‐ins.

5.15.1 src/pages/checkins.tsx
// frontend/src/pages/checkins.tsx
import useSWR from "swr";
import api from "@/lib/api";
import { useForm } from "react-hook-form";
import Spinner from "@/components/Spinner";
import Button from "@/components/Button";
import toast from "react-hot-toast";
import { useState } from "react";

type CheckIn = {
  id: string;
  frequency: "DAILY" | "WEEKLY" | "MONTHLY";
  nextDate: string;
};

type CheckInForm = {
  frequency: "DAILY" | "WEEKLY" | "MONTHLY";
  nextDate: string;
};

export default function CheckInsPage() {
  const { data, error, mutate } = useSWR<CheckIn[]>("/users/checkins", (url) =>
    api.get(url).then((res) => res.data)
  );
  const [loading, setLoading] = useState(false);
  const { register, handleSubmit, reset } = useForm<CheckInForm>();

  const onSubmit = async (data: CheckInForm) => {
    setLoading(true);
    try {
      await api.post("/users/checkins", data);
      toast.success("Check-In scheduled");
      mutate();
      reset();
    } catch (err: any) {
      toast.error(err.response?.data?.error || "Error creating check-in");
    } finally {
      setLoading(false);
    }
  };

  const updateCheckIn = async (id: string, freq: string, nextDate: string) => {
    try {
      await api.patch(`/users/checkins/${id}`, { frequency: freq, nextDate });
      toast.success("Check-In updated");
      mutate();
    } catch (err: any) {
      toast.error(err.response?.data?.error || "Error updating");
    }
  };

  const deleteCheckIn = async (id: string) => {
    try {
      await api.delete(`/users/checkins/${id}`);
      toast.success("Check-In deleted");
      mutate();
    } catch (err: any) {
      toast.error(err.response?.data?.error || "Error deleting");
    }
  };

  if (!data) return <Spinner />;
  if (error) return <div>Error loading check-ins</div>;

  return (
    <div className="space-y-6 max-w-lg mx-auto">
      <div className="bg-white p-6 rounded-lg shadow-md">
        <h1 className="text-xl font-semibold mb-4">Schedule a Check‐In</h1>
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700">Frequency</label>
            <select {...register("frequency")} className="border border-gray-300 rounded-md px-3 py-2 w-full">
              <option value="DAILY">Daily</option>
              <option value="WEEKLY">Weekly</option>
              <option value="MONTHLY">Monthly</option>
            </select>
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700">Next Date</label>
            <input type="date" {...register("nextDate")} className="border border-gray-300 rounded-md px-3 py-2 w-full" />
          </div>
          <Button type="submit" variant="primary" disabled={loading}>
            {loading ? "Scheduling…" : "Schedule"}
          </Button>
        </form>
      </div>

      <div className="bg-white p-6 rounded-lg shadow-md space-y-4">
        <h2 className="text-lg font-semibold">Your Check‐Ins</h2>
        {data.length === 0 ? (
          <p>No check-ins scheduled.</p>
        ) : (
          <ul className="space-y-2">
            {data.map((ci) => (
              <li key={ci.id} className="border border-gray-200 p-4 rounded-lg flex justify-between items-center">
                <div>
                  <p>
                    <strong>Frequency:</strong> {ci.frequency}
                  </p>
                  <p>
                    <strong>Next:</strong> {new Date(ci.nextDate).toLocaleDateString()}
                  </p>
                </div>
                <div className="space-x-2">
                  <Button
                    onClick={() => updateCheckIn(ci.id, ci.frequency, ci.nextDate)}
                    variant="secondary"
                  >
                    Update
                  </Button>
                  <Button onClick={() => deleteCheckIn(ci.id)} variant="danger">
                    Delete
                  </Button>
                </div>
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
}
Backend Reminder: The endpoints /users/checkins (GET, POST, PATCH, DELETE) are fully implemented (Section 2).

5.16 Search
We have a backend /api/search?q=… endpoint. Create a simple search bar (e.g., in Navbar) and a results page.

5.16.1 src/components/SearchBar.tsx
// frontend/src/components/SearchBar.tsx
import { useState } from "react";
import { useRouter } from "next/router";

export default function SearchBar() {
  const [q, setQ] = useState("");
  const router = useRouter();

  const onSearch = (e: React.FormEvent) => {
    e.preventDefault();
    if (q.trim()) {
      router.push(`/search?query=${encodeURIComponent(q)}`);
    }
  };

  return (
    <form onSubmit={onSearch} className="flex">
      <input
        type="text"
        value={q}
        onChange={(e) => setQ(e.target.value)}
        placeholder="Search …"
        className="border border-gray-300 rounded-l-md px-3 py-2 w-64 focus:ring-blue-500 focus:border-blue-500"
      />
      <button
        type="submit"
        className="bg-blue-600 text-white px-4 rounded-r-md hover:bg-blue-700"
      >
        Search
      </button>
    </form>
  );
}
Include <SearchBar /> in your Navbar if desired.
5.16.2 src/pages/search.tsx
// frontend/src/pages/search.tsx
import { useRouter } from "next/router";
import useSWR from "swr";
import api from "@/lib/api";
import Spinner from "@/components/Spinner";
import Link from "next/link";

type Result = {
  id: string;
  title: string;
  type: "Trust" | "Entity" | "VaultFile";
};

export default function SearchPage() {
  const router = useRouter();
  const { query } = router.query as { query: string };
  const { data, error } = useSWR<Result[]>(
    () => (query ? `/search?q=${encodeURIComponent(query)}` : null),
    (url) => api.get(url).then((res) => res.data.results)
  );

  if (!data && !error && query) return <Spinner />;
  if (error) return <div>Error searching</div>;

  return (
    <div className="max-w-2xl mx-auto bg-white p-6 rounded-lg shadow-md space-y-4">
      <h1 className="text-xl font-semibold">Search Results for "{query}"</h1>
      {data?.length === 0 ? (
        <p>No results found.</p>
      ) : (
        <ul className="space-y-2">
          {data?.map((r) => (
            <li key={`${r.type}-${r.id}`} className="p-4 border border-gray-200 rounded-lg hover:bg-gray-50">
              <Link href={`/${r.type.toLowerCase()}s/${r.id}`}>
                <a className="text-blue-600 hover:underline">
                  {r.type}: {r.title}
                </a>
              </Link>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
Backend Reminder: The backend /api/search already returns an object { results: [ { id, title, type } ] }.

5.17 Notifications Preferences
Allow users to enable/disable certain notification types.

5.17.1 src/pages/settings/billing.tsx
// frontend/src/pages/settings/billing.tsx
import { useState, useEffect } from "react";
import api from "@/lib/api";
import Button from "@/components/Button";
import Spinner from "@/components/Spinner";
import toast from "react-hot-toast";

type Pref = {
  type: string;
  enabled: boolean;
};

export default function BillingSettings() {
  const [prefs, setPrefs] = useState<Pref[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    // Load default preferences if not set
    api.get("/users/notifications").then((res) => {
      // This endpoint returns notifications, not preferences. 
      // Instead, call GET /users/notification-prefs if you add that route.
    });
  }, []);

  // For simplicity, assume each type: ["VaultAlert", "RegulatoryUpdate", "CheckInReminder", "ComplianceIssue"]
  const types = ["VaultAlert", "RegulatoryUpdate", "CheckInReminder", "ComplianceIssue"];

  const togglePref = async (type: string, enabled: boolean) => {
    setLoading(true);
    try {
      await api.patch("/users/notifications", { type, enabled });
      setPrefs((p) => p.map((x) => (x.type === type ? { ...x, enabled } : x)));
    } catch (err: any) {
      toast.error("Error updating preferences");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-md mx-auto bg-white p-6 rounded-lg shadow-md space-y-4">
      <h1 className="text-xl font-semibold">Notification Preferences</h1>
      {loading && <Spinner />}
      {types.map((type) => (
        <div key={type} className="flex justify-between items-center">
          <span>{type}</span>
          <input
            type="checkbox"
            checked={prefs.find((p) => p.type === type)?.enabled || false}
            onChange={(e) => togglePref(type, e.target.checked)}
            disabled={loading}
          />
        </div>
      ))}
    </div>
  );
}
Backend Reminder: You already implemented PATCH /api/users/notifications to upsert preferences.

5.18 Admin Metrics & Audit Logs
Only accessible if session.user.role === "ADMIN".

5.18.1 src/pages/admin/metrics/users.tsx and others
Essentially copy your dashboard metrics pages, but use /admin/metrics/users, /admin/metrics/subscriptions, /admin/metrics/vault, /admin/metrics/api-usage, and a new page:

// frontend/src/pages/admin/audit-logs.tsx
import useSWR from "swr";
import api from "@/lib/api";
import Spinner from "@/components/Spinner";
import { useState } from "react";

export default function AuditLogsPage() {
  const [page, setPage] = useState(1);
  const [filters, setFilters] = useState<{ resourceType?: string; resourceId?: string; userId?: string; action?: string }>({});
  const limit = 50;

  const queryParams = new URLSearchParams({ page: page.toString(), limit: limit.toString(), ...filters } as any);
  const { data, error } = useSWR<any[]>(`/admin/audit-logs?${queryParams.toString()}`, (url) =>
    api.get(url).then((res) => res.data)
  );

  if (!data) return <Spinner />;
  if (error) return <div>Error loading audit logs</div>;

  return (
    <div className="space-y-4">
      <h1 className="text-2xl font-bold">Audit Logs</h1>
      <table className="w-full text-left">
        <thead>
          <tr>
            <th>ID</th>
            <th>User</th>
            <th>Resource</th>
            <th>Action</th>
            <th>Timestamp</th>
          </tr>
        </thead>
        <tbody>
          {data.map((log) => (
            <tr key={log.id} className="border-t border-gray-200">
              <td className="px-2 py-1">{log.id}</td>
              <td className="px-2 py-1">{log.user.email}</td>
              <td className="px-2 py-1">
                {log.resourceType} ({log.resourceId})
              </td>
              <td className="px-2 py-1">{log.action}</td>
              <td className="px-2 py-1">{new Date(log.timestamp).toLocaleString()}</td>
            </tr>
          ))}
        </tbody>
      </table>
      <div className="flex justify-between mt-4">
        <button
          disabled={page === 1}
          onClick={() => setPage((p) => p - 1)}
          className="px-4 py-2 bg-gray-200 rounded-md hover:bg-gray-300 disabled:opacity-50"
        >
          Previous
        </button>
        <button
          onClick={() => setPage((p) => p + 1)}
          className="px-4 py-2 bg-gray-200 rounded-md hover:bg-gray-300"
        >
          Next
        </button>
      </div>
    </div>
  );
}
5.19 Final Checks & Edge Cases
Error Handling & Toasts: Everywhere we call api.*, wrap in try/catch. Use react-hot-toast to display errors or success.

Loading States: Use Spinner for any data‐fetching page. Disable buttons when loading.

Protected Routes: Layout already redirects unauthenticated users to /login. For admin pages, check session.user.role and show “Forbidden” or redirect if not admin.

Rate Limits: Backend’s rate limiting middleware will reject too many requests; show a toast such as “Too many requests, please wait.”

Locale/Translations: We stored translations in the DB (Section 1). To fully localize, you could fetch /translations?locale=en&module=whatever via an API and wrap strings in a useTranslation hook. (Out of scope unless you explicitly need it.)

2FA Flows: Already covered in Security page. Ensure login page handles TOTP if required — e.g., after credentials, redirect to a page that enters TOTP. This requires modifying your /auth/login flow.

SSE Streaming: Test that the SSE endpoints send data with correct Content-Type: text/event-stream headers. Frontend’s SSEReader should pick up each chunk.

File Upload/Download: Confirm that S3 CORS settings allow PUT from your frontend origin.

Date/Time: For check‐in, the backend expects ISO dates. The <input type="date"> provides YYYY-MM-DD. If you need time, use <input type="datetime-local">.

Deployment Config: In production, set NEXT_PUBLIC_API_BASE=https://api.yourdomain.com/api and ensure HTTPS, correct CORS, and environment variables for NextAuth secrets, Stripe, Twilio, OpenAI, etc.

5.20 Testing the Full Flow
Register a User → Confirm new record in User table.

Login → Session established, JWT stored via NextAuth.

Profile → Edit name/locale, confirm changes in DB.

Enable 2FA → Generate secret, scan QR, verify TOTP, confirm twoFAEnabled = true in DB.

Schedule Check‐In → New UserCheckIn record. In one day/week/month, the job runs and creates a notification.

Subscription → Select a plan in UI → For paid plan, redirects to Stripe Checkout → On success, /subscriptions/webhook marks user’s subscription in DB. Free plan simply sets UserSubscription.status = ACTIVE. UI shows storage usage.

Vault → Create folders, upload files → Records in VaultFolder/VaultFile → Download files via presigned URLs.

Emergency Access → Grant to another user → That user visits /vault/emergency/{code} → Sees file list, can download.

Trust Flow → Create a Trust draft → SSE streams GPT output → Save → Run Compliance Check → Finalize → PDF saved to S3 and Vault → AuditLog entries recorded.

Entity Flow → Same as Trust but for formation docs.

Legacy Letter → Create letter → SSE streams GPT output → Save → Check compliance → Finalize → PDF saved to S3 and Vault.

Dashboard → View Protection Score, Metrics, Charts.

Admin → As an admin user, view user growth, churn, vault usage, API usage, and audit logs.

Congratulations!
At this point, all backend functionality (Sections 1–4) has a corresponding frontend implementation (Section 5). You can run:

Backend:

cd backend
npm install
npm run migrate     # run Prisma migrations
npm run dev         # start Express server on port 4000
Frontend:

cd frontend
npm install
npm run dev         # start Next.js on port 3000
Visit http://localhost:3000 → register/login → work through each feature. If any backend endpoints are missing (e.g., GET /trusts, GET /entities, GET /legacy-letter), implement them analogously to the other listing routes.



==== Legacy Pro V6 Adjustments ====

1. Add Incident Model & Fraud‐Monitor Job
1.1. backend/prisma/schema.prisma
Add the Incident model at the bottom of the existing schema.

diff
@@
   model Translation {
     id       String @id @default(uuid())
     localeId String
     module   String
     key      String
     text     String

     locale   Locale @relation(fields: [localeId], references: [id])
     @@unique([localeId, module, key])
   }

+  /// ——————————————————————————————
+  /// INCIDENTS (real‐time fraud detection)
+  model Incident {
+    id         String    @id @default(uuid())
+    userId     String?   
+    type       String
+    details    Json
+    resolved   Boolean   @default(false)
+    createdAt  DateTime  @default(now())
+
+    user       User?     @relation(fields: [userId], references: [id])
+  }
+
+  enum IncidentType {
+    FRAUD_SCORE_HIGH
+    SUSPICIOUS_LOGIN
+    OTHER
+  }
Note: After saving, run:

cd backend
npx prisma migrate dev --name add_incident_model
to generate the new migration.

1.2. backend/src/jobs/fraudMonitor.ts
Create a new job that polls an external fraud‐scoring API (e.g., Sift or Arkose Labs). Whenever a high‐risk score appears, it creates an Incident in the database and sends a notification to Admin users.

// File: backend/src/jobs/fraudMonitor.ts

import { PrismaClient } from "@prisma/client";
import fetch from "node-fetch";
import { sendPushNotificationToAdmins } from "../utils/notifications";
import { differenceInMinutes } from "date-fns";

const prisma = new PrismaClient();

// Polling interval in minutes
const POLL_INTERVAL = 5;

async function checkForFraud() {
  try {
    // 1. Fetch users with recent logins (e.g., last hour) to check their fraud scores
    const oneHourAgo = new Date(Date.now() - 1000 * 60 * 60);
    const recentLogins = await prisma.loginLog.findMany({
      where: { createdAt: { gte: oneHourAgo } },
      include: { user: true },
    });

    for (const login of recentLogins) {
      const { user } = login;
      // Call external fraud‐scoring API (stub URL and payload)
      const response = await fetch("https://fraud-api.example.com/score", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${process.env.FRAUD_API_KEY}`,
        },
        body: JSON.stringify({
          userId: user.id,
          ip: login.ipAddress,
          timestamp: login.createdAt,
        }),
      });

      if (!response.ok) {
        console.warn(`Fraud API returned ${response.status}`);
        continue;
      }

      const { score } = await response.json();
      // If score is above threshold, create an Incident
      if (score >= 80) {
        // Check if a recent unresolved incident already exists
        const recentIncident = await prisma.incident.findFirst({
          where: {
            userId: user.id,
            type: "FRAUD_SCORE_HIGH",
            resolved: false,
            createdAt: {
              gte: new Date(Date.now() - 1000 * 60 * 30), // last 30 minutes
            },
          },
        });

        if (!recentIncident) {
          const incident = await prisma.incident.create({
            data: {
              userId: user.id,
              type: "FRAUD_SCORE_HIGH",
              details: { score, ip: login.ipAddress, timestamp: login.createdAt },
            },
          });

          // Create a Notification for Admin users
          const adminUsers = await prisma.user.findMany({
            where: { role: "ADMIN" },
            select: { id: true },
          });

          for (const admin of adminUsers) {
            await prisma.notification.create({
              data: {
                userId: admin.id,
                type: "IncidentAlert",
                title: "New Fraud Incident",
                message: `User ${user.email} triggered a high fraud score of ${score}.`,
                link: `/admin/incidents`,
              },
            });
          }

          // Fire off push notifications
          await sendPushNotificationToAdmins({
            title: "Fraud Alert",
            body: `High fraud risk detected for ${user.email}.`,
            data: { incidentId: incident.id },
          });
        }
      }
    }
  } catch (error) {
    console.error("Error in fraudMonitor job:", error);
  }
}

// Schedule the job every POLL_INTERVAL minutes
setInterval(checkForFraud, POLL_INTERVAL * 60 * 1000);

// Optionally kick off immediately on startup
checkForFraud().catch(console.error);
Explanation of key parts:

We look up any LoginLog entries (assuming you already have a loginLog model) from the last hour.

We POST to a stubbed “fraud‐API” endpoint, parse a returned score.

If score ≥ 80, and no recent unresolved incident exists, we create an Incident and notify admins.

sendPushNotificationToAdmins is assumed to exist in backend/src/utils/notifications.ts (adjust as needed).

1.3. backend/src/routes/admin/incidents.ts
Create a new route to fetch and resolve incidents from the Admin side.

// File: backend/src/routes/admin/incidents.ts

import { Router } from "express";
import { PrismaClient } from "@prisma/client";
import { requireAdmin } from "../../middleware/auth";

const prisma = new PrismaClient();
const router = Router();

// GET /api/admin/incidents
router.get("/", requireAdmin, async (req, res, next) => {
  try {
    const incidents = await prisma.incident.findMany({
      orderBy: { createdAt: "desc" },
      include: { user: { select: { id: true, email: true } } },
    });
    res.json({ data: incidents });
  } catch (err) {
    next(err);
  }
});

// POST /api/admin/incidents/:id/resolve
router.post("/:id/resolve", requireAdmin, async (req, res, next) => {
  try {
    const { id } = req.params;
    const updated = await prisma.incident.update({
      where: { id },
      data: { resolved: true },
    });
    res.json({ data: updated });
  } catch (err) {
    next(err);
  }
});

export default router;
Integration: In your main server.js, register:

import incidentsRouter from "./routes/admin/incidents";
// ...
app.use("/api/admin/incidents", incidentsRouter);
1.4. frontend/pages/admin/incidents.tsx
Add a new Admin page to list, view, and resolve incidents.

// File: frontend/pages/admin/incidents.tsx

import { useEffect, useState } from "react";
import Layout from "@/components/layout/AdminLayout";
import axios from "axios";
import { Incident } from "@prisma/client";
import { toast } from "react-toastify";

interface IncidentWithUser extends Incident {
  user: { id: string; email: string } | null;
}

export default function IncidentsPage() {
  const [incidents, setIncidents] = useState<IncidentWithUser[]>([]);
  const [loading, setLoading] = useState(true);

  async function fetchIncidents() {
    try {
      const res = await axios.get("/api/admin/incidents");
      setIncidents(res.data.data);
    } catch (err) {
      console.error(err);
      toast.error("Failed to load incidents.");
    } finally {
      setLoading(false);
    }
  }

  async function resolveIncident(id: string) {
    try {
      await axios.post(`/api/admin/incidents/${id}/resolve`);
      toast.success("Incident marked resolved.");
      setIncidents((prev) => prev.filter((inc) => inc.id !== id));
    } catch (err) {
      console.error(err);
      toast.error("Could not resolve incident.");
    }
  }

  useEffect(() => {
    fetchIncidents();
  }, []);

  return (
    <Layout title="Fraud Incidents">
      <h1 className="text-2xl font-semibold mb-4">Fraud Incidents</h1>
      {loading ? (
        <p>Loading...</p>
      ) : incidents.length === 0 ? (
        <p>No active incidents.</p>
      ) : (
        <div className="space-y-4">
          {incidents.map((inc) => (
            <div key={inc.id} className="p-4 border rounded-md flex justify-between">
              <div>
                <p>
                  <strong>User:</strong> {inc.user?.email || "Unknown"}
                </p>
                <p>
                  <strong>Type:</strong> {inc.type}
                </p>
                <p>
                  <strong>Details:</strong> {JSON.stringify(inc.details)}
                </p>
                <p>
                  <strong>Created:</strong> {new Date(inc.createdAt).toLocaleString()}
                </p>
              </div>
              <button
                onClick={() => resolveIncident(inc.id)}
                className="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600"
              >
                Resolve
              </button>
            </div>
          ))}
        </div>
      )}
    </Layout>
  );
}
Note: AdminLayout should include the sidebar/navigation for Admin pages. If you don’t have it yet, wrap this with your existing admin layout component.

2. Yodlee Integration Endpoints (Stubs)
These files go under backend/src/routes/financial/yodlee/. If you plan to fully integrate later, replace the stub logic with real API calls; for now, this ensures the routes exist and return a placeholder.

2.1. backend/src/routes/financial/yodlee/create-session.ts
// File: backend/src/routes/financial/yodlee/create-session.ts

import { Router } from "express";
import { requireAuth } from "../../../middleware/auth";

const router = Router();

// POST /api/financial/yodlee/create-session
router.post("/", requireAuth, async (req, res, next) => {
  try {
    // TODO: Replace with actual Yodlee API call to create a new session
    // Example placeholder response:
    const placeholderSession = {
      cobSession: "abcdef1234567890",
      userSession: "user-session-xyz",
      createdAt: new Date(),
    };
    res.json({ data: placeholderSession });
  } catch (err) {
    next(err);
  }
});

export default router;
2.2. backend/src/routes/financial/yodlee/accounts.ts
// File: backend/src/routes/financial/yodlee/accounts.ts

import { Router } from "express";
import { requireAuth } from "../../../middleware/auth";

const router = Router();

// GET /api/financial/yodlee/accounts
router.get("/", requireAuth, async (req, res, next) => {
  try {
    // TODO: Replace with actual call to Yodlee to fetch accounts
    const placeholderAccounts = [
      { id: "acct1", name: "Checking Account", balance: 1234.56 },
      { id: "acct2", name: "Savings Account", balance: 7890.12 },
    ];
    res.json({ data: placeholderAccounts });
  } catch (err) {
    next(err);
  }
});

export default router;
2.3. Register Yodlee Routes in backend/src/routes/financial/index.ts
diff
@@
 import express from "express";
 import plaidRouter from "./plaid";
+import yodleeCreateSessionRouter from "./yodlee/create-session";
+import yodleeAccountsRouter from "./yodlee/accounts";

 const router = express.Router();

 router.use("/plaid", plaidRouter);
+router.use("/yodlee/create-session", yodleeCreateSessionRouter);
+router.use("/yodlee/accounts", yodleeAccountsRouter);

 export default router;
3. Add PWA/Web‐Push Service Worker
We’ll add a basic Firebase Messaging service worker. This file must live at the root of the public/ directory so that it’s served from /firebase-messaging-sw.js.

3.1. public/firebase-messaging-sw.js
// File: public/firebase-messaging-sw.js

// Import scripts required by Firebase
importScripts("https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js");
importScripts("https://www.gstatic.com/firebasejs/9.0.0/firebase-messaging-compat.js");

// Initialize the Firebase app in the service worker by passing in your config.
// (Make sure to replace the config object with your actual Firebase project credentials.)
firebase.initializeApp({
  apiKey: "YOUR_FIREBASE_API_KEY",
  authDomain: "YOUR_FIREBASE_AUTH_DOMAIN",
  projectId: "YOUR_FIREBASE_PROJECT_ID",
  storageBucket: "YOUR_FIREBASE_STORAGE_BUCKET",
  messagingSenderId: "YOUR_FIREBASE_SENDER_ID",
  appId: "YOUR_FIREBASE_APP_ID",
});

const messaging = firebase.messaging();

// Handle background messages
messaging.onBackgroundMessage((payload) => {
  console.log("[firebase-messaging-sw.js] Received background message ", payload);
  const { title, body } = payload.notification || {};
  const notificationOptions = {
    body,
    // You can add icon or other options here
  };

  if (title) {
    self.registration.showNotification(title, notificationOptions);
  }
});
Instructions to integrate:

Ensure your Firebase config in frontend/src/firebaseConfig.ts matches the service worker’s config.

In your Next.js _document.tsx or in a custom hook, request permission and register:

if ("serviceWorker" in navigator) {
  navigator.serviceWorker
    .register("/firebase-messaging-sw.js")
    .then((registration) => {
      console.log("Service Worker registered:", registration);
      // Initialize Firebase messaging with this registration
      import("firebase/messaging").then((firebaseMessaging) => {
        const messaging = firebaseMessaging.getMessaging();
        messaging.useServiceWorker(registration);
        // Now you can request and handle tokens in the app
      });
    })
    .catch((err) => console.error("SW registration failed:", err));
}
4. Integrate DOMPurify for XSS Protection
Anywhere the app renders HTML returned from GPT (e.g., TrustBuilder draft preview or AdvisorChat streaming), we must sanitize it with DOMPurify. Below is an example in the GPT output display component. You can follow the same pattern wherever untrusted HTML is rendered.

4.1. Install DOMPurify
cd frontend
npm install dompurify
# or
yarn add dompurify
4.2. Example: frontend/components/trust-builder/DraftPreview.tsx
Adjust the component that shows the raw HTML draft returned by GPT. We’ll import DOMPurify and run purify() before setting innerHTML.

// File: frontend/components/trust-builder/DraftPreview.tsx

import React, { useEffect, useRef } from "react";
import DOMPurify from "dompurify";

interface DraftPreviewProps {
  htmlContent: string;
}

export default function DraftPreview({ htmlContent }: DraftPreviewProps) {
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (containerRef.current) {
      // Sanitize the incoming HTML
      const cleanHtml = DOMPurify.sanitize(htmlContent, {
        USE_PROFILES: { html: true },
      });
      containerRef.current.innerHTML = cleanHtml;
    }
  }, [htmlContent]);

  return (
    <div
      ref={containerRef}
      className="prose max-w-none bg-white p-4 rounded-md shadow-sm"
    />
  );
}
Repeat this pattern in:

frontend/components/ai-advisor/ChatBubble.tsx (if rendering HTML messages)

frontend/components/legacy-letter/DraftEditor.tsx

Any other place where GPT returns HTML.

5. Add Markdown API Documentation
Create a new file that summarizes all endpoints in Markdown format. You can expand this later, but here is a skeleton with the most critical routes.

5.1. docs/api.md
# Legacy Pro API Documentation

> All endpoints live under `/api` and return JSON by default unless otherwise noted.

---

## Authentication & Users

### `POST /api/auth/register`
- **Description:** Create a new user account.
- **Body:**
  ```json
  {
    "email": "string",
    "password": "string",
    "name": "string"
  }
Response:

{ "data": { "id": "string", "email": "string", "name": "string" } }
POST /api/auth/login
Description: Log in user, returns a session cookie.

Body:

{
  "email": "string",
  "password": "string"
}
Response:

{ "data": { "user": { "id": "string", "email": "string", "role": "USER" } } }
POST /api/auth/logout
Description: Logs out current user.

Response:

{ "message": "Logged out successfully." }
Users
GET /api/users/me
Auth: Required

Description: Returns current user’s profile.

Response:

{
  "data": {
    "id": "string",
    "email": "string",
    "name": "string",
    "role": "USER",
    "locale": "en",
    "avatarUrl": "string"
  }
}
PATCH /api/users/me
Auth: Required

Description: Update name, phone, or locale.

Body: (any combination)

{
  "name": "string",
  "phone": "string",
  "locale": "string"
}
Response:

{ "data": { "id": "string", "email": "string", "name": "string", ... } }
POST /api/users/me/avatar
Auth: Required

Description: Upload new avatar image. Returns avatarUrl.

Form‐Data: file (binary image)

Response:

{ "data": { "avatarUrl": "https://s3.amazonaws.com/..." } }
POST /api/users/me/password
Auth: Required

Description: Change user password.

Body:

{
  "currentPassword": "string",
  "newPassword": "string"
}
Response:

{ "message": "Password updated." }
PATCH /api/users/me/2fa/setup
Auth: Required

Description: Initiate 2FA setup (returns QR code data).

Response:

{ "data": { "qrCode": "data:image/png;base64,..." } }
POST /api/users/me/2fa/verify
Auth: Required

Description: Verify TOTP code.

Body:

{
  "token": "string"
}
Response:

{ "message": "2FA enabled." }
POST /api/users/me/2fa/disable
Auth: Required

Description: Disable 2FA for the current user.

Response:

{ "message": "2FA disabled." }
Subscriptions & Billing
GET /api/users/me/subscription
Auth: Required

Description: Return current user’s plan info.

Response:

{
  "data": {
    "plan": "Pro",
    "status": "ACTIVE",
    "currentPeriodEnd": "ISODate",
    "storageUsedMB": 1200,
    "storageLimitMB": 2048
  }
}
POST /api/subscriptions/subscribe
Auth: Required

Description: Create or update subscription (Stripe Checkout).

Body:

{
  "priceId": "string"  // Stripe Price ID
}
Response:

{ "data": { "checkoutUrl": "https://checkout.stripe.com/..." } }
POST /api/subscriptions/webhook
Description: Stripe webhook endpoint to process events (e.g., invoice.paid, customer.subscription.deleted).

Body: Stripe event payload.

Response:

{ "received": true }
Vault (Folders & Files)
GET /api/vault/folders
Auth: Required

Description: List all folders and categories for current user.

Response:

{
  "data": [
    { "id": "uuid", "category": "Estate Planning", "folders": [ /* ... */ ] },
    { "id": "uuid", "category": "Entities & Business", "folders": [ /* ... */ ] },
    // ...
  ]
}
POST /api/vault/folders
Auth: Required

Description: Create a new folder under a category.

Body:

{
  "category": "string",
  "name": "string"
}
Response:

{ "data": { "id": "uuid", "category": "string", "name": "string" } }
DELETE /api/vault/folders/:id
Auth: Required

Description: Delete a folder (and optionally all its files).

Response:

{ "message": "Folder deleted." }
GET /api/vault/upload-url
Auth: Required

Query Params:

folderId (string)

fileName (string)

fileType (string, e.g. application/pdf)

Description: Returns a presigned S3 URL for upload.

Response:

{
  "data": {
    "uploadUrl": "https://s3.amazonaws.com/...",
    "fileKey": "vault/{userId}/{folderId}/{uuid}-{fileName}"
  }
}
POST /api/vault/files
Auth: Required

Body:

{
  "folderId": "uuid",
  "fileKey": "string",
  "fileName": "string",
  "fileSizeMB": 1.23,
  "mimeType": "application/pdf"
}
Description: Save metadata after uploading to S3. Also triggers storage‐threshold check (Vault Alerts).

Response:

{ "data": { "id": "uuid", "fileKey": "string", "fileName": "string", "mimeType": "string" } }
GET /api/vault/files
Auth: Required

Query Params: folderId (string)

Description: List all files in a folder.

Response:

{
  "data": [
    {
      "id": "uuid",
      "fileName": "string",
      "fileKey": "string",
      "mimeType": "string",
      "createdAt": "ISODate"
    },
    // ...
  ]
}
DELETE /api/vault/files/:id
Auth: Required

Description: Delete file metadata and remove from S3.

Response:

{ "message": "File deleted." }
GET /api/vault/emergency/:code
Auth: Public

Description: Validate emergency access code, return read‐only signed URLs to files in designated folder.

Response:

{
  "data": {
    "folderName": "string",
    "files": [
      { "fileName": "string", "signedUrl": "https://s3.amazonaws.com/..." },
      // ...
    ]
  }
}
Financial Hub
Plaid
POST /api/financial/plaid/create-link-token
Auth: Required

Body: { "clientUserId": "string" }

Response:

{ "data": { "link_token": "string" } }
POST /api/financial/plaid/exchange-token
Auth: Required

Body: { "public_token": "string" }

Response:

{ "data": { "access_token": "string", "item_id": "string" } }
GET /api/financial/plaid/accounts
Auth: Required

Response:

{
  "data": [
    { "account_id": "string", "name": "string", "balance": 123.45 },
    // ...
  ]
}
GET /api/financial/plaid/transactions
Auth: Required

Query Params: start_date=YYYY-MM-DD, end_date=YYYY-MM-DD

Response:

{
  "data": [
    {
      "transaction_id": "string",
      "amount": 45.67,
      "date": "YYYY-MM-DD",
      "name": "string"
    },
    // ...
  ]
}
Yodlee (Stub)
POST /api/financial/yodlee/create-session
Auth: Required

Response (Placeholder):

{
  "data": {
    "cobSession": "string",
    "userSession": "string",
    "createdAt": "ISODate"
  }
}
GET /api/financial/yodlee/accounts
Auth: Required

Response (Placeholder):

{
  "data": [
    { "id": "string", "name": "string", "balance": 123.45 }
    // ...
  ]
}
Search
GET /api/search?query={text}
Auth: Required

Description: Full‐text search across Trust, Entity, and VaultFile tables.

Response:

{
  "data": {
    "trusts": [ /* array of matching Trusts */ ],
    "entities": [ /* array of matching Entities */ ],
    "files": [ /* array of matching VaultFiles */ ]
  }
}
Trust Builder
POST /api/trusts/draft
Auth: Required

Body:

{
  "type": "Revocable" | "Irrevocable" | "SpecialNeeds",
  "basicInfo": { /* ... */ },
  "trustees": [ /* ... */ ],
  "beneficiaries": [ /* ... */ ],
  "state": "CA",
  "clauses": [ "TrustProtector", "DigitalAssets", /* ... */ ],
  "additionalFields": { /* ... */ }
}
Description: Streams GPT‐4 draft via SSE.

Response: SSE stream of HTML or text segments.

POST /api/trusts/compliance-check
Auth: Required

Body:

{ "draftHtml": "string" }
Response:

{
  "data": {
    "issues": [
      { "field": "DigitalAssets", "message": "Clause missing state-specific requirement." },
      // ...
    ],
    "passed": boolean
  }
}
POST /api/trusts/:id/finalize
Auth: Required

Body: none

Description: Generates a finalized PDF, uploads to S3, updates Trust.status, and creates a VaultFile under “Trusts” folder.

Response:

{
  "data": {
    "pdfUrl": "https://s3.amazonaws.com/...",
    "vaultFileId": "uuid"
  }
}
Entity Builder
POST /api/entities/draft
Auth: Required

Body: (similar structure to Trust Builder, with entity‐specific fields)

Response: SSE stream of HTML or text.

POST /api/entities/compliance-check
Auth: Required

Body:

{ "draftHtml": "string" }
Response:

{
  "data": {
    "issues": [ /* ... */ ],
    "passed": boolean
  }
}
POST /api/entities/:id/finalize
Auth: Required

Description: Generates PDF, uploads to S3, updates Entity.status, and creates a VaultFile under “LLCs & Business Entities.”

Response:

{
  "data": {
    "pdfUrl": "https://s3.amazonaws.com/...",
    "vaultFileId": "uuid"
  }
}
Legacy Letter
POST /api/legacy-letter/generate
Auth: Required

Body:

{
  "tone": "string",
  "recipients": ["string", ...],
  "body": "string",
  "attachments": ["fileKey1", ...]
}
Response: SSE stream of generated letter HTML.

POST /api/legacy-letter/compliance-check
Auth: Required

Body:

{ "draftHtml": "string" }
Response:

{
  "data": {
    "issues": [ /* ... */ ],
    "passed": boolean
  }
}
POST /api/legacy-letter/:id/finalize
Auth: Required

Description: Generates final PDF, uploads to S3, updates LegacyLetter.status, and creates a VaultFile under “Estate Planning → Legacy Letters.”

Response:

{
  "data": {
    "pdfUrl": "https://s3.amazonaws.com/...",
    "vaultFileId": "uuid"
  }
}
AI Advisor (“Ava”)
POST /api/ai/advisor
Auth: Required

Body:

{ "prompt": "string", "context": "string (optional)" }
Response: SSE stream of GPT‐4 Turbo messages.

Protection Score
GET /api/protection-score
Auth: Required

Response:

{
  "data": {
    "score": 75,
    "breakdown": {
      "trust": 25,
      "entity": 15,
      "vault": 18,
      "security": 9,
      "financial": 8
    },
    "suggestions": [ "Create a trust", "Set up 2FA", ... ]
  }
}
Notifications & Check‐Ins
POST /api/push-tokens
Auth: Required

Body:

{ "token": "string", "deviceId": "string" }
Response:

{
  "data": { "id": "uuid", "token": "string", "deviceId": "string" }
}
DELETE /api/push-tokens/:id
Auth: Required

Response:

{ "message": "Push token deleted." }
POST /api/checkins
Auth: Required

Body:

{ "frequency": "DAILY" | "WEEKLY" | "MONTHLY", "nextDate": "ISODate" }
Response:

{ "data": { "id": "uuid", "frequency": "WEEKLY", "nextDate": "ISODate" } }
GET /api/checkins
Auth: Required

Response:

{
  "data": [
    { "id": "uuid", "frequency": "WEEKLY", "nextDate": "ISODate", "lastSent": "ISODate" }
    // ...
  ]
}
PATCH /api/checkins/:id
Auth: Required

Body:

{ "frequency": "string", "nextDate": "ISODate" }
Response:

{ "data": { "id": "uuid", /* updated fields */ } }
DELETE /api/checkins/:id
Auth: Required

Response:

{ "message": "Check-in deleted." }
Admin
GET /api/admin/metrics
Auth: Requires role = ADMIN

Description: Return user growth, churn, vault usage, API usage.

Response:

{
  "data": {
    "userGrowth": [{ "date": "YYYY-MM-DD", "count": number }, ...],
    "churn": [{ "date": "YYYY-MM-DD", "count": number }, ...],
    "vaultUsage": [{ "date": "YYYY-MM-DD", "usedMB": number }, ...],
    "apiUsage": [{ "endpoint": "/api/ai/advisor", "count": number }, ...]
  }
}
GET /api/admin/audit-logs
Auth: Requires role = ADMIN

Response:

{
  "data": [
    {
      "id": "uuid",
      "userId": "string",
      "action": "string",
      "resource": "string",
      "timestamp": "ISODate"
    },
    // ...
  ]
}
GET /api/admin/incidents
Auth: Requires role = ADMIN

Response:

{
  "data": [
    {
      "id": "uuid",
      "userId": "string",
      "type": "FRAUD_SCORE_HIGH",
      "details": { /* ... */ },
      "resolved": false,
      "createdAt": "ISODate"
    },
    // ...
  ]
}
POST /api/admin/incidents/:id/resolve
Auth: Requires role = ADMIN

Response:

{
  "data": {
    "id": "uuid",
    "resolved": true,
    "createdAt": "ISODate"
  }
}
Error Handling & Utilities
All routes use Zod for body validation.

Custom errors are thrown via ApiError.

Global errorHandler middleware returns standardized JSON:

{ "error": { "message": "string", "code": "string (optional)" } }
Rate limiting and CSRF protection are enabled on all /api/* routes.

With the above docs/api.md in place, your README or root documentation can simply link to it.

Summary
By adding or updating the files above:

Incident Model & Fraud Monitoring

schema.prisma: added Incident.

jobs/fraudMonitor.ts: implements polling + incident creation.

routes/admin/incidents.ts: admin endpoints.

frontend/pages/admin/incidents.tsx: UI for listing/resolving incidents.

Yodlee Stubs

Create create-session.ts & accounts.ts under routes/financial/yodlee.

Register them in the financial index.

PWA / Web Push Service Worker

public/firebase-messaging-sw.js: basic Firebase Messaging SW.

Register in client code (see instructions).

DOMPurify Sanitization

Install dompurify.

Use DOMPurify.sanitize(...) in every component that calls dangerouslySetInnerHTML or otherwise renders raw GPT‐generated HTML.

Markdown API Docs

Create a new docs/api.md summarizing all endpoints in human‐readable Markdown.

Once you apply these changes, run:

# Regenerate Prisma client:
cd backend && npx prisma generate

# (Rebuild/typescript if necessary)
And redeploy the frontend so that the new service worker is recognized (often you need to clear existing SW caches in your browser). After that, every planned feature will be present in code.

Let me know if you need any further details or adjustments!