name: Restore

on:
  workflow_dispatch:

jobs:
  restore:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Restore via script
        run: |
          #!/usr/bin/env bash
          set -e
          
          # ============================
          # Part 1: Backend Directories & package.json
          # ============================
          
          # Create backend directory structure
          mkdir -p backend/prisma
          mkdir -p backend/src/config
          mkdir -p backend/src/middleware
          mkdir -p backend/src/utils
          mkdir -p backend/src/routes/auth
          mkdir -p backend/src/routes/users
          mkdir -p backend/src/routes/subscriptions/plans
          mkdir -p backend/src/routes/subscriptions
          mkdir -p backend/src/routes/trusts
          mkdir -p backend/src/routes/entities
          mkdir -p backend/src/routes/vault/folders
          mkdir -p backend/src/routes/vault/files
          mkdir -p backend/src/routes/vault
          mkdir -p backend/src/routes/search
          mkdir -p backend/src/routes/ai
          mkdir -p backend/src/routes/legacy-letter
          mkdir -p backend/src/routes/protection-score
          mkdir -p backend/src/routes/dashboard
          mkdir -p backend/src/routes/admin
          mkdir -p backend/src/routes/notifications
          mkdir -p backend/src/routes/push-notifications
          mkdir -p backend/src/jobs
          
          # Navigate into backend folder
          cd backend
          
          # ----------------------------
          # backend/package.json
          # ----------------------------
          cat > package.json << 'EOF'
          {
            "name": "legacy-pro-backend",
            "version": "1.0.0",
            "main": "server.js",
            "scripts": {
              "dev": "NODE_ENV=development nodemon server.js",
              "start": "node server.js",
              "migrate": "prisma migrate dev --name init",
              "generate": "prisma generate"
            },
            "dependencies": {
              "@prisma/client": "^4.0.0",
              "bcrypt": "^5.0.1",
              "bull": "^4.0.0",
              "csurf": "^1.11.0",
              "dotenv": "^10.0.0",
              "express": "^4.17.1",
              "express-rate-limit": "^6.0.0",
              "firebase-admin": "^10.0.0",
              "jsdoc-to-swagger": "^1.0.0",
              "jsonwebtoken": "^8.5.1",
              "nodemailer": "^6.7.2",
              "plaid": "^10.0.0",
              "prisma": "^4.0.0",
              "stripe": "^8.0.0",
              "swagger-ui-express": "^4.1.6",
              "twilio": "^3.75.0",
              "zod": "^3.11.6"
            },
            "devDependencies": {
              "@types/express": "^4.17.13",
              "@types/node": "^16.11.7",
              "nodemon": "^2.0.15",
              "typescript": "^4.4.4"
            }
          }
          EOF
          
          # Return to project root
          cd ..
          
          echo "Part 1 complete: Backend directories created and package.json generated."
          #!/usr/bin/env bash
          set -e
          
          # ============================
          # Part 2: Prisma Schema, Prisma Client, server.js, and Config Files
          # (Place under backend/ and backend/src/config)
          # ============================
          
          # Navigate into backend folder
          cd backend
          
          # ----------------------------
          # 1. Prisma Schema: prisma/schema.prisma
          # ----------------------------
          cat > prisma/schema.prisma << 'EOF'
          datasource db {
            provider = "postgresql"
            url      = env("DATABASE_URL")
          }
          
          generator client {
            provider = "prisma-client-js"
          }
          
          model User {
            id                String             @id @default(uuid())
            email             String             @unique
            passwordHash      String?
            name              String?
            avatarUrl         String?
            role              Role               @default(USER)
            twoFAEnabled      Boolean            @default(false)
            twoFASecret       String?
            locale            String             @default("en")
            firstTime         Boolean            @default(true)
            lastLogin         DateTime?
            createdAt         DateTime           @default(now())
            updatedAt         DateTime           @updatedAt
          
            sessions          Session[]
            userSubscriptions UserSubscription[]
            vaultFolders      VaultFolder[]
            vaultFiles        VaultFile[]
            auditLogs         AuditLog[]
            notifications     Notification[]
            notificationPrefs NotificationPreference[]
            userCheckIns      UserCheckIn[]
            aiUsageLogs       AIUsageLog[]
            trusts            Trust[]
            entities          Entity[]
            legacyLetters     LegacyLetter[]
            pushTokens        PushToken[]
            financialAccounts FinancialAccount[]
          }
          
          model Session {
            id           String   @id @default(uuid())
            sessionToken String   @unique
            userId       String
            user         User     @relation(fields: [userId], references: [id])
            expires      DateTime
          }
          
          model SubscriptionPlan {
            id             String           @id @default(uuid())
            name           String           @unique
            stripePlanId   String           @unique
            priceCents     Int
            billingCycle   BillingCycle
            storageLimitMB Int
            createdAt      DateTime         @default(now())
          }
          
          model UserSubscription {
            id             String              @id @default(uuid())
            userId         String
            planId         String
            status         SubscriptionStatus  @default(PENDING)
            startDate      DateTime?
            endDate        DateTime?
            stripeSubId    String?
            cancelAt       DateTime?
            createdAt      DateTime             @default(now())
            updatedAt      DateTime             @updatedAt
          
            user           User                @relation(fields: [userId], references: [id])
            plan           SubscriptionPlan    @relation(fields: [planId], references: [id])
          
            @@index([userId])
          }
          
          model VaultFolder {
            id         String       @id @default(uuid())
            userId     String
            parentId   String?
            name       String
            path       String
            createdAt  DateTime     @default(now())
            updatedAt  DateTime     @updatedAt
          
            user       User         @relation(fields: [userId], references: [id])
            parent     VaultFolder? @relation("FolderParent", fields: [parentId], references: [id])
            children   VaultFolder[] @relation("FolderParent")
            files      VaultFile[]
          }
          
          model VaultFile {
            id          String       @id @default(uuid())
            userId      String
            folderId    String
            fileName    String
            fileType    String
            size        Int
            s3Key       String       @unique
            createdAt   DateTime      @default(now())
            updatedAt   DateTime      @updatedAt
            isArchived  Boolean       @default(false)
          
            user        User          @relation(fields: [userId], references: [id])
            folder      VaultFolder   @relation(fields: [folderId], references: [id])
            auditLogs   AuditLog[]    @relation("FileActions")
          }
          
          model AuditLog {
            id           String        @id @default(uuid())
            userId       String
            resourceType ResourceType
            resourceId   String
            action       String
            metadata     Json?
            timestamp    DateTime      @default(now())
          
            user         User          @relation(fields: [userId], references: [id])
          }
          
          model Notification {
            id        String            @id @default(uuid())
            userId    String
            type      NotificationType
            content   Json
            read      Boolean           @default(false)
            createdAt DateTime          @default(now())
          
            user      User              @relation(fields: [userId], references: [id])
          }
          
          model NotificationPreference {
            id        String           @id @default(uuid())
            userId    String
            type      NotificationType
            enabled   Boolean          @default(true)
            createdAt DateTime         @default(now())
          
            user      User             @relation(fields: [userId], references: [id])
          
            @@unique([userId, type])
          }
          
          model UserCheckIn {
            id         String    @id @default(uuid())
            userId     String
            frequency  Frequency
            nextDate   DateTime
            lastSent   DateTime?
            createdAt  DateTime  @default(now())
            updatedAt  DateTime  @updatedAt
          
            user       User      @relation(fields: [userId], references: [id])
          }
          
          model AIUsageLog {
            id           String      @id @default(uuid())
            userId       String
            feature      FeatureType
            tokensUsed   Int
            promptHash   String
            createdAt    DateTime    @default(now())
          
            user         User        @relation(fields: [userId], references: [id])
          }
          
          model Trust {
            id                String        @id @default(uuid())
            userId            String
            trustName         String
            type              TrustType
            grantor           Json
            trustees          Json[]
            successorTrustees Json[]
            beneficiaries     Json[]
            state             String
            assetsIncluded    Json[]
            additionalClauses String[]
            data              Json
            status            DraftStatus
            pdfS3Key          String?
            createdAt         DateTime      @default(now())
            updatedAt         DateTime      @updatedAt
          
            user              User          @relation(fields: [userId], references: [id])
            auditLogs         AuditLog[]    @relation("TrustActions")
          }
          
          model Entity {
            id                String         @id @default(uuid())
            userId            String
            entityName        String
            type              EntityType
            owners            Json[]
            state             String
            purpose           String?
            capital           Json[]
            additionalClauses String[]
            data              Json
            status            DraftStatus
            pdfS3Key          String?
            createdAt         DateTime       @default(now())
            updatedAt         DateTime       @updatedAt
          
            user              User           @relation(fields: [userId], references: [id])
            auditLogs         AuditLog[]     @relation("EntityActions")
          }
          
          model LegacyLetter {
            id         String            @id @default(uuid())
            userId     String
            tone       String
            recipients String[]
            body       String
            attachedDocs Json[]
            status      DraftStatus
            pdfS3Key    String?
            createdAt   DateTime         @default(now())
            updatedAt   DateTime         @updatedAt
          
            user        User             @relation(fields: [userId], references: [id])
            auditLogs   AuditLog[]       @relation("LegacyLetterActions")
          }
          
          model PushToken {
            id         String   @id @default(uuid())
            userId     String
            deviceId   String
            token      String
            createdAt  DateTime @default(now())
          
            user       User     @relation(fields: [userId], references: [id])
          }
          
          model FinancialAccount {
            id            String      @id @default(uuid())
            userId        String
            provider      String
            accountData   Json
            accessToken   String?
            createdAt     DateTime    @default(now())
            updatedAt     DateTime    @updatedAt
          
            user          User        @relation(fields: [userId], references: [id])
          }
          
          model Locale {
            id      String  @id @default(uuid())
            code    String  @unique
            name    String
          }
          
          model Translation {
            id       String  @id @default(uuid())
            localeId String
            module   String
            key      String
            text     String
          
            locale   Locale  @relation(fields: [localeId], references: [id])
          
            @@unique([localeId, module, key])
          }
          
          enum Role {
            USER
            ADMIN
          }
          
          enum SubscriptionStatus {
            PENDING
            ACTIVE
            CANCELED
          }
          
          enum BillingCycle {
            MONTHLY
            ANNUAL
          }
          
          enum ResourceType {
            VaultFile
            Trust
            Entity
            LegacyLetter
            User
            Notification
          }
          
          enum NotificationType {
            VaultAlert
            RegulatoryUpdate
            CheckInReminder
            ComplianceIssue
          }
          
          enum Frequency {
            DAILY
            WEEKLY
            MONTHLY
          }
          
          enum FeatureType {
            Advisor
            TrustBuilder
            EntityBuilder
            LegacyLetter
          }
          
          enum TrustType {
            REVOCABLE
            IRREVOCABLE
            SPECIAL_NEEDS
            DYNASTY
            MINOR
          }
          
          enum EntityType {
            LLC
            S_CORP
            C_CORP
            DBA
          }
          
          enum DraftStatus {
            DRAFT
            FINALIZED
          }
          EOF
          
          # ----------------------------
          # 2. Prisma Client File: prismaClient.ts
          # ----------------------------
          cat > prismaClient.ts << 'EOF'
          const { PrismaClient } = require("@prisma/client");
          const prisma = new PrismaClient();
          module.exports = prisma;
          EOF
          
          # ----------------------------
          # 3. Main Server File: server.js
          # ----------------------------
          cat > server.js << 'EOF'
          require("dotenv").config();
          const express = require("express");
          const cors = require("cors");
          const swaggerUi = require("swagger-ui-express");
          const swaggerDocument = require("./swagger.json");
          const nextAuthRouter = require("./src/routes/auth");
          const userRouter = require("./src/routes/users");
          const subscriptionRouter = require("./src/routes/subscriptions");
          const trustRouter = require("./src/routes/trusts");
          const entityRouter = require("./src/routes/entities");
          const vaultRouter = require("./src/routes/vault");
          const aiRouter = require("./src/routes/ai");
          const legacyLetterRouter = require("./src/routes/legacy-letter");
          const protectionScoreRouter = require("./src/routes/protection-score");
          const dashboardRouter = require("./src/routes/dashboard");
          const adminRouter = require("./src/routes/admin");
          const notificationRouter = require("./src/routes/notifications");
          const searchRouter = require("./src/routes/search");
          const pushTokenRouter = require("./src/routes/push-notifications");
          const { authLimiter, apiLimiter } = require("./src/middleware/rateLimiter");
          const errorHandler = require("./src/middleware/errorHandler");
          const csrfProtection = require("./src/middleware/csrfProtection");
          
          const app = express();
          app.use(cors());
          app.use(express.json());
          
          // Swagger docs
          app.use("/api/docs", swaggerUi.serve, swaggerUi.setup(swaggerDocument));
          
          // Rate limiting
          app.use("/api/auth", authLimiter);
          app.use("/api", apiLimiter);
          
          // CSRF Protection
          app.use(csrfProtection);
          
          // Routes
          app.use("/api/auth", nextAuthRouter);
          app.use("/api/users", userRouter);
          app.use("/api/subscriptions", subscriptionRouter);
          app.use("/api/trusts", trustRouter);
          app.use("/api/entities", entityRouter);
          app.use("/api/vault", vaultRouter);
          app.use("/api/ai", aiRouter);
          app.use("/api/legacy-letter", legacyLetterRouter);
          app.use("/api/protection-score", protectionScoreRouter);
          app.use("/api/dashboard", dashboardRouter);
          app.use("/api/admin", adminRouter);
          app.use("/api/notifications", notificationRouter);
          app.use("/api/search", searchRouter);
          app.use("/api/push-tokens", pushTokenRouter);
          
          // Error handling
          app.use(errorHandler);
          
          const PORT = process.env.PORT || 4000;
          app.listen(PORT, () => {
            console.log(\`Legacy Pro backend running on port \${PORT}\`);
          });
          EOF
          
          # ----------------------------
          # 4. Configuration: backend/src/config/index.js
          # ----------------------------
          cat > src/config/index.js << 'EOF'
          require("dotenv").config();
          
          module.exports = {
            DATABASE_URL: process.env.DATABASE_URL,
            NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET,
            JWT_SECRET: process.env.JWT_SECRET,
            STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY,
            STRIPE_WEBHOOK_SECRET: process.env.STRIPE_WEBHOOK_SECRET,
            OPENAI_API_KEY: process.env.OPENAI_API_KEY,
            TWILIO_ACCOUNT_SID: process.env.TWILIO_ACCOUNT_SID,
            TWILIO_AUTH_TOKEN: process.env.TWILIO_AUTH_TOKEN,
            TWILIO_PHONE_NUMBER: process.env.TWILIO_PHONE_NUMBER,
            PLAID_CLIENT_ID: process.env.PLAID_CLIENT_ID,
            PLAID_SECRET: process.env.PLAID_SECRET,
            PLAID_ENV: process.env.PLAID_ENV || "sandbox",
            YODLEE_CLIENT_ID: process.env.YODLEE_CLIENT_ID,
            YODLEE_SECRET: process.env.YODLEE_SECRET,
            EMAIL_SERVER: process.env.EMAIL_SERVER,
            EMAIL_FROM: process.env.EMAIL_FROM,
            FCM_SERVER_KEY: process.env.FCM_SERVER_KEY,
            RATE_LIMIT_WINDOW: process.env.RATE_LIMIT_WINDOW || 15 * 60 * 1000,
            RATE_LIMIT_MAX: process.env.RATE_LIMIT_MAX || 100
          };
          EOF
          
          # ----------------------------
          # 5. Configuration: backend/src/config/stripe.js
          # ----------------------------
          cat > src/config/stripe.js << 'EOF'
          const Stripe = require("stripe");
          const { STRIPE_SECRET_KEY } = require("./index");
          const stripe = new Stripe(STRIPE_SECRET_KEY, { apiVersion: "2022-11-15" });
          module.exports = stripe;
          EOF
          
          # ----------------------------
          # 6. Configuration: backend/src/config/plaid.js
          # ----------------------------
          cat > src/config/plaid.js << 'EOF'
          const { Configuration, PlaidApi, PlaidEnvironments } = require("plaid");
          const { PLAID_CLIENT_ID, PLAID_SECRET, PLAID_ENV } = require("./index");
          
          const config = new Configuration({
            basePath: PlaidEnvironments[PLAID_ENV],
            baseOptions: {
              headers: {
                "PLAID-CLIENT-ID": PLAID_CLIENT_ID,
                "PLAID-SECRET": PLAID_SECRET
              }
            }
          });
          const plaidClient = new PlaidApi(config);
          module.exports = plaidClient;
          EOF
          
          # ----------------------------
          # 7. Configuration: backend/src/config/sms.js
          # ----------------------------
          cat > src/config/sms.js << 'EOF'
          const Twilio = require("twilio");
          const { TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, TWILIO_PHONE_NUMBER } = require("./index");
          const client = new Twilio(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN);
          
          async function sendSMS({ to, body }) {
            await client.messages.create({ from: TWILIO_PHONE_NUMBER, to, body });
          }
          
          module.exports = sendSMS;
          EOF
          
          # ----------------------------
          # 8. Configuration: backend/src/config/email.js
          # ----------------------------
          cat > src/config/email.js << 'EOF'
          const nodemailer = require("nodemailer");
          const { EMAIL_SERVER, EMAIL_FROM } = require("./index");
          
          const transporter = nodemailer.createTransport(EMAIL_SERVER);
          
          async function sendEmail({ to, subject, html }) {
            await transporter.sendMail({ from: EMAIL_FROM, to, subject, html });
          }
          
          module.exports = sendEmail;
          EOF
          
          # Return to project root
          cd ..
          
          echo "Part 2 complete: Prisma schema, prisma-client, server.js, and config files created."
          #!/usr/bin/env bash
          set -e
          
          # ============================
          # Part 3: Backend Middleware & Utilities
          # (Place under backend/src/middleware and backend/src/utils)
          # ============================
          
          # Navigate into backend folder
          cd backend
          
          # ----------------------------------------
          # 1. Middleware: backend/src/middleware/auth.js
          # ----------------------------------------
          cat > src/middleware/auth.js << 'EOF'
          const { getToken } = require("next-auth/jwt");
          const ApiError = require("../utils/ApiError");
          
          module.exports = async function authMiddleware(req, res, next) {
            try {
              const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });
              if (!token) throw new ApiError(401, "Not authenticated");
              req.user = { id: token.sub, role: token.role || "USER" };
              next();
            } catch (err) {
              next(err);
            }
          };
          EOF
          
          # ----------------------------------------
          # 2. Middleware: backend/src/middleware/rateLimiter.js
          # ----------------------------------------
          cat > src/middleware/rateLimiter.js << 'EOF'
          const rateLimit = require("express-rate-limit");
          const { RATE_LIMIT_WINDOW, RATE_LIMIT_MAX } = require("../config");
          
          const authLimiter = rateLimit({
            windowMs: RATE_LIMIT_WINDOW,
            max: 5,
            message: "Too many login attempts; please try again later.",
            keyGenerator: (req) => req.ip,
            skipSuccessfulRequests: true
          });
          
          const apiLimiter = rateLimit({
            windowMs: RATE_LIMIT_WINDOW,
            max: RATE_LIMIT_MAX,
            message: "Too many requests; please slow down.",
            keyGenerator: (req) => req.user?.id || req.ip
          });
          
          module.exports = { authLimiter, apiLimiter };
          EOF
          
          # ----------------------------------------
          # 3. Middleware: backend/src/middleware/auditLogger.js
          # ----------------------------------------
          cat > src/middleware/auditLogger.js << 'EOF'
          const prisma = require("../../prismaClient");
          
          async function logAudit({ userId, resourceType, resourceId, action, metadata = {} }) {
            await prisma.auditLog.create({
              data: { userId, resourceType, resourceId, action, metadata }
            });
          }
          
          module.exports = logAudit;
          EOF
          
          # ----------------------------------------
          # 4. Middleware: backend/src/middleware/csrfProtection.js
          # ----------------------------------------
          cat > src/middleware/csrfProtection.js << 'EOF'
          const csurf = require("csurf");
          const csrfProtection = csurf({ cookie: true });
          module.exports = csrfProtection;
          EOF
          
          # ----------------------------------------
          # 5. Middleware: backend/src/middleware/errorHandler.js
          # ----------------------------------------
          cat > src/middleware/errorHandler.js << 'EOF'
          function errorHandler(err, req, res, next) {
            console.error(err);
            if (err.isJoi || err.name === "ZodError") {
              return res.status(400).json({ error: err.message });
            }
            if (err.status) {
              return res.status(err.status).json({ error: err.message });
            }
            return res.status(500).json({ error: "Internal Server Error" });
          }
          
          module.exports = errorHandler;
          EOF
          
          # ----------------------------------------
          # 6. Utility: backend/src/utils/ApiError.js
          # ----------------------------------------
          cat > src/utils/ApiError.js << 'EOF'
          class ApiError extends Error {
            constructor(status, message) {
              super(message);
              this.status = status;
            }
          }
          
          module.exports = ApiError;
          EOF
          
          # ----------------------------------------
          # 7. Utility: backend/src/utils/logger.js
          # ----------------------------------------
          cat > src/utils/logger.js << 'EOF'
          const winston = require("winston");
          
          const logger = winston.createLogger({
            level: process.env.NODE_ENV === "production" ? "info" : "debug",
            format: winston.format.combine(
              winston.format.timestamp(),
              winston.format.json()
            ),
            transports: [new winston.transports.Console()]
          });
          
          module.exports = logger;
          EOF
          
          # ----------------------------------------
          # 8. Utility: backend/src/utils/validationSchemas.js
          # ----------------------------------------
          cat > src/utils/validationSchemas.js << 'EOF'
          const Joi = require("joi");
          
          const trustSchema = Joi.object({
            trustName: Joi.string().min(3).required(),
            type: Joi.string().valid("REVOCABLE", "IRREVOCABLE", "SPECIAL_NEEDS", "DYNASTY", "MINOR").required(),
            grantor: Joi.object({
              firstName: Joi.string().required(),
              lastName: Joi.string().required(),
              address: Joi.string().allow(""),
              DOB: Joi.string().isoDate().allow("")
            }).required(),
            trustees: Joi.array().items(
              Joi.object({
                firstName: Joi.string().required(),
                lastName: Joi.string().required(),
                address: Joi.string().allow("")
              })
            ).min(1).required(),
            beneficiaries: Joi.array().items(
              Joi.object({
                firstName: Joi.string().required(),
                lastName: Joi.string().required(),
                allocation: Joi.number().min(0).max(100).required(),
                DOB: Joi.string().isoDate().allow("")
              })
            ).min(1).required()
              .custom((list, helper) => {
                const sum = list.reduce((acc, b) => acc + b.allocation, 0);
                if (sum !== 100) return helper.message("Allocations must sum to 100%");
                return list;
              }),
            state: Joi.string().length(2).required(),
            additionalClauses: Joi.array().items(Joi.string()).optional(),
            assetsIncluded: Joi.array().items(
              Joi.object({
                type: Joi.string().required(),
                description: Joi.string().required()
              })
            ).optional()
          });
          
          module.exports = {
            trustSchema
          };
          EOF
          
          # Return to project root
          cd ..
          
          echo "Part 3 complete: all middleware and utility files created under backend/src."
          #!/usr/bin/env bash
          set -e
          
          # ============================
          # Part 4a: Backend Routes – Auth & Users
          # (Place under backend/src/routes)
          # ============================
          
          # Navigate into backend folder
          cd backend
          
          # ----------------------------------------
          # 1. Auth Routes: backend/src/routes/auth/[...nextauth].ts
          # ----------------------------------------
          mkdir -p src/routes/auth
          cat > src/routes/auth/[...nextauth].ts << 'EOF'
          import NextAuth from "next-auth";
          import Providers from "next-auth/providers";
          import { PrismaAdapter } from "@next-auth/prisma-adapter";
          import prisma from "../../../prismaClient";
          
          export default NextAuth({
            adapter: PrismaAdapter(prisma),
            session: { jwt: true },
            jwt: { secret: process.env.NEXTAUTH_SECRET },
            providers: [
              Providers.Email({
                server: process.env.EMAIL_SERVER!,
                from: process.env.EMAIL_FROM!
              }),
              Providers.Google({
                clientId: process.env.GOOGLE_CLIENT_ID!,
                clientSecret: process.env.GOOGLE_CLIENT_SECRET!
              }),
              Providers.GitHub({
                clientId: process.env.GITHUB_ID!,
                clientSecret: process.env.GITHUB_SECRET!
              })
            ],
            callbacks: {
              async session({ session, user }) {
                session.user.id = user.id;
                session.user.role = user.role;
                return session;
              }
            },
            pages: {
              signIn: "/login",
              signOut: "/",
              error: "/login?error="
            },
            events: {
              async signIn(message) {
                await prisma.user.update({
                  where: { id: message.user.id },
                  data: { lastLogin: new Date(), firstTime: false }
                });
              }
            }
          });
          EOF
          
          # ----------------------------------------
          # 2. User Routes: backend/src/routes/users/index.ts
          # ----------------------------------------
          mkdir -p src/routes/users
          cat > src/routes/users/index.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          import bcrypt from "bcrypt";
          import sendEmail from "../../config/email";
          import sendSMS from "../../config/sms";
          import ApiError from "../../utils/ApiError";
          
          const router = express.Router();
          
          // GET /api/users/me
          router.get("/me", authMiddleware, async (req, res, next) => {
            try {
              const user = await prisma.user.findUnique({ where: { id: req.user.id } });
              if (!user) throw new ApiError(404, "User not found");
              res.json(user);
            } catch (err) {
              next(err);
            }
          });
          
          // PATCH /api/users/me
          router.patch("/me", authMiddleware, async (req, res, next) => {
            try {
              const { name, locale } = req.body;
              const updated = await prisma.user.update({
                where: { id: req.user.id },
                data: { name, locale }
              });
              res.json(updated);
            } catch (err) {
              next(err);
            }
          });
          
          // POST /api/users/me/avatar
          router.post("/me/avatar", authMiddleware, async (req, res, next) => {
            try {
              const { fileName, fileType, size } = req.body;
              // Generate presigned PUT URL for S3 (implement getPresignedPutUrl separately)
              const key = \`avatars/\${req.user.id}/\${fileName}\`;
              const putUrl = await getPresignedPutUrl(key, fileType);
              res.json({ key, url: putUrl });
            } catch (err) {
              next(err);
            }
          });
          
          // POST /api/users/me/password
          router.post("/me/password", authMiddleware, async (req, res, next) => {
            try {
              const { currentPassword, newPassword } = req.body;
              const user = await prisma.user.findUnique({ where: { id: req.user.id } });
              if (!user?.passwordHash) throw new ApiError(400, "No password set");
              const match = await bcrypt.compare(currentPassword, user.passwordHash);
              if (!match) throw new ApiError(400, "Current password incorrect");
              const hash = await bcrypt.hash(newPassword, 10);
              await prisma.user.update({
                where: { id: req.user.id },
                data: { passwordHash: hash }
              });
              res.json({ message: "Password updated" });
            } catch (err) {
              next(err);
            }
          });
          
          // POST /api/users/me/2fa/setup
          router.post("/me/2fa/setup", authMiddleware, async (req, res, next) => {
            try {
              const secret = generateTOTPSecret(); // implement separately
              const qrCodeDataURL = await generateQRCodeDataURL(secret); // implement separately
              await prisma.user.update({
                where: { id: req.user.id },
                data: { twoFASecret: encrypt(secret) } // implement encrypt separately
              });
              res.json({ qrCodeDataURL });
            } catch (err) {
              next(err);
            }
          });
          
          // POST /api/users/me/2fa/verify
          router.post("/me/2fa/verify", authMiddleware, async (req, res, next) => {
            try {
              const { token } = req.body;
              const user = await prisma.user.findUnique({ where: { id: req.user.id } });
              const secret = decrypt(user?.twoFASecret!); // implement decrypt separately
              const valid = verifyTOTPToken(secret, token); // implement verify separately
              if (!valid) throw new ApiError(400, "Invalid token");
              await prisma.user.update({
                where: { id: req.user.id },
                data: { twoFAEnabled: true }
              });
              res.json({ message: "2FA enabled" });
            } catch (err) {
              next(err);
            }
          });
          
          // DELETE /api/users/me/2fa
          router.delete("/me/2fa", authMiddleware, async (req, res, next) => {
            try {
              await prisma.user.update({
                where: { id: req.user.id },
                data: { twoFAEnabled: false, twoFASecret: null }
              });
              res.json({ message: "2FA disabled" });
            } catch (err) {
              next(err);
            }
          });
          
          // GET /api/users/checkins
          router.get("/checkins", authMiddleware, async (req, res, next) => {
            try {
              const checkIns = await prisma.userCheckIn.findMany({ where: { userId: req.user.id } });
              res.json(checkIns);
            } catch (err) {
              next(err);
            }
          });
          
          // POST /api/users/checkins
          router.post("/checkins", authMiddleware, async (req, res, next) => {
            try {
              const { frequency, nextDate } = req.body;
              const newCheckIn = await prisma.userCheckIn.create({
                data: { userId: req.user.id, frequency, nextDate: new Date(nextDate) }
              });
              res.json(newCheckIn);
            } catch (err) {
              next(err);
            }
          });
          
          // PATCH /api/users/checkins/:id
          router.patch("/checkins/:id", authMiddleware, async (req, res, next) => {
            try {
              const { frequency, nextDate } = req.body;
              const updated = await prisma.userCheckIn.update({
                where: { id: req.params.id },
                data: { frequency, nextDate: new Date(nextDate) }
              });
              res.json(updated);
            } catch (err) {
              next(err);
            }
          });
          
          // DELETE /api/users/checkins/:id
          router.delete("/checkins/:id", authMiddleware, async (req, res, next) => {
            try {
              await prisma.userCheckIn.delete({ where: { id: req.params.id } });
              res.json({ message: "Deleted" });
            } catch (err) {
              next(err);
            }
          });
          
          // GET /api/users/notifications
          router.get("/notifications", authMiddleware, async (req, res, next) => {
            try {
              const notifications = await prisma.notification.findMany({
                where: { userId: req.user.id },
                orderBy: { createdAt: "desc" }
              });
              res.json(notifications);
            } catch (err) {
              next(err);
            }
          });
          
          // PATCH /api/users/notifications/:id/mark-read
          router.patch("/notifications/:id/mark-read", authMiddleware, async (req, res, next) => {
            try {
              const updated = await prisma.notification.update({
                where: { id: req.params.id },
                data: { read: true }
              });
              res.json(updated);
            } catch (err) {
              next(err);
            }
          });
          
          // PATCH /api/users/notifications (preferences)
          router.patch("/notifications", authMiddleware, async (req, res, next) => {
            try {
              const { type, enabled } = req.body;
              const pref = await prisma.notificationPreference.upsert({
                where: { userId_type: { userId: req.user.id, type } },
                update: { enabled },
                create: { userId: req.user.id, type, enabled }
              });
              res.json(pref);
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # Return to project root
          cd ..
          
          echo "Part 4a complete: Auth and Users routes created."
          #!/usr/bin/env bash
          set -e
          
          # ============================
          # Part 4b: Backend Routes – Subscriptions
          # (Place under backend/src/routes)
          # ============================
          
          # Navigate into backend folder
          cd backend
          
          # ----------------------------------------
          # 1. Subscription Plan Routes: backend/src/routes/subscriptions/plans.ts
          # ----------------------------------------
          mkdir -p src/routes/subscriptions
          mkdir -p src/routes/subscriptions/plans
          cat > src/routes/subscriptions/plans.ts << 'EOF'
          import express from "express";
          import prisma from "../../../prismaClient";
          
          const router = express.Router();
          
          // GET /api/subscriptions/plans
          router.get("/plans", async (req, res, next) => {
            try {
              const plans = await prisma.subscriptionPlan.findMany();
              res.json(plans);
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 2. Subscribe Route: backend/src/routes/subscriptions/subscribe.ts
          # ----------------------------------------
          cat > src/routes/subscriptions/subscribe.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          import stripe from "../../config/stripe";
          import ApiError from "../../utils/ApiError";
          
          const router = express.Router();
          
          // POST /api/subscriptions/subscribe
          router.post("/subscribe", authMiddleware, async (req, res, next) => {
            try {
              const { planId } = req.body;
              const user = await prisma.user.findUnique({ where: { id: req.user.id } });
              const plan = await prisma.subscriptionPlan.findUnique({ where: { id: planId } });
              if (!plan) throw new ApiError(404, "Plan not found");
          
              if (plan.priceCents === 0) {
                const subscription = await prisma.userSubscription.create({
                  data: {
                    userId: user!.id,
                    planId: plan.id,
                    status: "ACTIVE",
                    startDate: new Date()
                  }
                });
                return res.json({ subscription });
              }
          
              const session = await stripe.checkout.sessions.create({
                mode: "subscription",
                payment_method_types: ["card"],
                customer_email: user!.email!,
                line_items: [{ price: plan.stripePlanId, quantity: 1 }],
                success_url: \`\${process.env.FRONTEND_URL}/settings/plan?session_id={CHECKOUT_SESSION_ID}\`,
                cancel_url: \`\${process.env.FRONTEND_URL}/settings/plan\`
              });
          
              res.json({ sessionId: session.id, url: session.url });
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 3. Webhook Route: backend/src/routes/subscriptions/webhook.ts
          # ----------------------------------------
          cat > src/routes/subscriptions/webhook.ts << 'EOF'
          import express from "express";
          import { buffer } from "micro";
          import stripe from "../../config/stripe";
          import prisma from "../../../prismaClient";
          
          const router = express.Router();
          const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET!;
          
          // Skip body parsing, use raw buffer
          export const config = { api: { bodyParser: false } };
          
          router.post("/webhook", async (req, res) => {
            const sig = req.headers["stripe-signature"]!;
            const buf = await buffer(req);
            let event;
          
            try {
              event = stripe.webhooks.constructEvent(buf, sig, endpointSecret);
            } catch (err) {
              return res.status(400).send(\`Webhook Error: \${err.message}\`);
            }
          
            switch (event.type) {
              case "checkout.session.completed": {
                const session = event.data.object;
                const user = await prisma.user.findUnique({
                  where: { email: session.customer_email }
                });
                const plan = await prisma.subscriptionPlan.findUnique({
                  where: { stripePlanId: session.display_items[0].price.id }
                });
                if (user && plan) {
                  await prisma.userSubscription.upsert({
                    where: { userId: user.id },
                    update: {
                      status: "ACTIVE",
                      stripeSubId: session.subscription,
                      startDate: new Date()
                    },
                    create: {
                      userId: user.id,
                      planId: plan.id,
                      status: "ACTIVE",
                      stripeSubId: session.subscription,
                      startDate: new Date()
                    }
                  });
                }
                break;
              }
              case "invoice.payment_failed":
              case "customer.subscription.deleted": {
                const subscriptionId = event.data.object.id;
                await prisma.userSubscription.updateMany({
                  where: { stripeSubId: subscriptionId },
                  data: { status: "CANCELED", endDate: new Date() }
                });
                break;
              }
              default:
                break;
            }
            res.json({ received: true });
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 4. Subscription Status Route: backend/src/routes/subscriptions/status.ts
          # ----------------------------------------
          cat > src/routes/subscriptions/status.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          
          const router = express.Router();
          
          // GET /api/subscriptions/status
          router.get("/status", authMiddleware, async (req, res, next) => {
            try {
              const subscription = await prisma.userSubscription.findFirst({
                where: { userId: req.user.id },
                include: { plan: true }
              });
              if (!subscription) {
                return res.json({ planName: "None", status: "NONE", storageUsedMB: 0, storageLimitMB: 0 });
              }
              const storageUsedBytes = await prisma.vaultFile.aggregate({
                where: { userId: req.user.id },
                _sum: { size: true }
              });
              const storageUsedMB = Math.ceil((storageUsedBytes._sum.size || 0) / (1024 * 1024));
              res.json({
                planName: subscription.plan.name,
                status: subscription.status,
                storageUsedMB,
                storageLimitMB: subscription.plan.storageLimitMB,
                nextBillingDate: subscription.endDate
              });
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # Return to project root
          cd ..
          
          echo "Part 4b complete: Subscriptions routes created."
          #!/usr/bin/env bash
          set -e
          
          # ============================
          # Part 4c: Backend Routes – Trusts
          # (Place under backend/src/routes)
          # ============================
          
          # Navigate into backend folder
          cd backend
          
          # ----------------------------------------
          # 1. Trust Clauses Route: backend/src/routes/trusts/clauses.ts
          # ----------------------------------------
          mkdir -p src/routes/trusts
          cat > src/routes/trusts/clauses.ts << 'EOF'
          import express from "express";
          import clausesData from "../../../data/clauses.json";
          
          const router = express.Router();
          
          // GET /api/trusts/clauses?state=XX
          router.get("/clauses", (req, res) => {
            const state = (req.query.state as string)?.toUpperCase();
            if (!state) return res.status(400).json({ error: "State parameter is required." });
            const clauses = clausesData[state] || [];
            res.json({ clauses });
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 2. Trust Generate Route: backend/src/routes/trusts/generate.ts
          # ----------------------------------------
          cat > src/routes/trusts/generate.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          import { trustSchema } from "../../utils/validationSchemas";
          import OpenAI from "openai";
          import logAudit from "../../middleware/auditLogger";
          import ApiError from "../../utils/ApiError";
          import clausesData from "../../../data/clauses.json";
          
          const router = express.Router();
          const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
          
          router.post("/generate", authMiddleware, async (req, res, next) => {
            try {
              const validation = trustSchema.validate(req.body);
              if (validation.error) throw new ApiError(400, validation.error.details[0].message);
          
              const input = req.body;
              const newTrust = await prisma.trust.create({
                data: {
                  userId: req.user.id,
                  trustName: input.trustName,
                  type: input.type,
                  grantor: input.grantor,
                  trustees: input.trustees,
                  successorTrustees: input.successorTrustees,
                  beneficiaries: input.beneficiaries,
                  state: input.state,
                  assetsIncluded: input.assetsIncluded || [],
                  additionalClauses: input.additionalClauses || [],
                  data: {},
                  status: "DRAFT"
                }
              });
          
              const clauseTexts = input.additionalClauses.map((id: string) => {
                const allClauses = clausesData[input.state];
                const clause = allClauses.find((c: any) => c.id === id);
                return clause ? clause.text : "";
              });
          
              const prompt = \`
          You are LegalGPT. Generate a \${input.type} Trust for \${input.state}.
          Grantor: \${JSON.stringify(input.grantor)}.
          Trustees: \${JSON.stringify(input.trustees)}.
          Successor Trustees: \${JSON.stringify(input.successorTrustees)}.
          Beneficiaries: \${JSON.stringify(input.beneficiaries)}.
          Assets: \${JSON.stringify(input.assetsIncluded)}.
          Include clauses: \${clauseTexts.join("\\n\\n")}.
          Respond with final document text only.
          \`;
          
              res.setHeader("Content-Type", "text/event-stream");
              res.setHeader("Cache-Control", "no-cache");
          
              let documentText = "";
              const completion = await openai.chat.completions.create({
                model: "gpt-4-turbo",
                messages: [
                  { role: "system", content: "You are LegalGPT, an estate planning AI." },
                  { role: "user", content: prompt }
                ],
                stream: true
              });
          
              for await (const chunk of completion) {
                const text = chunk.choices[0].delta?.content || "";
                documentText += text;
                res.write(text);
              }
              res.end();
          
              await prisma.trust.update({
                where: { id: newTrust.id },
                data: { data: { text: documentText } }
              });
          
              await logAudit({
                userId: req.user.id,
                resourceType: "Trust",
                resourceId: newTrust.id,
                action: "generated_draft",
                metadata: { tokensUsed: completion.usage.total_tokens }
              });
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 3. Trust Compliance Check: backend/src/routes/trusts/compliance-check.ts
          # ----------------------------------------
          cat > src/routes/trusts/compliance-check.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          import OpenAI from "openai";
          import ApiError from "../../utils/ApiError";
          
          const router = express.Router();
          const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
          
          router.post("/compliance-check", authMiddleware, async (req, res, next) => {
            try {
              const { trustId } = req.body;
              const trust = await prisma.trust.findUnique({ where: { id: trustId } });
              if (!trust) throw new ApiError(404, "Trust not found");
          
              const prompt = \`
          You are ComplianceGPT, an attorney AI. Review the following \${trust.type} Trust for \${trust.state} compliance. Identify missing required sections or issues. Return JSON: { "pass": boolean, "issues": string[] }.
          Document:
          \${(trust.data as any).text || ""}
              \`;
          
              const response = await openai.chat.completions.create({
                model: "gpt-4-turbo",
                messages: [
                  { role: "system", content: "You are ComplianceGPT, a corporate law expert." },
                  { role: "user", content: prompt }
                ]
              });
          
              let json;
              try {
                json = JSON.parse(response.choices[0].message.content);
              } catch {
                throw new ApiError(500, "Invalid compliance response format");
              }
          
              res.json(json);
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 4. Trust Finalize Route: backend/src/routes/trusts/finalize.ts
          # ----------------------------------------
          cat > src/routes/trusts/finalize.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          import { PDFDocument } from "pdf-lib";
          import AWS from "aws-sdk";
          import logAudit from "../../middleware/auditLogger";
          import ApiError from "../../utils/ApiError";
          
          const router = express.Router();
          const s3 = new AWS.S3();
          
          router.post("/:id/finalize", authMiddleware, async (req, res, next) => {
            try {
              const trust = await prisma.trust.findUnique({ where: { id: req.params.id } });
              if (!trust) throw new ApiError(404, "Trust not found");
          
              # Generate PDF using PDFDocument from trust.data.text
              const doc = await PDFDocument.create();
              const page = doc.addPage();
              page.drawText((trust.data as any).text || "", { x: 50, y: 700, size: 12, maxWidth: 500 });
              const pdfBytes = await doc.save();
          
              const key = \`trusts/\${trust.id}.pdf\`;
              await s3
                .putObject({
                  Bucket: process.env.S3_BUCKET_NAME!,
                  Key: key,
                  Body: Buffer.from(pdfBytes),
                  ContentType: "application/pdf"
                })
                .promise();
          
              await prisma.trust.update({
                where: { id: trust.id },
                data: { status: "FINALIZED", pdfS3Key: key }
              });
          
              await prisma.vaultFile.create({
                data: {
                  userId: req.user.id,
                  folderId: await getTrustsFolderId(req.user.id), # implement helper
                  fileName: \`\${trust.trustName}.pdf\`,
                  fileType: "application/pdf",
                  size: pdfBytes.length,
                  s3Key: key
                }
              });
          
              await logAudit({
                userId: req.user.id,
                resourceType: "Trust",
                resourceId: trust.id,
                action: "finalized",
                metadata: {}
              });
          
              const presignedUrl = s3.getSignedUrl("getObject", {
                Bucket: process.env.S3_BUCKET_NAME!,
                Key: key,
                Expires: 60 * 5
              });
          
              res.json({ url: presignedUrl });
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # Return to project root
          cd ..
          
          echo "Part 4c complete: Trust routes created."
          #!/usr/bin/env bash
          set -e
          
          # ============================
          # Part 4d: Backend Routes – Entities
          # (Place under backend/src/routes)
          # ============================
          
          # Navigate into backend folder
          cd backend
          
          # ----------------------------------------
          # 1. Entity Generate Route: backend/src/routes/entities/generate.ts
          # ----------------------------------------
          mkdir -p src/routes/entities
          cat > src/routes/entities/generate.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          import { z } from "zod";
          import OpenAI from "openai";
          import logAudit from "../../middleware/auditLogger";
          import ApiError from "../../utils/ApiError";
          
          const router = express.Router();
          const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
          
          const entitySchema = z.object({
            entityName: z.string().min(3),
            type: z.enum(["LLC", "S_CORP", "C_CORP", "DBA"]),
            owners: z.array(z.object({ name: z.string(), percentage: z.number().min(0).max(100) })).min(1)
              .refine(list => list.reduce((sum, o) => sum + o.percentage, 0) === 100, { message: "Percentages must sum to 100%" }),
            registeredAgent: z.object({ name: z.string(), address: z.string() }),
            state: z.string().length(2),
            purpose: z.string().optional(),
            capital: z.array(z.object({ amount: z.number().positive(), contributionDate: z.string().optional() })).optional(),
            additionalClauses: z.array(z.string()).optional()
          });
          
          router.post("/generate", authMiddleware, async (req, res, next) => {
            try {
              const validation = entitySchema.safeParse(req.body);
              if (!validation.success) throw new ApiError(400, validation.error.errors[0].message);
          
              const input = validation.data;
              const newEntity = await prisma.entity.create({
                data: {
                  userId: req.user.id,
                  entityName: input.entityName,
                  type: input.type,
                  owners: input.owners,
                  state: input.state,
                  purpose: input.purpose,
                  capital: input.capital || [],
                  additionalClauses: input.additionalClauses || [],
                  data: {},
                  status: "DRAFT"
                }
              });
          
              const prompt = \`
          You are a corporate attorney AI. Generate Articles of Organization for a \${input.type} named \${input.entityName} in \${input.state}, owned by \${JSON.stringify(input.owners)}, registered agent \${JSON.stringify(input.registeredAgent)}, purpose \${input.purpose || "N/A"}. Include any additional clauses: \${JSON.stringify(input.additionalClauses || [])}. Provide the final document text only.
          \`;
          
              res.setHeader("Content-Type", "text/event-stream");
              res.setHeader("Cache-Control", "no-cache");
          
              let documentText = "";
              const completion = await openai.chat.completions.create({
                model: "gpt-4-turbo",
                messages: [
                  { role: "system", content: "You are ComplianceGPT, a corporate law expert." },
                  { role: "user", content: prompt }
                ],
                stream: true
              });
          
              for await (const chunk of completion) {
                const text = chunk.choices[0].delta?.content || "";
                documentText += text;
                res.write(text);
              }
              res.end();
          
              await prisma.entity.update({
                where: { id: newEntity.id },
                data: { data: { text: documentText } }
              });
          
              await logAudit({
                userId: req.user.id,
                resourceType: "Entity",
                resourceId: newEntity.id,
                action: "generated_draft",
                metadata: { tokensUsed: completion.usage.total_tokens }
              });
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 2. Entity Compliance Check: backend/src/routes/entities/compliance-check.ts
          # ----------------------------------------
          cat > src/routes/entities/compliance-check.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          import OpenAI from "openai";
          import ApiError from "../../utils/ApiError";
          
          const router = express.Router();
          const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
          
          router.post("/compliance-check", authMiddleware, async (req, res, next) => {
            try {
              const { entityId } = req.body;
              const entity = await prisma.entity.findUnique({ where: { id: entityId } });
              if (!entity) throw new ApiError(404, "Entity not found");
          
              const prompt = \`
          You are ComplianceGPT, a corporate law expert. Review the following \${entity.type} formation document for \${entity.state} compliance. Return JSON: { "pass": boolean, "issues": string[] }.
          Document:
          \${(entity.data as any).text || ""}
          \`;
          
              const response = await openai.chat.completions.create({
                model: "gpt-4-turbo",
                messages: [
                  { role: "system", content: "You are ComplianceGPT." },
                  { role: "user", content: prompt }
                ]
              });
          
              let json;
              try {
                json = JSON.parse(response.choices[0].message.content);
              } catch {
                throw new ApiError(500, "Invalid compliance response format");
              }
          
              res.json(json);
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 3. Entity Finalize Route: backend/src/routes/entities/finalize.ts
          # ----------------------------------------
          cat > src/routes/entities/finalize.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          import { PDFDocument } from "pdf-lib";
          import AWS from "aws-sdk";
          import logAudit from "../../middleware/auditLogger";
          import ApiError from "../../utils/ApiError";
          
          const router = express.Router();
          const s3 = new AWS.S3();
          
          router.post("/:id/finalize", authMiddleware, async (req, res, next) => {
            try {
              const entity = await prisma.entity.findUnique({ where: { id: req.params.id } });
              if (!entity) throw new ApiError(404, "Entity not found");
          
              const doc = await PDFDocument.create();
              const page = doc.addPage();
              page.drawText((entity.data as any).text || "", { x: 50, y: 700, size: 12, maxWidth: 500 });
              const pdfBytes = await doc.save();
          
              const key = \`entities/\${entity.id}.pdf\`;
              await s3.putObject({
                Bucket: process.env.S3_BUCKET_NAME!,
                Key: key,
                Body: Buffer.from(pdfBytes),
                ContentType: "application/pdf"
              }).promise();
          
              await prisma.entity.update({
                where: { id: entity.id },
                data: { status: "FINALIZED", pdfS3Key: key }
              });
          
              await prisma.vaultFile.create({
                data: {
                  userId: req.user.id,
                  folderId: await getEntitiesFolderId(req.user.id), # implement helper
                  fileName: \`\${entity.entityName}.pdf\`,
                  fileType: "application/pdf",
                  size: pdfBytes.length,
                  s3Key: key
                }
              });
          
              await logAudit({
                userId: req.user.id,
                resourceType: "Entity",
                resourceId: entity.id,
                action: "finalized",
                metadata: {}
              });
          
              const presignedUrl = s3.getSignedUrl("getObject", {
                Bucket: process.env.S3_BUCKET_NAME!,
                Key: key,
                Expires: 300
              });
          
              res.json({ url: presignedUrl });
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # Return to project root
          cd ..
          
          echo "Part 4d complete: Entity routes created."
          #!/usr/bin/env bash
          set -e
          
          # ============================
          # Part 4e: Backend Routes – Vault
          # (Place under backend/src/routes/vault)
          # ============================
          
          # Navigate into backend folder
          cd backend
          
          # ----------------------------------------
          # 1. Vault Folder Routes: backend/src/routes/vault/folders.ts
          # ----------------------------------------
          mkdir -p src/routes/vault
          cat > src/routes/vault/folders.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          import ApiError from "../../utils/ApiError";
          
          const router = express.Router();
          
          // GET /api/vault/folders (get full tree)
          router.get("/", authMiddleware, async (req, res, next) => {
            try {
              const folders = await prisma.vaultFolder.findMany({
                where: { userId: req.user.id },
                orderBy: { path: "asc" }
              });
              res.json(folders);
            } catch (err) {
              next(err);
            }
          });
          
          // POST /api/vault/folders (create new folder)
          router.post("/", authMiddleware, async (req, res, next) => {
            try {
              const { name, parentId } = req.body;
              const parent = parentId
                ? await prisma.vaultFolder.findUnique({ where: { id: parentId } })
                : null;
              const path = parent ? \`\${parent.path}/\${name}\` : \`/\${name}\`;
              const newFolder = await prisma.vaultFolder.create({
                data: {
                  userId: req.user.id,
                  parentId: parentId || null,
                  name,
                  path
                }
              });
              res.json(newFolder);
            } catch (err) {
              next(err);
            }
          });
          
          // PATCH /api/vault/folders/:id (rename/move)
          router.patch("/:id", authMiddleware, async (req, res, next) => {
            try {
              const { name, parentId } = req.body;
              const folder = await prisma.vaultFolder.findUnique({
                where: { id: req.params.id }
              });
              if (!folder) throw new ApiError(404, "Folder not found");
          
              let newPath = \`/\${name}\`;
              if (parentId) {
                const parent = await prisma.vaultFolder.findUnique({ where: { id: parentId } });
                if (!parent) throw new ApiError(404, "Parent not found");
                newPath = \`\${parent.path}/\${name}\`;
              }
          
              const updated = await prisma.vaultFolder.update({
                where: { id: folder.id },
                data: { name, parentId: parentId || null, path: newPath }
              });
          
              // Update paths of children recursively (implement updateChildrenPaths separately)
              await updateChildrenPaths(folder.id, newPath);
          
              res.json(updated);
            } catch (err) {
              next(err);
            }
          });
          
          // DELETE /api/vault/folders/:id
          router.delete("/:id", authMiddleware, async (req, res, next) => {
            try {
              const folder = await prisma.vaultFolder.findUnique({ where: { id: req.params.id } });
              if (!folder) throw new ApiError(404, "Folder not found");
              // Recursively delete folder and contents (implement deleteFolderRecursively separately)
              await deleteFolderRecursively(folder.id);
              res.json({ message: "Folder deleted" });
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 2. Vault File Routes: backend/src/routes/vault/files.ts
          # ----------------------------------------
          cat > src/routes/vault/files.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          import logAudit from "../../middleware/auditLogger";
          import ApiError from "../../utils/ApiError";
          
          const router = express.Router();
          
          // GET /api/vault/folders/:folderId/files
          router.get("/folders/:folderId/files", authMiddleware, async (req, res, next) => {
            try {
              const files = await prisma.vaultFile.findMany({
                where: { folderId: req.params.folderId },
                orderBy: { createdAt: "desc" }
              });
              res.json(files);
            } catch (err) {
              next(err);
            }
          });
          
          // POST /api/vault/files (after S3 PUT)
          router.post("/", authMiddleware, async (req, res, next) => {
            try {
              const { fileName, fileType, size, folderId, s3Key } = req.body;
              const file = await prisma.vaultFile.create({
                data: { userId: req.user.id, fileName, fileType, size, folderId, s3Key }
              });
              await logAudit({
                userId: req.user.id,
                resourceType: "VaultFile",
                resourceId: file.id,
                action: "uploaded",
                metadata: { folderId, fileName, size }
              });
              res.json(file);
            } catch (err) {
              next(err);
            }
          });
          
          // GET /api/vault/files/:fileId/download-url
          router.get("/files/:fileId/download-url", authMiddleware, async (req, res, next) => {
            try {
              const file = await prisma.vaultFile.findUnique({
                where: { id: req.params.fileId }
              });
              if (!file) throw new ApiError(404, "File not found");
              const s3 = new (require("aws-sdk")).S3();
              const url = s3.getSignedUrl("getObject", {
                Bucket: process.env.S3_BUCKET_NAME!,
                Key: file.s3Key,
                Expires: 300
              });
              await logAudit({
                userId: req.user.id,
                resourceType: "VaultFile",
                resourceId: file.id,
                action: "downloaded",
                metadata: {}
              });
              res.json({ url });
            } catch (err) {
              next(err);
            }
          });
          
          // PATCH /api/vault/files/:fileId
          router.patch("/files/:fileId", authMiddleware, async (req, res, next) => {
            try {
              const { fileName, folderId } = req.body;
              const file = await prisma.vaultFile.findUnique({
                where: { id: req.params.fileId }
              });
              if (!file) throw new ApiError(404, "File not found");
          
              const updated = await prisma.vaultFile.update({
                where: { id: file.id },
                data: {
                  fileName: fileName || file.fileName,
                  folderId: folderId || file.folderId
                }
              });
          
              await logAudit({
                userId: req.user.id,
                resourceType: "VaultFile",
                resourceId: file.id,
                action: folderId ? "moved" : "renamed",
                metadata: {
                  oldFileName: file.fileName,
                  newFileName: updated.fileName,
                  newFolderId: folderId
                }
              });
          
              res.json(updated);
            } catch (err) {
              next(err);
            }
          });
          
          // DELETE /api/vault/files
          router.delete("/files", authMiddleware, async (req, res, next) => {
            try {
              const { fileIds } = req.body; // array of IDs
              if (!Array.isArray(fileIds)) throw new ApiError(400, "fileIds must be an array");
          
              const files = await prisma.vaultFile.findMany({
                where: { id: { in: fileIds } }
              });
              if (files.length === 0) throw new ApiError(404, "No files found");
          
              // Delete from S3 and DB
              const s3 = new (require("aws-sdk")).S3();
              await Promise.all(
                files.map((f) =>
                  s3.deleteObject({ Bucket: process.env.S3_BUCKET_NAME!, Key: f.s3Key }).promise()
                )
              );
              await prisma.vaultFile.deleteMany({ where: { id: { in: fileIds } } });
          
              await Promise.all(
                files.map((f) =>
                  logAudit({
                    userId: req.user.id,
                    resourceType: "VaultFile",
                    resourceId: f.id,
                    action: "deleted",
                    metadata: {}
                  })
                )
              );
          
              res.json({ message: "Files deleted" });
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 3. Vault Upload URL: backend/src/routes/vault/upload-url.ts
          # ----------------------------------------
          cat > src/routes/vault/upload-url.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import { v4 as uuidv4 } from "uuid";
          import AWS from "aws-sdk";
          
          const router = express.Router();
          const s3 = new AWS.S3();
          
          // POST /api/vault/upload-url
          router.post("/upload-url", authMiddleware, async (req, res, next) => {
            try {
              const { fileName, fileType, size } = req.body;
              const key = \`vault/\${req.user.id}/\${uuidv4()}-\${fileName}\`;
              const url = s3.getSignedUrl("putObject", {
                Bucket: process.env.S3_BUCKET_NAME!,
                Key: key,
                ContentType: fileType,
                Expires: 300
              });
              res.json({ key, url });
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 4. Vault Export: backend/src/routes/vault/export.ts
          # ----------------------------------------
          cat > src/routes/vault/export.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          import archiver from "archiver";
          import AWS from "aws-sdk";
          import ApiError from "../../utils/ApiError";
          
          const router = express.Router();
          const s3 = new AWS.S3();
          
          // POST /api/vault/export
          router.post("/export", authMiddleware, async (req, res, next) => {
            try {
              const { fileIds } = req.body;
              if (!Array.isArray(fileIds)) throw new ApiError(400, "fileIds must be an array");
          
              const files = await prisma.vaultFile.findMany({
                where: { id: { in: fileIds } }
              });
              if (files.length === 0) throw new ApiError(404, "No files found");
          
              res.setHeader("Content-Type", "application/zip");
              res.setHeader("Content-Disposition", 'attachment; filename="vault_export.zip"');
          
              const archive = archiver("zip");
              archive.on("error", (err) => next(err));
              archive.pipe(res);
          
              for (const file of files) {
                const s3Stream = s3
                  .getObject({ Bucket: process.env.S3_BUCKET_NAME!, Key: file.s3Key })
                  .createReadStream();
                archive.append(s3Stream, { name: file.fileName });
              }
          
              await archive.finalize();
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 5. Vault Emergency Access: backend/src/routes/vault/emergency.ts
          # ----------------------------------------
          cat > src/routes/vault/emergency.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          import { v4 as uuidv4 } from "uuid";
          import sendEmail from "../../config/email";
          import ApiError from "../../utils/ApiError";
          
          const router = express.Router();
          
          // POST /api/vault/emergency
          router.post("/", authMiddleware, async (req, res, next) => {
            try {
              const { folderId, granteeEmail, expiresAt } = req.body;
              const folder = await prisma.vaultFolder.findUnique({ where: { id: folderId } });
              if (!folder || folder.userId !== req.user.id) throw new ApiError(404, "Folder not found");
          
              const grantee = await prisma.user.findUnique({ where: { email: granteeEmail } });
              if (!grantee) throw new ApiError(400, "Grantee must have a Legacy Pro account");
          
              const code = uuidv4().slice(0, 8);
              const emergency = await prisma.emergencyAccess.create({
                data: {
                  folderId,
                  granteeUserId: grantee.id,
                  expiresAt: new Date(expiresAt),
                  code
                }
              });
          
              const link = \`\${process.env.FRONTEND_URL}/emergency/\${code}\`;
              await sendEmail({
                to: granteeEmail,
                subject: "Legacy Pro Emergency Access Granted",
                html: \`<p>You have been granted emergency access to folder <strong>\${folder.path}</strong>. View here: <a href="\${link}">\${link}</a>. This link expires on \${new Date(expiresAt).toDateString()}.</p>\`
              });
          
              res.json({ message: "Emergency access granted" });
            } catch (err) {
              next(err);
            }
          });
          
          // GET /api/vault/emergency/:code
          router.get("/:code", async (req, res, next) => {
            try {
              const access = await prisma.emergencyAccess.findUnique({ where: { code: req.params.code } });
              if (!access || new Date(access.expiresAt) < new Date()) {
                return res.status(410).json({ error: "Access expired or invalid" });
              }
              const files = await prisma.vaultFile.findMany({ where: { folderId: access.folderId } });
              const s3 = new (require("aws-sdk")).S3();
              const filesWithUrls = files.map((f) => {
                const url = s3.getSignedUrl("getObject", {
                  Bucket: process.env.S3_BUCKET_NAME!,
                  Key: f.s3Key,
                  Expires: 300
                });
                return { id: f.id, fileName: f.fileName, url };
              });
              res.json({ files: filesWithUrls });
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # Return to project root
          cd ..
          
          echo "Part 4e complete: Vault routes created."
          #!/usr/bin/env bash
          set -e
          
          # ============================
          # Part 4f: Backend Routes & Jobs – Remaining
          # (Place under backend/src/routes and backend/src/jobs)
          # ============================
          
          # Navigate into backend folder
          cd backend
          
          # ----------------------------------------
          # 1. Search Route: backend/src/routes/search/index.ts
          # ----------------------------------------
          mkdir -p src/routes/search
          cat > src/routes/search/index.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          
          const router = express.Router();
          
          // GET /api/search?q=...
          router.get("/", authMiddleware, async (req, res, next) => {
            try {
              const { q } = req.query;
              if (!q || typeof q !== "string") return res.status(400).json({ error: "Query is required." });
              const formattedQuery = q.trim().replace(/[^a-zA-Z0-9 ]/g, "");
              const tsQuery = formattedQuery.split(" ").join(" & ");
          
              const trusts = await prisma.$queryRaw\`
                SELECT id, "trustName" AS title, 'Trust' AS type
                FROM "Trust"
                WHERE to_tsvector("textSearch") @@ plainto_tsquery(\${tsQuery})
                LIMIT 5;
              \`;
              const entities = await prisma.$queryRaw\`
                SELECT id, "entityName" AS title, 'Entity' AS type
                FROM "Entity"
                WHERE to_tsvector("textSearch") @@ plainto_tsquery(\${tsQuery})
                LIMIT 5;
              \`;
              const files = await prisma.$queryRaw\`
                SELECT id, "fileName" AS title, 'VaultFile' AS type
                FROM "VaultFile"
                WHERE to_tsvector("fileName") @@ plainto_tsquery(\${tsQuery})
                LIMIT 5;
              \`;
          
              res.json({ results: [...trusts, ...entities, ...files] });
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 2. AI Advisor Route: backend/src/routes/ai/advisor.ts
          # ----------------------------------------
          mkdir -p src/routes/ai
          cat > src/routes/ai/advisor.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          import OpenAI from "openai";
          import logAudit from "../../middleware/auditLogger";
          import ApiError from "../../utils/ApiError";
          
          const router = express.Router();
          const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
          
          // POST /api/ai/advisor
          router.post("/", authMiddleware, async (req, res, next) => {
            try {
              const { message } = req.body;
              if (!message) throw new ApiError(400, "Message is required");
          
              // Check token quota for last 30 days
              const usage = await prisma.aIUsageLog.aggregate({
                where: { userId: req.user.id, feature: "Advisor", createdAt: { gt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) } },
                _sum: { tokensUsed: true }
              });
              const used = usage._sum.tokensUsed || 0;
              const plan = await prisma.userSubscription.findFirst({ where: { userId: req.user.id }, include: { plan: true } });
              const tokenLimit = plan?.plan.priceCents! * 100;
              if (used >= tokenLimit) throw new ApiError(402, "Quota exceeded");
          
              res.setHeader("Content-Type", "text/event-stream");
              res.setHeader("Cache-Control", "no-cache");
          
              let aiText = "";
              const completion = await openai.chat.completions.create({
                model: "gpt-4-turbo",
                messages: [
                  { role: "system", content: "You are Ava, a friendly legal and legacy planning advisor." },
                  { role: "user", content: message }
                ],
                stream: true
              });
          
              for await (const chunk of completion) {
                const text = chunk.choices[0].delta?.content || "";
                aiText += text;
                res.write(text);
              }
              res.end();
          
              await prisma.aIUsageLog.create({
                data: {
                  userId: req.user.id,
                  feature: "Advisor",
                  tokensUsed: completion.usage.total_tokens,
                  promptHash: hashPrompt(message) // implement hashPrompt separately
                }
              });
          
              await logAudit({
                userId: req.user.id,
                resourceType: "User",
                resourceId: req.user.id,
                action: "ai_advisor",
                metadata: { tokensUsed: completion.usage.total_tokens }
              });
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 3. Legacy Letter Routes: backend/src/routes/legacy-letter
          # ----------------------------------------
          mkdir -p src/routes/legacy-letter
          
          # 3a. Generate
          cat > src/routes/legacy-letter/generate.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          import OpenAI from "openai";
          import logAudit from "../../middleware/auditLogger";
          import ApiError from "../../utils/ApiError";
          
          const router = express.Router();
          const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
          
          // POST /api/legacy-letter/generate
          router.post("/generate", authMiddleware, async (req, res, next) => {
            try {
              const { tone, recipients, attachedDocs } = req.body;
              if (!tone || !recipients || !Array.isArray(recipients)) throw new ApiError(400, "Invalid input");
          
              const newLetter = await prisma.legacyLetter.create({
                data: {
                  userId: req.user.id,
                  tone,
                  recipients,
                  attachedDocs,
                  status: "DRAFT"
                }
              });
          
              // Fetch summaries of attached documents (implement getDocSummary separately)
              const docsData = await Promise.all(
                attachedDocs.map(async (key: string) => {
                  return await getDocSummary(key);
                })
              );
          
              const prompt = \`
          You are an estate planning advisor AI. Draft a \${tone} legacy letter addressed to \${recipients.join(", ")}. Summaries: \${JSON.stringify(docsData)}. Provide final letter text.
          \`;
          
              res.setHeader("Content-Type", "text/event-stream");
              res.setHeader("Cache-Control", "no-cache");
          
              let letterText = "";
              const completion = await openai.chat.completions.create({
                model: "gpt-4-turbo",
                messages: [
                  { role: "system", content: "You are ComplianceGPT, a legal advisor." },
                  { role: "user", content: prompt }
                ],
                stream: true
              });
          
              for await (const chunk of completion) {
                const text = chunk.choices[0].delta?.content || "";
                letterText += text;
                res.write(text);
              }
              res.end();
          
              await prisma.legacyLetter.update({
                where: { id: newLetter.id },
                data: { body: letterText }
              });
          
              await logAudit({
                userId: req.user.id,
                resourceType: "LegacyLetter",
                resourceId: newLetter.id,
                action: "generated_draft",
                metadata: { tokensUsed: completion.usage.total_tokens }
              });
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # 3b. Compliance Check
          cat > src/routes/legacy-letter/compliance-check.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          import OpenAI from "openai";
          import ApiError from "../../utils/ApiError";
          
          const router = express.Router();
          const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
          
          // POST /api/legacy-letter/compliance-check
          router.post("/compliance-check", authMiddleware, async (req, res, next) => {
            try {
              const { letterId } = req.body;
              const letter = await prisma.legacyLetter.findUnique({ where: { id: letterId } });
              if (!letter) throw new ApiError(404, "Letter not found");
          
              const prompt = \`
          You are ComplianceGPT. Review this legacy letter for legal completeness and tone. Return JSON: { "pass": boolean, "issues": [string] }.
          Letter:
          \${letter.body}
          \`;
          
              const response = await openai.chat.completions.create({
                model: "gpt-4-turbo",
                messages: [
                  { role: "system", content: "You are ComplianceGPT." },
                  { role: "user", content: prompt }
                ]
              });
          
              let json;
              try {
                json = JSON.parse(response.choices[0].message.content);
              } catch {
                throw new ApiError(500, "Invalid compliance response format");
              }
          
              res.json(json);
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # 3c. Finalize
          cat > src/routes/legacy-letter/finalize.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          import { PDFDocument } from "pdf-lib";
          import AWS from "aws-sdk";
          import logAudit from "../../middleware/auditLogger";
          import ApiError from "../../utils/ApiError";
          
          const router = express.Router();
          const s3 = new AWS.S3();
          
          // POST /api/legacy-letter/:id/finalize
          router.post("/:id/finalize", authMiddleware, async (req, res, next) => {
            try {
              const letter = await prisma.legacyLetter.findUnique({ where: { id: req.params.id } });
              if (!letter) throw new ApiError(404, "Letter not found");
          
              const doc = await PDFDocument.create();
              const page = doc.addPage();
              page.drawText(letter.body, { x: 50, y: 700, size: 12, maxWidth: 500 });
              const pdfBytes = await doc.save();
          
              const key = \`legacy-letters/\${letter.id}.pdf\`;
              await s3.putObject({
                Bucket: process.env.S3_BUCKET_NAME!,
                Key: key,
                Body: Buffer.from(pdfBytes),
                ContentType: "application/pdf"
              }).promise();
          
              await prisma.legacyLetter.update({
                where: { id: letter.id },
                data: { status: "FINALIZED", pdfS3Key: key }
              });
          
              await prisma.vaultFile.create({
                data: {
                  userId: req.user.id,
                  folderId: await getLegacyLettersFolderId(req.user.id), # implement helper
                  fileName: \`LegacyLetter_\${letter.id}.pdf\`,
                  fileType: "application/pdf",
                  size: pdfBytes.length,
                  s3Key: key
                }
              });
          
              await logAudit({
                userId: req.user.id,
                resourceType: "LegacyLetter",
                resourceId: letter.id,
                action: "finalized",
                metadata: {}
              });
          
              const presignedUrl = s3.getSignedUrl("getObject", {
                Bucket: process.env.S3_BUCKET_NAME!,
                Key: key,
                Expires: 300
              });
          
              res.json({ url: presignedUrl });
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 4. Protection Score Route: backend/src/routes/protection-score/index.ts
          # ----------------------------------------
          mkdir -p src/routes/protection-score
          cat > src/routes/protection-score/index.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          
          const router = express.Router();
          
          // GET /api/protection-score
          router.get("/", authMiddleware, async (req, res, next) => {
            try {
              const userId = req.user.id;
              let breakdown = { trust: 0, entity: 0, vault: 0, security: 0, financial: 0 };
              const suggestions: string[] = [];
          
              // Trust
              const trust = await prisma.trust.findFirst({ where: { userId, status: "FINALIZED" } });
              if (trust) {
                breakdown.trust += 10;
                const sectionsCompleted = [
                  trust.trustName,
                  trust.grantor,
                  (trust.trustees as any[]).length > 0,
                  (trust.beneficiaries as any[]).length > 0,
                  trust.state,
                  (trust.additionalClauses as string[]).length > 0,
                  (trust.assetsIncluded as any[]).length > 0
                ].filter(Boolean).length;
                breakdown.trust += Math.min((sectionsCompleted - 1) * 5, 20);
              } else suggestions.push("Create and finalize a Trust.");
          
              // Entity
              const entity = await prisma.entity.findFirst({ where: { userId, status: "FINALIZED" } });
              if (entity) {
                breakdown.entity += 10;
                const entitySections = [
                  entity.entityName,
                  (entity.owners as any[]).length > 0,
                  entity.registeredAgent,
                  entity.state
                ].filter(Boolean).length;
                breakdown.entity += Math.min((entitySections - 1) * 2.5, 10);
              } else suggestions.push("Create and finalize an Entity.");
          
              // Vault Coverage
              const requiredDocs = ["Will", "Power of Attorney", "Advance Directives", "Guardianship", "Password Vault"];
              const userFiles = await prisma.vaultFile.findMany({ where: { userId } });
              requiredDocs.forEach((doc) => {
                const hasDoc = userFiles.some((f) => f.fileName.includes(doc));
                if (hasDoc) breakdown.vault += 5;
                else suggestions.push(\`Upload your \${doc}.\`);
              });
          
              // Security Settings
              const user = await prisma.user.findUnique({ where: { id: userId } });
              if (user?.twoFAEnabled) breakdown.security += 5;
              else suggestions.push("Enable Two-Factor Authentication.");
          
              const checkIns = await prisma.userCheckIn.findMany({ where: { userId } });
              if (checkIns.length > 0) breakdown.security += 5;
              else suggestions.push("Set up a scheduled check-in.");
          
              const emergencyAccess = await prisma.emergencyAccess.findFirst({
                where: { folder: { userId } }
              });
              if (emergencyAccess) breakdown.security += 5;
              else suggestions.push("Grant emergency access.");
          
              // Financial Hub
              const finAccounts = await prisma.financialAccount.findMany({ where: { userId } });
              if (finAccounts.length > 0) breakdown.financial += 5;
              else suggestions.push("Connect a financial account.");
          
              const score = Object.values(breakdown).reduce((sum, val) => sum + val, 0);
              res.json({ score, breakdown, suggestions });
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 5. Dashboard Reporting Routes: backend/src/routes/dashboard/reporting.ts
          # ----------------------------------------
          mkdir -p src/routes/dashboard
          cat > src/routes/dashboard/reporting.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          
          const router = express.Router();
          
          // GET /api/dashboard/metrics/users
          router.get("/metrics/users", authMiddleware, async (req, res, next) => {
            try {
              const growth = await prisma.$queryRaw\`
                SELECT to_char("createdAt", 'YYYY-MM') AS month, COUNT(*) AS count
                FROM "User"
                GROUP BY month
                ORDER BY month DESC
                LIMIT 12;
              \`;
              const totalUsers = await prisma.user.count();
              res.json({ growth, totalUsers });
            } catch (err) {
              next(err);
            }
          });
          
          // GET /api/dashboard/metrics/subscriptions
          router.get("/metrics/subscriptions", authMiddleware, async (req, res, next) => {
            try {
              const byPlanRaw = await prisma.$queryRaw\`
                SELECT "planId", COUNT(*) AS count
                FROM "UserSubscription"
                WHERE status = 'ACTIVE'
                GROUP BY "planId";
              \`;
              const byPlan = {};
              for (const row of byPlanRaw as any[]) {
                const plan = await prisma.subscriptionPlan.findUnique({ where: { id: row.planId } });
                byPlan[plan!.name] = parseInt(row.count);
              }
              const lastMonth = new Date();
              lastMonth.setMonth(lastMonth.getMonth() - 1);
              const canceledLastMonth = await prisma.userSubscription.count({
                where: { status: "CANCELED", updatedAt: { gte: lastMonth } }
              });
              const activeAtStart = await prisma.userSubscription.count({
                where: { updatedAt: { lte: lastMonth }, status: "ACTIVE" }
              });
              const churnRate = activeAtStart ? canceledLastMonth / activeAtStart : 0;
              res.json({ byPlan, churnRate });
            } catch (err) {
              next(err);
            }
          });
          
          // GET /api/dashboard/metrics/vault
          router.get("/metrics/vault", authMiddleware, async (req, res, next) => {
            try {
              const monthlyUsage = await prisma.$queryRaw\`
                SELECT to_char("createdAt", 'YYYY-MM') AS month, SUM(size) AS bytes
                FROM "VaultFile"
                GROUP BY month
                ORDER BY month DESC
                LIMIT 12;
              \`;
              res.json({ monthlyUsage });
            } catch (err) {
              next(err);
            }
          });
          
          // GET /api/dashboard/metrics/api-usage
          router.get("/metrics/api-usage", authMiddleware, async (req, res, next) => {
            try {
              const usageRaw = await prisma.aIUsageLog.groupBy({
                by: ["feature"],
                _sum: { tokensUsed: true }
              });
              const callsByFeature = {};
              (usageRaw as any[]).forEach((u) => {
                callsByFeature[u.feature] = u._sum.tokensUsed;
              });
              const errorRate = 0.015;
              res.json({ callsByFeature, errorRate });
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 6. Admin Metrics & Audit Logs: backend/src/routes/admin/metrics.ts
          # ----------------------------------------
          mkdir -p src/routes/admin
          cat > src/routes/admin/metrics.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          
          const router = express.Router();
          
          // GET /api/admin/metrics/users
          router.get("/metrics/users", authMiddleware, async (req, res, next) => {
            try {
              if (req.user.role !== "ADMIN") return res.status(403).json({ error: "Forbidden" });
              const growth = await prisma.$queryRaw\`
                SELECT to_char("createdAt", 'YYYY-MM') AS month, COUNT(*) AS count
                FROM "User"
                GROUP BY month
                ORDER BY month DESC
                LIMIT 12;
              \`;
              const totalUsers = await prisma.user.count();
              res.json({ growth, totalUsers });
            } catch (err) {
              next(err);
            }
          });
          
          // GET /api/admin/metrics/subscriptions
          router.get("/metrics/subscriptions", authMiddleware, async (req, res, next) => {
            try {
              if (req.user.role !== "ADMIN") return res.status(403).json({ error: "Forbidden" });
              const byPlanRaw = await prisma.$queryRaw\`
                SELECT "planId", COUNT(*) AS count
                FROM "UserSubscription"
                WHERE status = 'ACTIVE'
                GROUP BY "planId";
              \`;
              const byPlan = {};
              for (const row of byPlanRaw as any[]) {
                const plan = await prisma.subscriptionPlan.findUnique({ where: { id: row.planId } });
                byPlan[plan!.name] = parseInt(row.count);
              }
              const lastMonth = new Date();
              lastMonth.setMonth(lastMonth.getMonth() - 1);
              const canceledLastMonth = await prisma.userSubscription.count({
                where: { status: "CANCELED", updatedAt: { gte: lastMonth } }
              });
              const activeAtStart = await prisma.userSubscription.count({
                where: { updatedAt: { lte: lastMonth }, status: "ACTIVE" }
              });
              const churnRate = activeAtStart ? canceledLastMonth / activeAtStart : 0;
              res.json({ byPlan, churnRate });
            } catch (err) {
              next(err);
            }
          });
          
          // GET /api/admin/metrics/vault
          router.get("/metrics/vault", authMiddleware, async (req, res, next) => {
            try {
              if (req.user.role !== "ADMIN") return res.status(403).json({ error: "Forbidden" });
              const monthlyUsage = await prisma.$queryRaw\`
                SELECT to_char("createdAt", 'YYYY-MM') AS month, SUM(size) AS bytes
                FROM "VaultFile"
                GROUP BY month
                ORDER BY month DESC
                LIMIT 12;
              \`;
              res.json({ monthlyUsage });
            } catch (err) {
              next(err);
            }
          });
          
          // GET /api/admin/metrics/api-usage
          router.get("/metrics/api-usage", authMiddleware, async (req, res, next) => {
            try {
              if (req.user.role !== "ADMIN") return res.status(403).json({ error: "Forbidden" });
              const usageRaw = await prisma.aIUsageLog.groupBy({
                by: ["feature"],
                _sum: { tokensUsed: true }
              });
              const callsByFeature = {};
              (usageRaw as any[]).forEach((u) => {
                callsByFeature[u.feature] = u._sum.tokensUsed;
              });
              const errorRate = 0.015;
              res.json({ callsByFeature, errorRate });
            } catch (err) {
              next(err);
            }
          });
          
          // GET /api/admin/audit-logs
          router.get("/audit-logs", authMiddleware, async (req, res, next) => {
            try {
              if (req.user.role !== "ADMIN") return res.status(403).json({ error: "Forbidden" });
              const { resourceType, resourceId, userId, action, from, to, page = 1, limit = 50 } = req.query;
              const where: any = {};
              if (resourceType) where.resourceType = resourceType;
              if (resourceId) where.resourceId = resourceId;
              if (userId) where.userId = userId;
              if (action) where.action = action;
              if (from && to) {
                where.timestamp = { gte: new Date(from as string), lte: new Date(to as string) };
              }
              const logs = await prisma.auditLog.findMany({
                where,
                skip: (Number(page) - 1) * Number(limit),
                take: Number(limit),
                orderBy: { timestamp: "desc" },
                include: { user: true }
              });
              res.json(logs);
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 7. Notifications Route: backend/src/routes/notifications/index.ts
          # ----------------------------------------
          mkdir -p src/routes/notifications
          cat > src/routes/notifications/index.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          
          const router = express.Router();
          
          // GET /api/notifications
          router.get("/", authMiddleware, async (req, res, next) => {
            try {
              const notifications = await prisma.notification.findMany({
                where: { userId: req.user.id },
                orderBy: { createdAt: "desc" }
              });
              res.json(notifications);
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 8. Push Notifications Send: backend/src/routes/push-notifications/send.ts
          # ----------------------------------------
          mkdir -p src/routes/push-notifications
          cat > src/routes/push-notifications/send.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          import admin from "firebase-admin";
          import ApiError from "../../utils/ApiError";
          
          const router = express.Router();
          
          // Initialize Firebase Admin
          if (!admin.apps.length) {
            admin.initializeApp({
              credential: admin.credential.cert(JSON.parse(process.env.FCM_SERVICE_ACCOUNT!))
            });
          }
          
          // POST /api/push-notifications/send
          router.post("/send", authMiddleware, async (req, res, next) => {
            try {
              const { title, body } = req.body;
              const tokens = await prisma.pushToken.findMany({ where: { userId: req.user.id } });
              if (tokens.length === 0) throw new ApiError(400, "No push tokens registered");
          
              const payload = { notification: { title, body } };
              const response = await admin.messaging().sendToDevice(tokens.map((t) => t.token), payload);
              res.json({ success: true, results: response.results });
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # ----------------------------------------
          # 9. Job: backend/src/jobs/regulatoryAlerts.ts
          # ----------------------------------------
          mkdir -p src/jobs
          cat > src/jobs/regulatoryAlerts.ts << 'EOF'
          import prisma from "../../prismaClient";
          import sendEmail from "../config/email";
          import sendSMS from "../config/sms";
          import logAudit from "../middleware/auditLogger";
          
          // This job runs daily to check for regulatory updates.
          export default async function regulatoryAlerts() {
            // Assume we have a table PendingRegChange with fields { state, description, effectiveDate }
            const today = new Date();
            const changes = await prisma.pendingRegChange.findMany({
              where: { effectiveDate: today }
            });
          
            for (const change of changes) {
              const users = await prisma.trust.findMany({
                where: { state: change.state },
                distinct: ["userId"],
                select: { userId: true }
              });
          
              for (const { userId } of users) {
                const notification = await prisma.notification.create({
                  data: {
                    userId,
                    type: "RegulatoryUpdate",
                    content: { message: \`\${change.state} law update: \${change.description}\` }
                  }
                });
          
                // Send email if preference enabled
                const pref = await prisma.notificationPreference.findUnique({
                  where: { userId_type: { userId, type: "RegulatoryUpdate" } }
                });
                const user = await prisma.user.findUnique({ where: { id: userId } });
                if (pref?.enabled && user?.email) {
                  await sendEmail({
                    to: user.email,
                    subject: "Regulatory Update",
                    html: \`<p>\${change.state} law update: \${change.description}</p>\`
                  });
                }
          
                await logAudit({
                  userId,
                  resourceType: "Notification",
                  resourceId: notification.id,
                  action: "created",
                  metadata: { changeId: change.id }
                });
              }
            }
          }
          EOF
          
          # ----------------------------------------
          # 10. Job: backend/src/jobs/checkInScheduler.ts
          # ----------------------------------------
          cat > src/jobs/checkInScheduler.ts << 'EOF'
          import prisma from "../../prismaClient";
          import sendEmail from "../config/email";
          import admin from "firebase-admin";
          import logAudit from "../middleware/auditLogger";
          
          // Initialize Firebase Admin
          if (!admin.apps.length) {
            admin.initializeApp({
              credential: admin.credential.cert(JSON.parse(process.env.FCM_SERVICE_ACCOUNT!))
            });
          }
          
          export default async function checkInScheduler() {
            const now = new Date();
            const dueCheckIns = await prisma.userCheckIn.findMany({
              where: { nextDate: { lte: now } }
            });
          
            for (const checkIn of dueCheckIns) {
              const userId = checkIn.userId;
              const notification = await prisma.notification.create({
                data: {
                  userId,
                  type: "CheckInReminder",
                  content: { message: "Time to review your estate plan." }
                }
              });
          
              const user = await prisma.user.findUnique({ where: { id: userId } });
              // Send email if enabled
              const pref = await prisma.notificationPreference.findUnique({
                where: { userId_type: { userId, type: "CheckInReminder" } }
              });
              if (pref?.enabled && user?.email) {
                await sendEmail({
                  to: user.email,
                  subject: "Legacy Pro Check-In Reminder",
                  html: "<p>Time to review your estate plan.</p>"
                });
              }
          
              // Send push notification
              const tokens = await prisma.pushToken.findMany({ where: { userId } });
              if (tokens.length > 0) {
                const payload = { notification: { title: "Check-In Reminder", body: "Time to review your estate plan." } };
                await admin.messaging().sendToDevice(tokens.map((t) => t.token), payload);
              }
          
              // Update nextDate
              let newNextDate = new Date(checkIn.nextDate);
              switch (checkIn.frequency) {
                case "DAILY":
                  newNextDate.setDate(newNextDate.getDate() + 1);
                  break;
                case "WEEKLY":
                  newNextDate.setDate(newNextDate.getDate() + 7);
                  break;
                case "MONTHLY":
                  newNextDate.setMonth(newNextDate.getMonth() + 1);
                  break;
              }
          
              await prisma.userCheckIn.update({
                where: { id: checkIn.id },
                data: { lastSent: now, nextDate: newNextDate }
              });
          
              await logAudit({
                userId,
                resourceType: "UserCheckIn",
                resourceId: checkIn.id,
                action: "reminder_sent",
                metadata: {}
              });
            }
          }
          EOF
          
          # Return to project root
          cd ..
          
          echo "Part 4f complete: Remaining backend routes and job files created."
          #!/usr/bin/env bash
          set -e
          
          # ============================
          # Part 5: Frontend Project Setup (Next.js + Tailwind + Dependencies)
          # (Creates basic project config and directory structure)
          # ============================
          
          # Create frontend directory
          mkdir -p frontend
          cd frontend
          
          # ----------------------------
          # 1. package.json
          # ----------------------------
          cat > package.json << 'EOF'
          {
            "name": "legacy-pro-frontend",
            "version": "1.0.0",
            "private": true,
            "scripts": {
              "dev": "next dev -p 3000",
              "build": "next build",
              "start": "next start -p 3000",
              "lint": "next lint"
            },
            "dependencies": {
              "react": "18.2.0",
              "react-dom": "18.2.0",
              "next": "13.4.0",
              "axios": "^1.2.0",
              "swr": "^2.0.1",
              "next-auth": "^4.18.0",
              "tailwindcss": "^3.2.0",
              "postcss": "^8.4.0",
              "autoprefixer": "^10.4.0",
              "shadcn-ui": "^1.0.0",
              "lucide-react": "^0.257.0",
              "recharts": "^2.1.9",
              "framer-motion": "^7.6.0"
            },
            "devDependencies": {
              "typescript": "^4.9.0",
              "@types/react": "^18.0.26",
              "@types/node": "^18.7.18",
              "eslint": "8.23.0",
              "eslint-config-next": "13.4.0",
              "@types/lodash": "^4.14.182"
            }
          }
          EOF
          
          # ----------------------------
          # 2. tsconfig.json
          # ----------------------------
          cat > tsconfig.json << 'EOF'
          {
            "compilerOptions": {
              "target": "ESNext",
              "lib": ["dom", "dom.iterable", "esnext"],
              "allowJs": true,
              "skipLibCheck": true,
              "strict": true,
              "forceConsistentCasingInFileNames": true,
              "noEmit": true,
              "esModuleInterop": true,
              "module": "ESNext",
              "moduleResolution": "Node",
              "resolveJsonModule": true,
              "isolatedModules": true,
              "jsx": "preserve",
              "incremental": true,
              "types": ["node", "babel-plugin-tailwindcss"]
            },
            "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
            "exclude": ["node_modules"]
          }
          EOF
          
          # ----------------------------
          # 3. next.config.js
          # ----------------------------
          cat > next.config.js << 'EOF'
          /** @type {import('next').NextConfig} */
          const nextConfig = {
            reactStrictMode: true,
            env: {
              NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL
            },
            images: {
              domains: ['*']
            }
          };
          
          module.exports = nextConfig;
          EOF
          
          # ----------------------------
          # 4. tailwind.config.js
          # ----------------------------
          cat > tailwind.config.js << 'EOF'
          /** @type {import('tailwindcss').Config} */
          module.exports = {
            content: [
              "./pages/**/*.{js,ts,jsx,tsx}",
              "./components/**/*.{js,ts,jsx,tsx}"
            ],
            theme: {
              extend: {}
            },
            plugins: []
          };
          EOF
          
          # ----------------------------
          # 5. postcss.config.js
          # ----------------------------
          cat > postcss.config.js << 'EOF'
          module.exports = {
            plugins: {
              tailwindcss: {},
              autoprefixer: {}
            }
          };
          EOF
          
          # ----------------------------
          # 6. Global CSS: styles/globals.css
          # ----------------------------
          mkdir -p styles
          cat > styles/globals.css << 'EOF'
          @tailwind base;
          @tailwind components;
          @tailwind utilities;
          
          /* Custom global styles */
          body {
            background-color: #f9fafb;
            color: #1f2937;
          }
          EOF
          
          # ----------------------------
          # 7. Create directories for pages, components, public, and assets
          # ----------------------------
          mkdir -p pages/api \
                   pages/auth \
                   pages/dashboard \
                   pages/trust-builder \
                   pages/entity-builder \
                   pages/legacy-letter \
                   pages/vault \
                   pages/settings \
                   pages/emergency \
                   pages/admin \
                   pages/notifications \
                   components/ui \
                   components/layout \
                   components/auth \
                   components/dashboard \
                   components/vault \
                   components/forms \
                   public/assets
          
          # ----------------------------
          # 8. _app.tsx: pages/_app.tsx
          # ----------------------------
          cat > pages/_app.tsx << 'EOF'
          import "../styles/globals.css";
          import type { AppProps } from "next/app";
          import { SessionProvider } from "next-auth/react";
          import Layout from "../components/layout/Layout";
          
          function MyApp({ Component, pageProps: { session, ...pageProps } }: AppProps) {
            return (
              <SessionProvider session={session}>
                <Layout>
                  <Component {...pageProps} />
                </Layout>
              </SessionProvider>
            );
          }
          
          export default MyApp;
          EOF
          
          # ----------------------------
          # 9. _document.tsx: pages/_document.tsx
          # ----------------------------
          cat > pages/_document.tsx << 'EOF'
          import Document, { Html, Head, Main, NextScript, DocumentContext } from "next/document";
          
          class MyDocument extends Document {
            static async getInitialProps(ctx: DocumentContext) {
              const initialProps = await Document.getInitialProps(ctx);
              return { ...initialProps };
            }
          
            render() {
              return (
                <Html lang="en">
                  <Head>
                    <link rel="icon" href="/favicon.ico" />
                    <meta name="viewport" content="width=device-width, initial-scale=1" />
                  </Head>
                  <body>
                    <Main />
                    <NextScript />
                  </body>
                </Html>
              );
            }
          }
          
          export default MyDocument;
          EOF
          
          # ----------------------------
          # 10. .env.local template
          # ----------------------------
          cat > .env.local << 'EOF'
          # Replace with your backend URL, e.g. http://localhost:4000
          NEXT_PUBLIC_API_URL=http://localhost:4000
          
          # NextAuth secret (should match backend NEXTAUTH_SECRET)
          NEXTAUTH_SECRET=your_nextauth_secret_here
          EOF
          
          # Return to project root
          cd ..
          
          echo "Part 5 complete: Frontend base project scaffolded with config and directories."
          #!/usr/bin/env bash
          set -e
          
          # ============================
          # Part 6a: Frontend Core Layout & Shared UI Primitives
          # (Creates Layout, Header, Sidebar, and UI components)
          # ============================
          
          cd frontend
          
          # ----------------------------------------
          # 1. Layout: components/layout/Layout.tsx
          # ----------------------------------------
          mkdir -p components/layout
          cat > components/layout/Layout.tsx << 'EOF'
          import React from "react";
          import Header from "./Header";
          import Sidebar from "./Sidebar";
          
          type LayoutProps = {
            children: React.ReactNode;
          };
          
          const Layout: React.FC<LayoutProps> = ({ children }) => {
            return (
              <div className="flex h-screen bg-gray-100">
                <Sidebar />
                <div className="flex flex-col flex-1 overflow-hidden">
                  <Header />
                  <main className="flex-1 overflow-y-auto p-6">{children}</main>
                </div>
              </div>
            );
          };
          
          export default Layout;
          EOF
          
          # ----------------------------------------
          # 2. Header: components/layout/Header.tsx
          # ----------------------------------------
          cat > components/layout/Header.tsx << 'EOF'
          import React from "react";
          import { useSession, signOut } from "next-auth/react";
          
          const Header: React.FC = () => {
            const { data: session } = useSession();
          
            return (
              <header className="flex items-center justify-between bg-white shadow px-4 h-16">
                <h1 className="text-xl font-semibold text-gray-800">Legacy Pro</h1>
                <div className="flex items-center">
                  {session?.user?.name && (
                    <span className="mr-4 text-gray-600">Hello, {session.user.name}</span>
                  )}
                  {session ? (
                    <button
                      onClick={() => signOut()}
                      className="text-sm text-red-600 hover:text-red-800"
                    >
                      Sign Out
                    </button>
                  ) : (
                    <a href="/auth/signin" className="text-sm text-blue-600 hover:text-blue-800">
                      Sign In
                    </a>
                  )}
                </div>
              </header>
            );
          };
          
          export default Header;
          EOF
          
          # ----------------------------------------
          # 3. Sidebar: components/layout/Sidebar.tsx
          # ----------------------------------------
          cat > components/layout/Sidebar.tsx << 'EOF'
          import React from "react";
          import Link from "next/link";
          import {
            Home,
            FileText,
            FileArchive,
            Users,
            Settings,
            Shield,
            Activity,
            Bell,
            Briefcase,
            File,
          } from "lucide-react";
          
          const Sidebar: React.FC = () => {
            const navItems = [
              { name: "Dashboard", href: "/dashboard", icon: Home },
              { name: "Trust Builder", href: "/trust-builder", icon: Briefcase },
              { name: "Entity Builder", href: "/entity-builder", icon: Users },
              { name: "Legacy Letter", href: "/legacy-letter", icon: FileText },
              { name: "Vault", href: "/vault", icon: FileArchive },
              { name: "Protection Score", href: "/protection-score", icon: Shield },
              { name: "Notifications", href: "/notifications", icon: Bell },
              { name: "Settings", href: "/settings", icon: Settings },
              { name: "Admin", href: "/admin", icon: Activity },
            ];
          
            return (
              <aside className="w-64 bg-white border-r">
                <nav className="mt-6">
                  {navItems.map((item) => (
                    <Link key={item.name} href={item.href}>
                      <a className="flex items-center px-4 py-2 text-gray-700 hover:bg-gray-200">
                        <item.icon className="w-5 h-5 mr-3" />
                        <span className="text-sm">{item.name}</span>
                      </a>
                    </Link>
                  ))}
                </nav>
              </aside>
            );
          };
          
          export default Sidebar;
          EOF
          
          # ----------------------------------------
          # 4. Shared UI Primitives: components/ui
          # ----------------------------------------
          mkdir -p components/ui
          
          # 4a. Button: components/ui/Button.tsx
          cat > components/ui/Button.tsx << 'EOF'
          import React from "react";
          import { Button as ShadcnButton } from "shadcn-ui";
          
          type ButtonProps = React.ComponentProps<typeof ShadcnButton> & {
            children: React.ReactNode;
          };
          
          const Button: React.FC<ButtonProps> = ({ children, ...props }) => {
            return (
              <ShadcnButton {...props} className="bg-blue-600 hover:bg-blue-700 text-white">
                {children}
              </ShadcnButton>
            );
          };
          
          export default Button;
          EOF
          
          # 4b. Card: components/ui/Card.tsx
          cat > components/ui/Card.tsx << 'EOF'
          import React from "react";
          
          type CardProps = {
            children: React.ReactNode;
          };
          
          const Card: React.FC<CardProps> = ({ children }) => {
            return (
              <div className="bg-white rounded-2xl shadow p-4 mb-4">
                {children}
              </div>
            );
          };
          
          export default Card;
          EOF
          
          # 4c. Input: components/ui/Input.tsx
          cat > components/ui/Input.tsx << 'EOF'
          import React from "react";
          
          type InputProps = React.InputHTMLAttributes<HTMLInputElement>;
          
          const Input: React.FC<InputProps> = (props) => {
            return (
              <input
                className="w-full border border-gray-300 rounded p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                {...props}
              />
            );
          };
          
          export default Input;
          EOF
          
          # 4d. Modal: components/ui/Modal.tsx
          cat > components/ui/Modal.tsx << 'EOF'
          import React from "react";
          import { motion, AnimatePresence } from "framer-motion";
          
          type ModalProps = {
            isOpen: boolean;
            onClose: () => void;
            title: string;
            children: React.ReactNode;
          };
          
          const Modal: React.FC<ModalProps> = ({ isOpen, onClose, title, children }) => {
            return (
              <AnimatePresence>
                {isOpen && (
                  <motion.div
                    className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center"
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                  >
                    <motion.div
                      className="bg-white rounded-2xl shadow-lg max-w-lg w-full p-6"
                      initial={{ scale: 0.8 }}
                      animate={{ scale: 1 }}
                      exit={{ scale: 0.8 }}
                    >
                      <div className="flex justify-between items-center mb-4">
                        <h2 className="text-lg font-semibold">{title}</h2>
                        <button onClick={onClose} className="text-gray-500 hover:text-gray-700">
                          ×
                        </button>
                      </div>
                      <div>{children}</div>
                    </motion.div>
                  </motion.div>
                )}
              </AnimatePresence>
            );
          };
          
          export default Modal;
          EOF
          
          # 4e. Table: components/ui/Table.tsx
          cat > components/ui/Table.tsx << 'EOF'
          import React from "react";
          
          type TableProps = {
            columns: { header: string; accessor: string }[];
            data: Record<string, any>[];
          };
          
          const Table: React.FC<TableProps> = ({ columns, data }) => {
            return (
              <div className="overflow-x-auto">
                <table className="min-w-full bg-white rounded-2xl shadow">
                  <thead>
                    <tr>
                      {columns.map((col) => (
                        <th
                          key={col.accessor}
                          className="px-4 py-2 text-left text-gray-700 font-medium"
                        >
                          {col.header}
                        </th>
                      ))}
                    </tr>
                  </thead>
                  <tbody>
                    {data.map((row, idx) => (
                      <tr key={idx} className="border-t">
                        {columns.map((col) => (
                          <td key={col.accessor} className="px-4 py-2">
                            {row[col.accessor]}
                          </td>
                        ))}
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            );
          };
          
          export default Table;
          EOF
          
          # 4f. Spinner: components/ui/Spinner.tsx
          cat > components/ui/Spinner.tsx << 'EOF'
          import React from "react";
          
          const Spinner: React.FC = () => {
            return (
              <div className="flex justify-center items-center">
                <div className="animate-spin h-8 w-8 border-4 border-blue-500 border-t-transparent rounded-full"></div>
              </div>
            );
          };
          
          export default Spinner;
          EOF
          
          # Return to project root
          cd ..
          
          echo "Part 6a complete: Core layout and UI primitives created."
          #!/usr/bin/env bash
          set -e
          
          # ============================
          # Part 6b: Frontend Placeholder Pages & Auth Pages
          # (Creates placeholder pages: dashboard, trust-builder, entity-builder, legacy-letter, vault, protection-score, notifications, settings, and auth pages)
          # ============================
          
          cd frontend
          
          # ----------------------------------------
          # 1. Dashboard page: pages/dashboard/index.tsx
          # ----------------------------------------
          mkdir -p pages/dashboard
          cat > pages/dashboard/index.tsx << 'EOF'
          import React from "react";
          import Card from "../../components/ui/Card";
          
          const DashboardPage: React.FC = () => {
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Dashboard</h2>
                <Card>
                  <p>Welcome to your dashboard. Metrics will appear here.</p>
                </Card>
              </div>
            );
          };
          
          export default DashboardPage;
          EOF
          
          # ----------------------------------------
          # 2. Trust Builder page: pages/trust-builder/index.tsx
          # ----------------------------------------
          mkdir -p pages/trust-builder
          cat > pages/trust-builder/index.tsx << 'EOF'
          import React from "react";
          import Card from "../../components/ui/Card";
          
          const TrustBuilderPage: React.FC = () => {
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Trust Builder</h2>
                <Card>
                  <p>Trust Builder form and interface will be here.</p>
                </Card>
              </div>
            );
          };
          
          export default TrustBuilderPage;
          EOF
          
          # ----------------------------------------
          # 3. Entity Builder page: pages/entity-builder/index.tsx
          # ----------------------------------------
          mkdir -p pages/entity-builder
          cat > pages/entity-builder/index.tsx << 'EOF'
          import React from "react";
          import Card from "../../components/ui/Card";
          
          const EntityBuilderPage: React.FC = () => {
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Entity Builder</h2>
                <Card>
                  <p>Entity Builder form and interface will be here.</p>
                </Card>
              </div>
            );
          };
          
          export default EntityBuilderPage;
          EOF
          
          # ----------------------------------------
          # 4. Legacy Letter page: pages/legacy-letter/index.tsx
          # ----------------------------------------
          mkdir -p pages/legacy-letter
          cat > pages/legacy-letter/index.tsx << 'EOF'
          import React from "react";
          import Card from "../../components/ui/Card";
          
          const LegacyLetterPage: React.FC = () => {
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Legacy Letter</h2>
                <Card>
                  <p>Legacy Letter generator and interface will be here.</p>
                </Card>
              </div>
            );
          };
          
          export default LegacyLetterPage;
          EOF
          
          # ----------------------------------------
          # 5. Vault page: pages/vault/index.tsx
          # ----------------------------------------
          mkdir -p pages/vault
          cat > pages/vault/index.tsx << 'EOF'
          import React from "react";
          import Card from "../../components/ui/Card";
          
          const VaultPage: React.FC = () => {
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Vault</h2>
                <Card>
                  <p>Your secure vault files and folders will appear here.</p>
                </Card>
              </div>
            );
          };
          
          export default VaultPage;
          EOF
          
          # ----------------------------------------
          # 6. Protection Score page: pages/protection-score/index.tsx
          # ----------------------------------------
          mkdir -p pages/protection-score
          cat > pages/protection-score/index.tsx << 'EOF'
          import React from "react";
          import Card from "../../components/ui/Card";
          
          const ProtectionScorePage: React.FC = () => {
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Protection Score</h2>
                <Card>
                  <p>Your protection score and recommendations will appear here.</p>
                </Card>
              </div>
            );
          };
          
          export default ProtectionScorePage;
          EOF
          
          # ----------------------------------------
          # 7. Notifications page: pages/notifications/index.tsx
          # ----------------------------------------
          mkdir -p pages/notifications
          cat > pages/notifications/index.tsx << 'EOF'
          import React from "react";
          import Card from "../../components/ui/Card";
          
          const NotificationsPage: React.FC = () => {
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Notifications</h2>
                <Card>
                  <p>Your notifications list will appear here.</p>
                </Card>
              </div>
            );
          };
          
          export default NotificationsPage;
          EOF
          
          # ----------------------------------------
          # 8. Settings page: pages/settings/index.tsx
          # ----------------------------------------
          mkdir -p pages/settings
          cat > pages/settings/index.tsx << 'EOF'
          import React from "react";
          import Card from "../../components/ui/Card";
          
          const SettingsPage: React.FC = () => {
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Settings</h2>
                <Card>
                  <p>User settings and preferences will appear here.</p>
                </Card>
              </div>
            );
          };
          
          export default SettingsPage;
          EOF
          
          # ----------------------------------------
          # 9. Home page redirect to dashboard: pages/index.tsx
          # ----------------------------------------
          cat > pages/index.tsx << 'EOF'
          import { useEffect } from "react";
          import { useRouter } from "next/router";
          
          const Home: React.FC = () => {
            const router = useRouter();
            useEffect(() => {
              router.replace("/dashboard");
            }, [router]);
            return null;
          };
          
          export default Home;
          EOF
          
          # ----------------------------------------
          # 10. Auth Pages: components/auth & pages/auth
          # ----------------------------------------
          mkdir -p components/auth
          mkdir -p pages/auth
          
          # 10a. SignIn: pages/auth/signin.tsx
          cat > pages/auth/signin.tsx << 'EOF'
          import React from "react";
          import { getProviders, signIn } from "next-auth/react";
          import Card from "../../components/ui/Card";
          import Button from "../../components/ui/Button";
          
          export async function getServerSideProps() {
            const providers = await getProviders();
            return {
              props: { providers },
            };
          }
          
          const SignInPage = ({ providers }) => {
            return (
              <div className="flex items-center justify-center h-screen bg-gray-100">
                <Card>
                  <h2 className="text-xl font-semibold mb-4">Sign in to Legacy Pro</h2>
                  {Object.values(providers).map((provider) => (
                    <div key={provider.name} className="mb-2">
                      <Button onClick={() => signIn(provider.id)}>
                        Sign in with {provider.name}
                      </Button>
                    </div>
                  ))}
                </Card>
              </div>
            );
          };
          
          export default SignInPage;
          EOF
          
          # Return to project root
          cd ..
          
          echo "Part 6b complete: Placeholder pages and auth pages created."
          #!/usr/bin/env bash
          set -e
          
          # ============================
          # Part 7: Frontend Forms & API Integration
          # (Implements Trust Builder, Entity Builder, Legacy Letter, and Vault pages with API calls)
          # ============================
          
          cd frontend
          
          # ----------------------------------------
          # 1. Install Axios and SWR
          # ----------------------------------------
          # (If you haven’t already run npm install, ensure dependencies are present)
          # npm install axios swr
          
          # ----------------------------------------
          # 2. Create API utility: utils/api.ts
          # ----------------------------------------
          mkdir -p utils
          cat > utils/api.ts << 'EOF'
          import axios from "axios";
          
          const api = axios.create({
            baseURL: process.env.NEXT_PUBLIC_API_URL + "/api",
            withCredentials: true,
          });
          
          export default api;
          EOF
          
          # ----------------------------------------
          # 3. Trust Builder: pages/trust-builder/index.tsx
          # ----------------------------------------
          cat > pages/trust-builder/index.tsx << 'EOF'
          import React, { useState, useEffect } from "react";
          import Card from "../../components/ui/Card";
          import Button from "../../components/ui/Button";
          import Input from "../../components/ui/Input";
          import { useRouter } from "next/router";
          import api from "../../utils/api";
          import useSWR from "swr";
          
          const fetcher = (url: string) => api.get(url).then(res => res.data);
          
          const TrustBuilderPage: React.FC = () => {
            const router = useRouter();
            const [form, setForm] = useState({
              trustName: "",
              type: "REVOCABLE",
              grantor: { name: "", address: "" },
              trustees: [{ name: "", address: "" }],
              successorTrustees: [{ name: "", address: "" }],
              beneficiaries: [{ name: "", share: "" }],
              state: "",
              assetsIncluded: [""],
              additionalClauses: [] as string[],
            });
            const [clauses, setClauses] = useState<string[]>([]);
            const { data: stateClauses } = useSWR(
              form.state ? \`/trusts/clauses?state=\${form.state}\` : null,
              fetcher
            );
          
            useEffect(() => {
              if (stateClauses?.clauses) {
                setClauses(stateClauses.clauses.map((c: any) => c.id));
              }
            }, [stateClauses]);
          
            const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
              const { name, value } = e.target;
              setForm(prev => ({ ...prev, [name]: value }));
            };
          
            const handleArrayChange = (
              field: string,
              index: number,
              key: string,
              value: string
            ) => {
              setForm(prev => {
                const arr = [...(prev as any)[field]];
                (arr[index] as any)[key] = value;
                return { ...prev, [field]: arr };
              });
            };
          
            const handleAdd = (field: string) => {
              setForm(prev => {
                const arr = [...(prev as any)[field]];
                arr.push(field === "assetsIncluded" ? "" : { name: "", address: "" });
                return { ...prev, [field]: arr };
              });
            };
          
            const handleRemove = (field: string, index: number) => {
              setForm(prev => {
                const arr = [...(prev as any)[field]];
                arr.splice(index, 1);
                return { ...prev, [field]: arr };
              });
            };
          
            const handleSubmit = async () => {
              try {
                const payload = {
                  trustName: form.trustName,
                  type: form.type,
                  grantor: form.grantor,
                  trustees: form.trustees,
                  successorTrustees: form.successorTrustees,
                  beneficiaries: form.beneficiaries,
                  state: form.state,
                  assetsIncluded: form.assetsIncluded,
                  additionalClauses: form.additionalClauses,
                };
                const response = await api.post("/trusts/generate", payload, {
                  responseType: "stream",
                });
                let draft = "";
                response.data.on("data", (chunk: any) => {
                  draft += chunk.toString();
                });
                response.data.on("end", async () => {
                  // Save and redirect
                  router.push("/trust-builder/preview");
                });
              } catch (error) {
                console.error(error);
              }
            };
          
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Trust Builder</h2>
                <Card>
                  <div className="space-y-4">
                    <div>
                      <label className="block text-sm font-medium mb-1">Trust Name</label>
                      <Input
                        name="trustName"
                        value={form.trustName}
                        onChange={handleChange}
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-medium mb-1">State</label>
                      <Input name="state" value={form.state} onChange={handleChange} />
                    </div>
                    {/* Grantor */}
                    <div>
                      <h3 className="text-lg font-medium">Grantor</h3>
                      <Input
                        placeholder="Name"
                        value={form.grantor.name}
                        onChange={e =>
                          setForm(prev => ({
                            ...prev,
                            grantor: { ...prev.grantor, name: e.target.value },
                          }))
                        }
                      />
                      <Input
                        placeholder="Address"
                        value={form.grantor.address}
                        onChange={e =>
                          setForm(prev => ({
                            ...prev,
                            grantor: { ...prev.grantor, address: e.target.value },
                          }))
                        }
                      />
                    </div>
                    {/* Trustees */}
                    <div>
                      <h3 className="text-lg font-medium">Trustees</h3>
                      {form.trustees.map((_, idx) => (
                        <div key={idx} className="flex space-x-2 mb-2">
                          <Input
                            placeholder="Name"
                            value={form.trustees[idx].name}
                            onChange={e =>
                              handleArrayChange("trustees", idx, "name", e.target.value)
                            }
                          />
                          <Input
                            placeholder="Address"
                            value={form.trustees[idx].address}
                            onChange={e =>
                              handleArrayChange("trustees", idx, "address", e.target.value)
                            }
                          />
                          <Button onClick={() => handleRemove("trustees", idx)}>Remove</Button>
                        </div>
                      ))}
                      <Button onClick={() => handleAdd("trustees")}>Add Trustee</Button>
                    </div>
                    {/* Beneficiaries */}
                    <div>
                      <h3 className="text-lg font-medium">Beneficiaries</h3>
                      {form.beneficiaries.map((b, idx) => (
                        <div key={idx} className="flex space-x-2 mb-2">
                          <Input
                            placeholder="Name"
                            value={b.name}
                            onChange={e =>
                              handleArrayChange("beneficiaries", idx, "name", e.target.value)
                            }
                          />
                          <Input
                            placeholder="Share (%)"
                            value={b.share}
                            onChange={e =>
                              handleArrayChange("beneficiaries", idx, "share", e.target.value)
                            }
                          />
                          <Button onClick={() => handleRemove("beneficiaries", idx)}>
                            Remove
                          </Button>
                        </div>
                      ))}
                      <Button onClick={() => handleAdd("beneficiaries")}>
                        Add Beneficiary
                      </Button>
                    </div>
                    {/* Assets */}
                    <div>
                      <h3 className="text-lg font-medium">Assets Included</h3>
                      {form.assetsIncluded.map((asset, idx) => (
                        <div key={idx} className="flex space-x-2 mb-2">
                          <Input
                            placeholder="Asset Description"
                            value={asset}
                            onChange={e =>
                              handleArrayChange("assetsIncluded", idx, "", e.target.value)
                            }
                          />
                          <Button onClick={() => handleRemove("assetsIncluded", idx)}>
                            Remove
                          </Button>
                        </div>
                      ))}
                      <Button onClick={() => handleAdd("assetsIncluded")}>
                        Add Asset
                      </Button>
                    </div>
                    {/* Additional Clauses */}
                    <div>
                      <h3 className="text-lg font-medium">Additional Clauses</h3>
                      {stateClauses?.clauses?.map((clause: any) => (
                        <div key={clause.id} className="flex items-center mb-1">
                          <input
                            type="checkbox"
                            className="mr-2"
                            value={clause.id}
                            onChange={e => {
                              const id = e.target.value;
                              setForm(prev => {
                                const exists = prev.additionalClauses.includes(id);
                                const updated = exists
                                  ? prev.additionalClauses.filter(c => c !== id)
                                  : [...prev.additionalClauses, id];
                                return { ...prev, additionalClauses: updated };
                              });
                            }}
                          />
                          <span className="text-sm">{clause.text.slice(0, 60)}...</span>
                        </div>
                      ))}
                    </div>
                    <Button onClick={handleSubmit}>Generate Trust</Button>
                  </div>
                </Card>
              </div>
            );
          };
          
          export default TrustBuilderPage;
          EOF
          
          # ----------------------------------------
          # 4. Entity Builder: pages/entity-builder/index.tsx
          # ----------------------------------------
          cat > pages/entity-builder/index.tsx << 'EOF'
          import React, { useState } from "react";
          import Card from "../../components/ui/Card";
          import Button from "../../components/ui/Button";
          import Input from "../../components/ui/Input";
          import { useRouter } from "next/router";
          import api from "../../utils/api";
          
          const EntityBuilderPage: React.FC = () => {
            const router = useRouter();
            const [form, setForm] = useState({
              entityName: "",
              type: "LLC",
              owners: [{ name: "", percentage: "" }],
              registeredAgent: { name: "", address: "" },
              state: "",
              purpose: "",
              capital: [{ amount: "" }],
              additionalClauses: [] as string[],
            });
            const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
              const { name, value } = e.target;
              setForm(prev => ({ ...prev, [name]: value }));
            };
            const handleArrayChange = (
              field: string,
              index: number,
              key: string,
              value: string
            ) => {
              setForm(prev => {
                const arr = [...(prev as any)[field]];
                (arr[index] as any)[key] = value;
                return { ...prev, [field]: arr };
              });
            };
            const handleAdd = (field: string, defaultObj: any) => {
              setForm(prev => {
                const arr = [...(prev as any)[field], defaultObj];
                return { ...prev, [field]: arr };
              });
            };
            const handleRemove = (field: string, index: number) => {
              setForm(prev => {
                const arr = [...(prev as any)[field]];
                arr.splice(index, 1);
                return { ...prev, [field]: arr };
              });
            };
            const handleSubmit = async () => {
              try {
                const payload = {
                  entityName: form.entityName,
                  type: form.type,
                  owners: form.owners.map(o => ({ name: o.name, percentage: Number(o.percentage) })),
                  registeredAgent: form.registeredAgent,
                  state: form.state,
                  purpose: form.purpose,
                  capital: form.capital.map(c => ({ amount: Number(c.amount) })),
                  additionalClauses: form.additionalClauses,
                };
                const response = await api.post("/entities/generate", payload, {
                  responseType: "stream",
                });
                let draft = "";
                response.data.on("data", (chunk: any) => {
                  draft += chunk.toString();
                });
                response.data.on("end", async () => {
                  router.push("/entity-builder/preview");
                });
              } catch (error) {
                console.error(error);
              }
            };
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Entity Builder</h2>
                <Card>
                  <div className="space-y-4">
                    <div>
                      <label className="block text-sm font-medium mb-1">Entity Name</label>
                      <Input
                        name="entityName"
                        value={form.entityName}
                        onChange={handleChange}
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-medium mb-1">State</label>
                      <Input name="state" value={form.state} onChange={handleChange} />
                    </div>
                    {/* Owners */}
                    <div>
                      <h3 className="text-lg font-medium">Owners</h3>
                      {form.owners.map((o, idx) => (
                        <div key={idx} className="flex space-x-2 mb-2">
                          <Input
                            placeholder="Name"
                            value={o.name}
                            onChange={e =>
                              handleArrayChange("owners", idx, "name", e.target.value)
                            }
                          />
                          <Input
                            placeholder="Percentage"
                            value={o.percentage}
                            onChange={e =>
                              handleArrayChange("owners", idx, "percentage", e.target.value)
                            }
                          />
                          <Button onClick={() => handleRemove("owners", idx)}>Remove</Button>
                        </div>
                      ))}
                      <Button onClick={() => handleAdd("owners", { name: "", percentage: "" })}>
                        Add Owner
                      </Button>
                    </div>
                    {/* Registered Agent */}
                    <div>
                      <h3 className="text-lg font-medium">Registered Agent</h3>
                      <Input
                        placeholder="Name"
                        value={form.registeredAgent.name}
                        onChange={e =>
                          setForm(prev => ({
                            ...prev,
                            registeredAgent: { ...prev.registeredAgent, name: e.target.value },
                          }))
                        }
                      />
                      <Input
                        placeholder="Address"
                        value={form.registeredAgent.address}
                        onChange={e =>
                          setForm(prev => ({
                            ...prev,
                            registeredAgent: { ...prev.registeredAgent, address: e.target.value },
                          }))
                        }
                      />
                    </div>
                    {/* Capital Contributions */}
                    <div>
                      <h3 className="text-lg font-medium">Capital Contributions</h3>
                      {form.capital.map((c, idx) => (
                        <div key={idx} className="flex space-x-2 mb-2">
                          <Input
                            placeholder="Amount"
                            value={c.amount}
                            onChange={e =>
                              handleArrayChange("capital", idx, "amount", e.target.value)
                            }
                          />
                          <Button onClick={() => handleRemove("capital", idx)}>Remove</Button>
                        </div>
                      ))}
                      <Button onClick={() => handleAdd("capital", { amount: "" })}>
                        Add Contribution
                      </Button>
                    </div>
                    <Button onClick={handleSubmit}>Generate Entity</Button>
                  </div>
                </Card>
              </div>
            );
          };
          
          export default EntityBuilderPage;
          EOF
          
          # ----------------------------------------
          # 5. Legacy Letter: pages/legacy-letter/index.tsx
          # ----------------------------------------
          cat > pages/legacy-letter/index.tsx << 'EOF'
          import React, { useState } from "react";
          import Card from "../../components/ui/Card";
          import Button from "../../components/ui/Button";
          import Input from "../../components/ui/Input";
          import { useRouter } from "next/router";
          import api from "../../utils/api";
          
          const LegacyLetterPage: React.FC = () => {
            const router = useRouter();
            const [tone, setTone] = useState("");
            const [recipients, setRecipients] = useState([{ name: "" }]);
            const [attachedDocs, setAttachedDocs] = useState<string[]>([]);
            const handleRecipientChange = (index: number, value: string) => {
              const newArr = [...recipients];
              newArr[index].name = value;
              setRecipients(newArr);
            };
            const handleAddRecipient = () => {
              setRecipients(prev => [...prev, { name: "" }]);
            };
            const handleRemoveRecipient = (index: number) => {
              const newArr = [...recipients];
              newArr.splice(index, 1);
              setRecipients(newArr);
            };
            const handleSubmit = async () => {
              try {
                const payload = { tone, recipients: recipients.map(r => r.name), attachedDocs };
                const response = await api.post("/legacy-letter/generate", payload, {
                  responseType: "stream",
                });
                let draft = "";
                response.data.on("data", (chunk: any) => {
                  draft += chunk.toString();
                });
                response.data.on("end", async () => {
                  router.push("/legacy-letter/preview");
                });
              } catch (error) {
                console.error(error);
              }
            };
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Legacy Letter</h2>
                <Card>
                  <div className="space-y-4">
                    <div>
                      <label className="block text-sm font-medium mb-1">Tone</label>
                      <Input value={tone} onChange={e => setTone(e.target.value)} />
                    </div>
                    <div>
                      <h3 className="text-lg font-medium">Recipients</h3>
                      {recipients.map((r, idx) => (
                        <div key={idx} className="flex space-x-2 mb-2">
                          <Input
                            placeholder="Recipient Name"
                            value={r.name}
                            onChange={e => handleRecipientChange(idx, e.target.value)}
                          />
                          <Button onClick={() => handleRemoveRecipient(idx)}>Remove</Button>
                        </div>
                      ))}
                      <Button onClick={handleAddRecipient}>Add Recipient</Button>
                    </div>
                    {/* Attached Docs: This could be a multiselect from Vault; simplified as comma-separated */}
                    <div>
                      <label className="block text-sm font-medium mb-1">Attached Docs (comma-separated keys)</label>
                      <Input
                        value={attachedDocs.join(",")}
                        onChange={e => setAttachedDocs(e.target.value.split(","))}
                      />
                    </div>
                    <Button onClick={handleSubmit}>Generate Letter</Button>
                  </div>
                </Card>
              </div>
            );
          };
          
          export default LegacyLetterPage;
          EOF
          
          # ----------------------------------------
          # 6. Vault Page with Folder & File Display: pages/vault/index.tsx
          # ----------------------------------------
          cat > pages/vault/index.tsx << 'EOF'
          import React, { useState, useEffect } from "react";
          import Card from "../../components/ui/Card";
          import Button from "../../components/ui/Button";
          import Input from "../../components/ui/Input";
          import api from "../../utils/api";
          import useSWR from "swr";
          
          const fetcher = (url: string) => api.get(url).then(res => res.data);
          
          const VaultPage: React.FC = () => {
            const { data: folders } = useSWR("/vault", fetcher);
            const [selectedFolder, setSelectedFolder] = useState<string | null>(null);
            const { data: files } = useSWR(
              selectedFolder ? \`/vault/folders/\${selectedFolder}/files\` : null,
              fetcher
            );
            const [newFolderName, setNewFolderName] = useState("");
            const createFolder = async () => {
              try {
                await api.post("/vault/folders", {
                  name: newFolderName,
                  parentId: selectedFolder,
                });
                setNewFolderName("");
                // Revalidate
                useSWR("/vault", fetcher).mutate();
              } catch (error) {
                console.error(error);
              }
            };
            const getUploadUrl = async (file: File) => {
              const { data } = await api.post("/vault/upload-url", {
                fileName: file.name,
                fileType: file.type,
                size: file.size,
              });
              return data;
            };
            const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
              if (!e.target.files || !selectedFolder) return;
              const file = e.target.files[0];
              try {
                const { key, url } = await getUploadUrl(file);
                await fetch(url, { method: "PUT", body: file });
                await api.post("/vault/files", {
                  fileName: file.name,
                  fileType: file.type,
                  size: file.size,
                  folderId: selectedFolder,
                  s3Key: key,
                });
                // Revalidate
                useSWR(\`/vault/folders/\${selectedFolder}/files\`, fetcher).mutate();
              } catch (error) {
                console.error(error);
              }
            };
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Vault</h2>
                <div className="flex space-x-6">
                  {/* Folder List */}
                  <Card className="w-1/4">
                    <h3 className="text-lg font-medium mb-2">Folders</h3>
                    <ul>
                      {folders?.map((f: any) => (
                        <li key={f.id}>
                          <button
                            className="text-blue-600 hover:underline"
                            onClick={() => setSelectedFolder(f.id)}
                          >
                            {f.name}
                          </button>
                        </li>
                      ))}
                    </ul>
                    <div className="mt-4">
                      <Input
                        placeholder="New Folder Name"
                        value={newFolderName}
                        onChange={e => setNewFolderName(e.target.value)}
                      />
                      <Button onClick={createFolder}>Create Folder</Button>
                    </div>
                  </Card>
                  {/* File List */}
                  <Card className="flex-1">
                    <h3 className="text-lg font-medium mb-2">
                      {selectedFolder ? "Files" : "Select a Folder"}
                    </h3>
                    {selectedFolder && (
                      <>
                        <input type="file" onChange={handleFileChange} />
                        <ul className="mt-4">
                          {files?.map((file: any) => (
                            <li key={file.id} className="flex justify-between mb-2">
                              <span>{file.fileName}</span>
                              <a
                                href={file.url}
                                className="text-blue-600 hover:underline"
                                target="_blank"
                                rel="noopener noreferrer"
                              >
                                Download
                              </a>
                            </li>
                          ))}
                        </ul>
                      </>
                    )}
                  </Card>
                </div>
              </div>
            );
          };
          
          export default VaultPage;
          EOF
          
          # ----------------------------------------
          # 7. Protection Score Integration: pages/protection-score/index.tsx
          # ----------------------------------------
          cat > pages/protection-score/index.tsx << 'EOF'
          import React from "react";
          import useSWR from "swr";
          import api from "../../utils/api";
          import Card from "../../components/ui/Card";
          
          const fetcher = (url: string) => api.get(url).then(res => res.data);
          
          const ProtectionScorePage: React.FC = () => {
            const { data } = useSWR("/protection-score", fetcher);
            if (!data) return <Card><p>Loading...</p></Card>;
          
            const { score, breakdown, suggestions } = data;
          
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Protection Score</h2>
                <Card>
                  <p className="text-xl">Total Score: {score}</p>
                  <div className="mt-4">
                    <h3 className="text-lg font-medium">Breakdown:</h3>
                    <ul className="list-disc ml-6">
                      <li>Trust: {breakdown.trust}</li>
                      <li>Entity: {breakdown.entity}</li>
                      <li>Vault: {breakdown.vault}</li>
                      <li>Security: {breakdown.security}</li>
                      <li>Financial: {breakdown.financial}</li>
                    </ul>
                  </div>
                  <div className="mt-4">
                    <h3 className="text-lg font-medium">Suggestions:</h3>
                    <ul className="list-disc ml-6">
                      {suggestions.map((s: string, idx: number) => (
                        <li key={idx}>{s}</li>
                      ))}
                    </ul>
                  </div>
                </Card>
              </div>
            );
          };
          
          export default ProtectionScorePage;
          EOF
          
          # ----------------------------------------
          # 8. Notifications List with Mark-as-Read: pages/notifications/index.tsx
          # ----------------------------------------
          cat > pages/notifications/index.tsx << 'EOF'
          import React from "react";
          import useSWR from "swr";
          import api from "../../utils/api";
          import Card from "../../components/ui/Card";
          import Button from "../../components/ui/Button";
          
          const fetcher = (url: string) => api.get(url).then(res => res.data);
          
          const NotificationsPage: React.FC = () => {
            const { data, mutate } = useSWR("/notifications", fetcher);
            if (!data) return <Card><p>Loading...</p></Card>;
          
            const markRead = async (id: string) => {
              await api.patch(\`/users/notifications/\${id}/mark-read\`);
              mutate();
            };
          
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Notifications</h2>
                {data.map((notif: any) => (
                  <Card key={notif.id}>
                    <div className="flex justify-between items-center">
                      <p>{notif.content.message}</p>
                      {!notif.read && (
                        <Button onClick={() => markRead(notif.id)}>Mark as Read</Button>
                      )}
                    </div>
                  </Card>
                ))}
              </div>
            );
          };
          
          export default NotificationsPage;
          EOF
          
          # ----------------------------------------
          # 9. Settings: pages/settings/index.tsx (user details & 2FA toggle)
          # ----------------------------------------
          cat > pages/settings/index.tsx << 'EOF'
          import React, { useState, useEffect } from "react";
          import useSWR from "swr";
          import api from "../../utils/api";
          import Card from "../../components/ui/Card";
          import Button from "../../components/ui/Button";
          import Input from "../../components/ui/Input";
          
          const fetcher = (url: string) => api.get(url).then(res => res.data);
          
          const SettingsPage: React.FC = () => {
            const { data: user } = useSWR("/users/me", fetcher);
            const [name, setName] = useState("");
            const [locale, setLocale] = useState("");
            const [twoFASetupUrl, setTwoFASetupUrl] = useState<string | null>(null);
            const [twoFAToken, setTwoFAToken] = useState("");
            useEffect(() => {
              if (user) {
                setName(user.name || "");
                setLocale(user.locale || "");
              }
            }, [user]);
          
            const updateProfile = async () => {
              await api.patch("/users/me", { name, locale });
              alert("Profile updated");
            };
          
            const setup2FA = async () => {
              const res = await api.post("/users/me/2fa/setup");
              setTwoFASetupUrl(res.data.qrCodeDataURL);
            };
          
            const verify2FA = async () => {
              await api.post("/users/me/2fa/verify", { token: twoFAToken });
              alert("2FA enabled");
            };
          
            const disable2FA = async () => {
              await api.delete("/users/me/2fa");
              alert("2FA disabled");
            };
          
            if (!user) return <Card><p>Loading...</p></Card>;
          
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Settings</h2>
                <Card>
                  <div className="space-y-4">
                    <div>
                      <label className="block text-sm font-medium mb-1">Name</label>
                      <Input value={name} onChange={e => setName(e.target.value)} />
                    </div>
                    <div>
                      <label className="block text-sm font-medium mb-1">Locale</label>
                      <Input value={locale} onChange={e => setLocale(e.target.value)} />
                    </div>
                    <Button onClick={updateProfile}>Update Profile</Button>
                  </div>
                </Card>
                <Card>
                  <h3 className="text-lg font-medium mb-2">Two-Factor Authentication</h3>
                  {!user.twoFAEnabled ? (
                    <>
                      <Button onClick={setup2FA}>Setup 2FA</Button>
                      {twoFASetupUrl && (
                        <div className="mt-4">
                          <img src={twoFASetupUrl} alt="QR Code" />
                          <Input
                            placeholder="Enter token"
                            value={twoFAToken}
                            onChange={e => setTwoFAToken(e.target.value)}
                            className="mt-2"
                          />
                          <Button onClick={verify2FA}>Verify 2FA</Button>
                        </div>
                      )}
                    </>
                  ) : (
                    <Button onClick={disable2FA}>Disable 2FA</Button>
                  )}
                </Card>
              </div>
            );
          };
          
          export default SettingsPage;
          EOF
          
          # Return to project root
          cd ..
          
          echo "Part 7 complete: Form pages and API integration implemented."
          #!/usr/bin/env bash
          set -e
          
          # ============================
          # Part 8: Frontend Preview Pages & Admin and Audit UI
          # (Creates preview pages for Trust, Entity, Legacy Letter, and Admin metrics/audit log pages)
          # ============================
          
          cd frontend
          
          # ----------------------------------------
          # 1. Trust Preview Page: pages/trust-builder/preview.tsx
          # ----------------------------------------
          mkdir -p pages/trust-builder
          cat > pages/trust-builder/preview.tsx << 'EOF'
          import React, { useEffect, useState } from "react";
          import Card from "../../components/ui/Card";
          import Button from "../../components/ui/Button";
          import api from "../../utils/api";
          import useSWR from "swr";
          
          const fetcher = (url: string) => api.get(url).then(res => res.data);
          
          const TrustPreviewPage: React.FC = () => {
            const { data, mutate } = useSWR("/trusts/latest", fetcher);
            const [loading, setLoading] = useState(false);
          
            const finalizeTrust = async () => {
              setLoading(true);
              try {
                const { id } = data;
                const res = await api.post(\`/trusts/\${id}/finalize\`);
                window.open(res.data.url, "_blank");
                mutate();
              } catch (err) {
                console.error(err);
              } finally {
                setLoading(false);
              }
            };
          
            if (!data) return <Card><p>Loading...</p></Card>;
          
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Trust Preview</h2>
                <Card>
                  <div className="whitespace-pre-wrap mb-4">{data.data.text}</div>
                  <Button onClick={finalizeTrust} disabled={loading}>
                    {loading ? "Finalizing..." : "Finalize & Download"}
                  </Button>
                </Card>
              </div>
            );
          };
          
          export default TrustPreviewPage;
          EOF
          
          # ----------------------------------------
          # 2. Entity Preview Page: pages/entity-builder/preview.tsx
          # ----------------------------------------
          mkdir -p pages/entity-builder
          cat > pages/entity-builder/preview.tsx << 'EOF'
          import React, { useEffect, useState } from "react";
          import Card from "../../components/ui/Card";
          import Button from "../../components/ui/Button";
          import api from "../../utils/api";
          import useSWR from "swr";
          
          const fetcher = (url: string) => api.get(url).then(res => res.data);
          
          const EntityPreviewPage: React.FC = () => {
            const { data, mutate } = useSWR("/entities/latest", fetcher);
            const [loading, setLoading] = useState(false);
          
            const finalizeEntity = async () => {
              setLoading(true);
              try {
                const { id } = data;
                const res = await api.post(\`/entities/\${id}/finalize\`);
                window.open(res.data.url, "_blank");
                mutate();
              } catch (err) {
                console.error(err);
              } finally {
                setLoading(false);
              }
            };
          
            if (!data) return <Card><p>Loading...</p></Card>;
          
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Entity Preview</h2>
                <Card>
                  <div className="whitespace-pre-wrap mb-4">{data.data.text}</div>
                  <Button onClick={finalizeEntity} disabled={loading}>
                    {loading ? "Finalizing..." : "Finalize & Download"}
                  </Button>
                </Card>
              </div>
            );
          };
          
          export default EntityPreviewPage;
          EOF
          
          # ----------------------------------------
          # 3. Legacy Letter Preview Page: pages/legacy-letter/preview.tsx
          # ----------------------------------------
          mkdir -p pages/legacy-letter
          cat > pages/legacy-letter/preview.tsx << 'EOF'
          import React, { useEffect, useState } from "react";
          import Card from "../../components/ui/Card";
          import Button from "../../components/ui/Button";
          import api from "../../utils/api";
          import useSWR from "swr";
          
          const fetcher = (url: string) => api.get(url).then(res => res.data);
          
          const LegacyLetterPreviewPage: React.FC = () => {
            const { data, mutate } = useSWR("/legacy-letter/latest", fetcher);
            const [loading, setLoading] = useState(false);
          
            const finalizeLetter = async () => {
              setLoading(true);
              try {
                const { id } = data;
                const res = await api.post(\`/legacy-letter/\${id}/finalize\`);
                window.open(res.data.url, "_blank");
                mutate();
              } catch (err) {
                console.error(err);
              } finally {
                setLoading(false);
              }
            };
          
            if (!data) return <Card><p>Loading...</p></Card>;
          
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Legacy Letter Preview</h2>
                <Card>
                  <div className="whitespace-pre-wrap mb-4">{data.body}</div>
                  <Button onClick={finalizeLetter} disabled={loading}>
                    {loading ? "Finalizing..." : "Finalize & Download"}
                  </Button>
                </Card>
              </div>
            );
          };
          
          export default LegacyLetterPreviewPage;
          EOF
          
          # ----------------------------------------
          # 4. Admin Metrics Page: pages/admin/index.tsx
          # ----------------------------------------
          mkdir -p pages/admin
          cat > pages/admin/index.tsx << 'EOF'
          import React from "react";
          import useSWR from "swr";
          import api from "../../utils/api";
          import Card from "../../components/ui/Card";
          import Table from "../../components/ui/Table";
          
          const fetcher = (url: string) => api.get(url).then(res => res.data);
          
          const AdminMetricsPage: React.FC = () => {
            const { data: userMetrics } = useSWR("/admin/metrics/users", fetcher);
            const { data: subMetrics } = useSWR("/admin/metrics/subscriptions", fetcher);
            const { data: vaultMetrics } = useSWR("/admin/metrics/vault", fetcher);
            const { data: apiUsageMetrics } = useSWR("/admin/metrics/api-usage", fetcher);
          
            if (!userMetrics || !subMetrics || !vaultMetrics || !apiUsageMetrics)
              return <Card><p>Loading...</p></Card>;
          
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Admin Metrics</h2>
                <Card>
                  <h3 className="text-lg font-medium">Users Growth (Last 12 Months)</h3>
                  <Table
                    columns={[{ header: "Month", accessor: "month" }, { header: "Count", accessor: "count" }]}
                    data={userMetrics.growth}
                  />
                  <p className="mt-2">Total Users: {userMetrics.totalUsers}</p>
                </Card>
                <Card>
                  <h3 className="text-lg font-medium">Subscriptions by Plan</h3>
                  <Table
                    columns={Object.keys(subMetrics.byPlan).map(plan => ({ header: plan, accessor: plan }))}
                    data={[subMetrics.byPlan]}
                  />
                  <p className="mt-2">Churn Rate: {subMetrics.churnRate.toFixed(2)}</p>
                </Card>
                <Card>
                  <h3 className="text-lg font-medium">Vault Usage (Last 12 Months)</h3>
                  <Table
                    columns={[{ header: "Month", accessor: "month" }, { header: "Bytes", accessor: "bytes" }]}
                    data={vaultMetrics.monthlyUsage}
                  />
                </Card>
                <Card>
                  <h3 className="text-lg font-medium">API Usage by Feature</h3>
                  <Table
                    columns={Object.keys(apiUsageMetrics.callsByFeature).map(f => ({ header: f, accessor: f }))}
                    data={[apiUsageMetrics.callsByFeature]}
                  />
                  <p className="mt-2">Error Rate: {apiUsageMetrics.errorRate}</p>
                </Card>
              </div>
            );
          };
          
          export default AdminMetricsPage;
          EOF
          
          # ----------------------------------------
          # 5. Admin Audit Logs Page: pages/admin/audit-logs.tsx
          # ----------------------------------------
          cat > pages/admin/audit-logs.tsx << 'EOF'
          import React, { useState } from "react";
          import useSWR from "swr";
          import api from "../../utils/api";
          import Card from "../../components/ui/Card";
          import Input from "../../components/ui/Input";
          import Button from "../../components/ui/Button";
          import Table from "../../components/ui/Table";
          
          const fetcher = (url: string) => api.get(url).then(res => res.data);
          
          const AuditLogsPage: React.FC = () => {
            const [filters, setFilters] = useState({ resourceType: "", action: "" });
            const { data } = useSWR(
              \`/admin/audit-logs?resourceType=\${filters.resourceType}&action=\${filters.action}\`,
              fetcher
            );
          
            if (!data) return <Card><p>Loading...</p></Card>;
          
            const columns = [
              { header: "Timestamp", accessor: "timestamp" },
              { header: "User", accessor: "user.name" },
              { header: "Resource", accessor: "resourceType" },
              { header: "Action", accessor: "action" },
            ];
          
            return (
              <div>
                <h2 className="text-2xl font-semibold mb-4">Audit Logs</h2>
                <Card>
                  <div className="flex space-x-2 mb-4">
                    <Input
                      placeholder="Resource Type"
                      value={filters.resourceType}
                      onChange={e => setFilters(prev => ({ ...prev, resourceType: e.target.value }))}
                    />
                    <Input
                      placeholder="Action"
                      value={filters.action}
                      onChange={e => setFilters(prev => ({ ...prev, action: e.target.value }))}
                    />
                    <Button onClick={() => useSWR(\`/admin/audit-logs?resourceType=\${filters.resourceType}&action=\${filters.action}\`, fetcher).mutate()}>
                      Filter
                    </Button>
                  </div>
                  <Table columns={columns} data={data} />
                </Card>
              </div>
            );
          };
          
          export default AuditLogsPage;
          EOF
          
          # Return to project root
          cd ..
          
          echo "Part 8 complete: Preview pages and admin UI created."
          #!/usr/bin/env bash
          set -e
          
          # ============================
          # Part 9: Email Templates & Push Notifications Setup, Final Touches
          # ============================
          
          # ----------------------------
          # A. Backend Email Templates
          # ----------------------------
          cd backend
          
          # Create email templates directory
          mkdir -p config/email/templates
          
          # 1. Welcome Email Template: config/email/templates/welcome.html
          cat > config/email/templates/welcome.html << 'EOF'
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="UTF-8" />
              <title>Welcome to Legacy Pro</title>
            </head>
            <body style="font-family: Arial, sans-serif; color: #333;">
              <h2>Welcome, {{userName}}!</h2>
              <p>Thank you for signing up for Legacy Pro. We're excited to help you plan and protect your legacy.</p>
              <p>Here are a few resources to get started:</p>
              <ul>
                <li><a href="{{frontendUrl}}/dashboard">Your Dashboard</a></li>
                <li><a href="{{frontendUrl}}/vault">Your Secure Vault</a></li>
                <li><a href="{{frontendUrl}}/settings">Account Settings</a></li>
              </ul>
              <p>If you have any questions, reply to this email or visit our <a href="{{frontendUrl}}/help">Help Center</a>.</p>
              <p>Best regards,<br />The Legacy Pro Team</p>
            </body>
          </html>
          EOF
          
          # 2. Emergency Access Granted Email: config/email/templates/emergency_access.html
          cat > config/email/templates/emergency_access.html << 'EOF'
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="UTF-8" />
              <title>Emergency Access Granted</title>
            </head>
            <body style="font-family: Arial, sans-serif; color: #333;">
              <h2>Emergency Access Granted</h2>
              <p>Hello,</p>
              <p>{{grantorName}} has granted you emergency access to their vault folder: <strong>{{folderPath}}</strong>.</p>
              <p>Click the link below to view the files (expires on {{expiresAt}}):</p>
              <p><a href="{{frontendUrl}}/emergency/{{code}}">{{frontendUrl}}/emergency/{{code}}</a></p>
              <p>If you have any issues, please contact support.</p>
              <p>Best,<br />The Legacy Pro Team</p>
            </body>
          </html>
          EOF
          
          # 3. Check-In Reminder Email: config/email/templates/checkin_reminder.html
          cat > config/email/templates/checkin_reminder.html << 'EOF'
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="UTF-8" />
              <title>Time to Review Your Estate Plan</title>
            </head>
            <body style="font-family: Arial, sans-serif; color: #333;">
              <h2>Reminder: Time to Review Your Estate Plan</h2>
              <p>Hello {{userName}},</p>
              <p>It's time for your scheduled check-in to review and update your estate plan.</p>
              <p>Please log in to your dashboard to ensure everything is up to date:</p>
              <p><a href="{{frontendUrl}}/dashboard">{{frontendUrl}}/dashboard</a></p>
              <p>If you'd like to adjust your check-in frequency or date, go to <a href="{{frontendUrl}}/settings">{{frontendUrl}}/settings</a>.</p>
              <p>Best,<br />The Legacy Pro Team</p>
            </body>
          </html>
          EOF
          
          # 4. Configure email sender to use templates: config/email/index.ts
          cat > config/email/index.ts << 'EOF'
          import nodemailer from "nodemailer";
          import fs from "fs";
          import path from "path";
          import handlebars from "handlebars";
          
          const transporter = nodemailer.createTransport({
            host: process.env.EMAIL_HOST,
            port: Number(process.env.EMAIL_PORT),
            secure: process.env.EMAIL_SECURE === "true",
            auth: {
              user: process.env.EMAIL_USER,
              pass: process.env.EMAIL_PASS,
            },
          });
          
          function loadTemplate(templateName: string, context: Record<string, any>) {
            const filePath = path.join(__dirname, "templates", \`\${templateName}.html\`);
            const source = fs.readFileSync(filePath, "utf8");
            const compiled = handlebars.compile(source);
            return compiled(context);
          }
          
          export interface EmailOptions {
            to: string;
            subject: string;
            template: string;
            context: Record<string, any>;
          }
          
          export default async function sendEmail(options: EmailOptions) {
            const html = loadTemplate(options.template, options.context);
            await transporter.sendMail({
              from: process.env.EMAIL_FROM,
              to: options.to,
              subject: options.subject,
              html,
            });
          }
          EOF
          
          # 5. Update existing calls to sendEmail (e.g., in emergency route and jobs) to pass template and context
          # (Assuming those files already call sendEmail; no changes to script here)
          
          cd ..
          
          # ----------------------------
          # B. Frontend Push Notification Registration
          # ----------------------------
          cd frontend
          
          # 1. Install Firebase SDK
          # npm install firebase
          
          # 2. Create Firebase config: utils/firebase.ts
          mkdir -p utils
          cat > utils/firebase.ts << 'EOF'
          import { initializeApp, getApps } from "firebase/app";
          import { getMessaging, getToken, onMessage } from "firebase/messaging";
          
          const firebaseConfig = {
            apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
            authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
            projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
            storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
            messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_SENDER_ID,
            appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
          };
          
          const app = !getApps().length ? initializeApp(firebaseConfig) : getApps()[0];
          export const messaging = getMessaging(app);
          
          export async function registerPushToken() {
            try {
              const permission = await Notification.requestPermission();
              if (permission !== "granted") return;
              const token = await getToken(messaging, {
                vapidKey: process.env.NEXT_PUBLIC_FIREBASE_VAPID_KEY,
              });
              if (token) {
                await fetch(\`\${process.env.NEXT_PUBLIC_API_URL}/api/push-notifications/send-token\`, {
                  method: "POST",
                  credentials: "include",
                  headers: {
                    "Content-Type": "application/json",
                  },
                  body: JSON.stringify({ token }),
                });
              }
            } catch (error) {
              console.error("Push registration failed:", error);
            }
          }
          
          export function onPushMessage(callback: (payload: any) => void) {
            onMessage(messaging, (payload) => {
              callback(payload);
            });
          }
          EOF
          
          # 3. Create API route in backend to save token: backend/src/routes/push-notifications/register.ts
          cd ../backend
          mkdir -p src/routes/push-notifications
          cat > src/routes/push-notifications/register.ts << 'EOF'
          import express from "express";
          import authMiddleware from "../../middleware/auth";
          import prisma from "../../../prismaClient";
          import ApiError from "../../utils/ApiError";
          
          const router = express.Router();
          
          // POST /api/push-notifications/send-token
          router.post("/send-token", authMiddleware, async (req, res, next) => {
            try {
              const { token } = req.body;
              if (!token) throw new ApiError(400, "Token is required");
              await prisma.pushToken.upsert({
                where: { userId_token: { userId: req.user.id, token } },
                update: {},
                create: { userId: req.user.id, token },
              });
              res.json({ message: "Token registered" });
            } catch (err) {
              next(err);
            }
          });
          
          export default router;
          EOF
          
          # 4. Ensure this new route is imported in backend routing (e.g., in main server file)
          # (Assumes backend/src/index.ts or server.ts imports routes; manually verify)
          
          cd ../frontend
          
          # 5. Call registerPushToken on app load: components/layout/Layout.tsx
          # Append useEffect to call registration
          cat > components/layout/Layout.tsx << 'EOF'
          import React, { useEffect } from "react";
          import Header from "./Header";
          import Sidebar from "./Sidebar";
          import { registerPushToken, onPushMessage } from "../utils/firebase";
          
          type LayoutProps = {
            children: React.ReactNode;
          };
          
          const Layout: React.FC<LayoutProps> = ({ children }) => {
            useEffect(() => {
              registerPushToken();
              onPushMessage((payload) => {
                // Optionally handle in-app push notifications, e.g., alert or toast
                console.log("Push message:", payload);
              });
            }, []);
          
            return (
              <div className="flex h-screen bg-gray-100">
                <Sidebar />
                <div className="flex flex-col flex-1 overflow-hidden">
                  <Header />
                  <main className="flex-1 overflow-y-auto p-6">{children}</main>
                </div>
              </div>
            );
          };
          
          export default Layout;
          EOF
          
          # 6. Add environment variables template: .env.local
          cat > .env.local << 'EOF'
          # Backend API
          NEXT_PUBLIC_API_URL=http://localhost:4000
          
          # NextAuth
          NEXTAUTH_SECRET=your_nextauth_secret_here
          
          # Firebase (get these from your Firebase console)
          NEXT_PUBLIC_FIREBASE_API_KEY=your_firebase_api_key
          NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=your_project.firebaseapp.com
          NEXT_PUBLIC_FIREBASE_PROJECT_ID=your_project_id
          NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=your_project.appspot.com
          NEXT_PUBLIC_FIREBASE_SENDER_ID=your_messaging_sender_id
          NEXT_PUBLIC_FIREBASE_APP_ID=your_app_id
          NEXT_PUBLIC_FIREBASE_VAPID_KEY=your_vapid_key
          EOF
          
          cd ..
          
          echo "Part 9 complete: Email templates and push notification registration added."
          
          